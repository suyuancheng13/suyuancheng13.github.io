{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/cppr.png","path":"uploads/cppr.png","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/cr.png","path":"uploads/cr.png","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/csr.png","path":"uploads/csr.png","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/wechatpay.png","path":"uploads/wechatpay.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1655277625152},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1655277795012},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1655277795011},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1655277795011},{"_id":"themes/next/.DS_Store","hash":"30d4f2d0d85f4a5d6e9d2227331cd24e4e4fe065","modified":1490337086000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1655277795012},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1655277795012},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1655277795012},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1655277795012},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1655277795012},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1655277795012},{"_id":"themes/next/_config.yml","hash":"fb32bfb07060d2ed2c41d613d9b7cacfe11a3b07","modified":1655277795012},{"_id":"themes/next/package.json","hash":"a042faed34835a52505643aa2d841cd2dcf5dff6","modified":1655277795019},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1655277795012},{"_id":"themes/next/gulpfile.coffee","hash":"b00e93c5c8667a4fbed71046dc93ce6784bf6257","modified":1655277795012},{"_id":"source/_posts/C-C-C-导入lua浅析.md","hash":"6051de220235247cfe551d9c8b6df164aa79c078","modified":1655277803418},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1540449089000},{"_id":"source/_posts/Blocks-in-iOS.md","hash":"faf7e4b2ac098d904ae2d8548bf86b2d89a33890","modified":1655277795000},{"_id":"source/_posts/C-C-Dev.md","hash":"ff0a7d8e0d49ee42b458cd6aa2225cee50339a5e","modified":1655277795001},{"_id":"source/_posts/Lua学习笔记.md","hash":"0717809392e5a1905f45576f85755228105066ab","modified":1655277795001},{"_id":"source/_posts/SWIFT编程.md","hash":"328e6891e6fe1518a99837ecd3b650a1bef6ecc9","modified":1655277795002},{"_id":"source/_posts/Unity-学习笔记.md","hash":"7068b4a567118ee746d2bb31e254cf308aeaafab","modified":1655277795002},{"_id":"source/_posts/Python-Dev.md","hash":"14bf2b9563d6638026c38ac498cb3257c7537782","modified":1655277795001},{"_id":"source/_posts/git-使用手册.md","hash":"63c91c221e6f9a14b6b4382181a7145f936fab08","modified":1655277795002},{"_id":"source/_posts/hello-world.md","hash":"a26d9579c68b8753693eca2d6dcda2687ecfcd0b","modified":1655277795002},{"_id":"source/_posts/hexo使用手册.md","hash":"0186fc63c3120ea64771976f3f92a11e27d6b576","modified":1655277795002},{"_id":"source/_posts/iOS-Dev.md","hash":"cd4a660b6de705b31e278468f241170dec56c028","modified":1655277795002},{"_id":"source/_posts/学习资源大全.md","hash":"30fec7cb8bf20b5f9ecb9271fbbb284fde5ef2b0","modified":1655277795002},{"_id":"source/_posts/设计模式.md","hash":"7e52ba2bd4b17533a7e74d60be68c0808d68da15","modified":1655277795003},{"_id":"source/about/index.md","hash":"593ff78ffb1249515acdf2706e054936a6f7d0de","modified":1655277795003},{"_id":"source/categories/index.md","hash":"685fce153e4a05181bff38c54516f7b976ab7e40","modified":1655277795003},{"_id":"source/tags/index.md","hash":"c711d5a178132a5d33835cb92b27dbd248d67583","modified":1655277795003},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1655277795012},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1655277795012},{"_id":"themes/next/languages/default.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1655277795013},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1655277795013},{"_id":"themes/next/languages/en.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1655277795013},{"_id":"themes/next/languages/fr-FR.yml","hash":"e98f1558347752a20019b71f0b1f9c8be1b34f42","modified":1655277795013},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1655277795013},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1655277795013},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1655277795013},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1655277795013},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1655277795013},{"_id":"themes/next/languages/ru.yml","hash":"5022885d8955e1b91d8841048db272bf99c59a76","modified":1655277795013},{"_id":"themes/next/languages/zh-Hans.yml","hash":"40d01dc46d57f71c2ef635c45b295d4355456e90","modified":1655277795013},{"_id":"themes/next/languages/zh-hk.yml","hash":"19c23d21f262e24c06ee6ddfd51d2a6585304f88","modified":1655277795013},{"_id":"themes/next/languages/zh-tw.yml","hash":"68407799271c78ecc07f03d238257dd8c65ad42d","modified":1655277795013},{"_id":"themes/next/layout/_layout.swig","hash":"2c0c3547a5b470024326a33ae2779d5ee0252266","modified":1655277795014},{"_id":"themes/next/layout/.DS_Store","hash":"debfb81f96c918d920c45acae876f3e511e2d177","modified":1490337190000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1655277795018},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1655277795018},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1655277795018},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1655277795018},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1655277795018},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1655277795019},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1655277795018},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1655277795019},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1655277795018},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1655277795044},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1655277795044},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1655277795044},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1655277795027},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1655277795014},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1655277795014},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1655277795014},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1655277795014},{"_id":"themes/next/layout/_partials/comments.swig","hash":"970aa668680896262b1056bb5787fc9ec8754495","modified":1655277795014},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1655277795014},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1655277795014},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b57650032ed47b8bd357ec4dcc02d872fdd0e3e1","modified":1655277795014},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1655277795014},{"_id":"themes/next/layout/_macro/post.swig","hash":"2c2efe44ea013030f3ce5da7bfdeddb74489eb6e","modified":1655277795014},{"_id":"themes/next/layout/_partials/head.swig","hash":"a0eafe24d1dae30c790ae35612154b3ffbbd5cce","modified":1655277795015},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1655277795015},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1655277795015},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1655277795015},{"_id":"themes/next/layout/_partials/search.swig","hash":"7b61e96508df70152b809ea5354236ab7f0d54f4","modified":1655277795015},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1655277795016},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1655277795016},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1655277795016},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1655277795018},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1655277795019},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1655277795019},{"_id":"themes/next/scripts/tags/exturl.js","hash":"79378f3a1cd90518b07808ed09156a3ab55ffa31","modified":1655277795019},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1655277795019},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1655277795019},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1655277795027},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1655277795027},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1655277795027},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1655277795027},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1655277795027},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1655277795027},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1655277795028},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1655277795028},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1655277795028},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1655277795028},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1655277795028},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1655277795028},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1655277795028},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1655277795028},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1655277795028},{"_id":"themes/next/source/uploads/cppr.png","hash":"1df9e94f25c6897ddcbd9f3d34dc76ff6f14a2ca","modified":1655277795043},{"_id":"themes/next/source/uploads/cr.png","hash":"cde165844f6615a5af0fa3200c2f790e81a14f97","modified":1655277795043},{"_id":"themes/next/source/uploads/csr.png","hash":"3ae9379ff235ef747d6615806d8f340529146d5c","modified":1655277795043},{"_id":"themes/next/source/uploads/wechatpay.png","hash":"1637f48cfd5fbb7e4a5afc7bf7aa93e5fb570c0b","modified":1655277795043},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1655277795016},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1655277795016},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1655277795019},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1655277795024},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1655277795024},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1655277795025},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1655277795026},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1655277795027},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1655277795014},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1655277795014},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1655277795015},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1655277795015},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1655277795015},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"741f09b2ba4e440011c15f5d288b109b82c87f1b","modified":1655277795015},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1655277795016},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1655277795015},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1655277795015},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1655277795016},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1655277795016},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1655277795015},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1655277795016},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"e46900412e28f529c26e25e6bada342006435a32","modified":1655277795016},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"a279e1881208aff2f669fe235e9661ab825bc540","modified":1655277795017},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1655277795018},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"ceb39c100c99900294ddee8b1ff81fcaf43873b5","modified":1655277795018},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1655277795018},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1655277795018},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1655277795018},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1655277795024},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1655277795024},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1655277795024},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1655277795027},{"_id":"themes/next/source/css/_variables/base.styl","hash":"e7c76d93605e2b685274400afe51c55cc651486e","modified":1655277795027},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1655277795026},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1655277795028},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"54ca0acff29a414e2c1b7c1790db22f0c775604c","modified":1655277795028},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1655277795028},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1655277795028},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1655277795029},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1655277795029},{"_id":"themes/next/source/js/src/post-details.js","hash":"3b2d64c2e6ae072ba2a9ebf7f09908a1543abd58","modified":1655277795029},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1655277795029},{"_id":"themes/next/source/js/src/utils.js","hash":"9ff232a2d39a513b811814480502e3eaac429c52","modified":1655277795029},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1655277795029},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1655277795032},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1655277795033},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1655277795034},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1655277795034},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1655277795034},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1655277795034},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1655277795034},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1655277795033},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1655277795034},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1655277795034},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1655277795040},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1655277795040},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1655277795040},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1655277795040},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1655277795040},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1655277795041},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1655277795040},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1655277795041},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1655277795042},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1655277795042},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1655277795042},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1655277795041},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1655277795040},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1655277795016},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1655277795016},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1655277795016},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1655277795017},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1655277795017},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1655277795017},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-mta.swig","hash":"a652f202bd5b30c648c228ab8f0e997eb4928e44","modified":1655277795017},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1655277795017},{"_id":"themes/next/layout/_scripts/third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1655277795017},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1655277795017},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1655277795017},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1655277795017},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1655277795017},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1655277795018},{"_id":"themes/next/layout/_scripts/third-party/comments/livere.swig","hash":"7240f2e5ec7115f8abbbc4c9ef73d4bed180fdc7","modified":1655277795017},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1655277795024},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1655277795020},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1655277795020},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1655277795020},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1655277795020},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1655277795021},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1655277795020},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1655277795023},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"7804e31c44717c9a9ddf0f8482b9b9c1a0f74538","modified":1655277795024},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1655277795024},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1655277795024},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1655277795024},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1655277795024},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1655277795025},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1655277795025},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1655277795025},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1655277795025},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1655277795025},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1655277795025},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1655277795025},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1655277795025},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1655277795025},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1655277795026},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1655277795026},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"f15537cee1a9ef4fa1e72a1670ebce4097db8115","modified":1655277795026},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1655277795026},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1655277795026},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1655277795026},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1655277795026},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1655277795026},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1655277795026},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1655277795029},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1655277795032},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1655277795032},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1655277795032},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1655277795032},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1655277795032},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1655277795032},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1655277795033},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1655277795033},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1655277795033},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1655277795034},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1655277795034},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1655277795035},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1655277795035},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1655277795035},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1655277795041},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1655277795041},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1655277795035},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1655277795039},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1655277795040},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1655277795042},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1655277795020},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1655277795020},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1655277795020},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1655277795020},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1655277795020},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1655277795020},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1655277795020},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"755b04edbbfbdd981a783edb09c9cc34cb79cea7","modified":1655277795021},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1655277795021},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1655277795021},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1655277795021},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1655277795021},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1655277795021},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1655277795021},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1655277795021},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1655277795021},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1655277795021},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1655277795021},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1655277795021},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"b9a2e76f019a5941191f1263b54aef7b69c48789","modified":1655277795022},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1655277795022},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1655277795022},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1655277795022},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1655277795022},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1655277795022},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1655277795022},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1655277795022},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1655277795022},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1655277795022},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1655277795022},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1655277795022},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1655277795022},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1655277795022},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1655277795023},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1655277795023},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1655277795023},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1655277795023},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1655277795023},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1655277795023},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1655277795023},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8fe1e55bc290e6aaf07cc644fe27b62107a272a8","modified":1655277795023},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1655277795023},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1655277795023},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1655277795023},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1655277795023},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1655277795024},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1655277795023},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"173490e21bece35a34858e8e534cf86e34561350","modified":1655277795024},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1655277795024},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1655277795025},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1655277795025},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1655277795026},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1655277795032},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1655277795032},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1655277795032},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1655277795033},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1655277795033},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1655277795033},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1655277795035},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1655277795039},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1655277795031},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1655277795036},{"_id":"public/categories/index.html","hash":"d67edcf5f2bc8ac842bcede371db6c0d5eb9e9f9","modified":1655278495600},{"_id":"public/about/index.html","hash":"97ccd14d060b566a32bd6e7a27f20c2b24bf492d","modified":1655278495600},{"_id":"public/tags/index.html","hash":"34256bd7f3f12fb74c6f9bc66d9853410e3ee5bf","modified":1655278495600},{"_id":"public/2022/06/15/hello-world/index.html","hash":"c7263be771480fddf3c7b3d3bcb756388f753b00","modified":1655278495600},{"_id":"public/2018/10/25/C-C-C-导入lua浅析/index.html","hash":"535030917348fce50b625aeaff94b32cf49d1319","modified":1655278495600},{"_id":"public/2017/07/10/Lua学习笔记/index.html","hash":"39651e3e30f97b7be578849c7705d3bef2c344a8","modified":1655278495600},{"_id":"public/2017/06/27/Unity-学习笔记/index.html","hash":"224da6598c8d9ce971ec81a7adfbc84db2bd7d28","modified":1655278495600},{"_id":"public/2017/04/27/git-使用手册/index.html","hash":"3b9a4dc6798c0b36203c16fc78e5b7c7c628bb68","modified":1655278495600},{"_id":"public/2017/04/01/设计模式/index.html","hash":"06898a0434d01da411dce662414f230449d35ce5","modified":1655278495600},{"_id":"public/2017/05/07/SWIFT编程/index.html","hash":"0705cce2761fb2d7c4562b2b4c3fa8f7b21e3848","modified":1655278495600},{"_id":"public/2017/03/21/Python-Dev/index.html","hash":"08f096c67562e13179a59ff83b79fba0b7bf8f21","modified":1655278495600},{"_id":"public/2017/03/19/学习资源大全/index.html","hash":"a1ef95433d2d98c509e41e8e746dcf07bde9e878","modified":1655278495600},{"_id":"public/2017/03/19/C-C-Dev/index.html","hash":"fc72255cdfd778fe36d56a32e06512c4d0d3d984","modified":1655278495600},{"_id":"public/2017/03/19/hexo使用手册/index.html","hash":"390683571a2a46ccd4613572f85155fec03f30b1","modified":1655278495600},{"_id":"public/2017/03/19/Blocks-in-iOS/index.html","hash":"9ecff0875b1d8643289442709322c8371f8904d1","modified":1655278495600},{"_id":"public/2017/03/18/iOS-Dev/index.html","hash":"5591411cd1bbb84bd85d8616b7b3e29ae3fdec39","modified":1655278495600},{"_id":"public/categories/C-C/index.html","hash":"90b07036855115200cd5a408207bd893b55d7dc6","modified":1655278495600},{"_id":"public/categories/Lua/index.html","hash":"b076e4585a8db0eec2d8ac63c711e13f179b5c3b","modified":1655278495600},{"_id":"public/categories/Unity/index.html","hash":"33b39b71f9012047c32443d97ffd1661c3ade8c7","modified":1655278495600},{"_id":"public/categories/git/index.html","hash":"da856c54b65d16c9f143f429fe16508df5f4d12a","modified":1655278495600},{"_id":"public/categories/Python/index.html","hash":"650217d3da39271bfd90cec0995e04b7fff9af47","modified":1655278495600},{"_id":"public/categories/iOS/index.html","hash":"6f2e00b0ec74d3bbad93cb1fdf69fa0ff94e8129","modified":1655278495600},{"_id":"public/categories/学习资源/index.html","hash":"17e5d8ade99f9232c2f301eda52b2aeb68bbb007","modified":1655278495601},{"_id":"public/categories/设计模式/index.html","hash":"3769f46439b99459a0cc0c69dcf2e220cddd7eab","modified":1655278495601},{"_id":"public/categories/Hexo/index.html","hash":"a0a1b7c66ff5cc5b856f5ef560a9d31d218a8bbd","modified":1655278495601},{"_id":"public/archives/index.html","hash":"b60871d169983f0d9cda063bd0337e49700cf725","modified":1655278495601},{"_id":"public/archives/page/2/index.html","hash":"6cb27bf52e6fde163c5471f904c070717addb2fa","modified":1655278495601},{"_id":"public/archives/2017/index.html","hash":"242e4afcd597aa5463c9a22daeb7602f1401a323","modified":1655278495601},{"_id":"public/archives/2017/04/index.html","hash":"80edd8b559ab55a58dd6bce7dc353e95033459ff","modified":1655278495601},{"_id":"public/archives/2017/03/index.html","hash":"64890fdbdb6b00380fa415bf07ca3b7d45265985","modified":1655278495601},{"_id":"public/archives/2017/page/2/index.html","hash":"d329d7c0bf3314e2dc5b7e0c7f3a5cdd4c2fa8aa","modified":1655278495601},{"_id":"public/archives/2017/05/index.html","hash":"6b5e631feff61957cbd265221eceda1646fd3c4b","modified":1655278495601},{"_id":"public/archives/2018/index.html","hash":"dd91afa9ec4e30c76dff7e4ceae2384c84bd4353","modified":1655278495601},{"_id":"public/archives/2017/07/index.html","hash":"f56e48ba646ee88896b80a69e2e368ae7aa54342","modified":1655278495601},{"_id":"public/archives/2018/10/index.html","hash":"f9575e99154960f7303983d5105947a0c5931582","modified":1655278495601},{"_id":"public/archives/2017/06/index.html","hash":"f8c49d9344c98a14268a5fa19b3b40f052211551","modified":1655278495601},{"_id":"public/archives/2022/index.html","hash":"5e000a34dd365c6614d02c22308ca5dffdc59ee2","modified":1655278495601},{"_id":"public/index.html","hash":"40c7d1ec0135dd269290cd8a3fa567bc602f936e","modified":1655278495601},{"_id":"public/archives/2022/06/index.html","hash":"dd0b9c6594c87ff9b791b05b52bdf63216c6177c","modified":1655278495601},{"_id":"public/tags/iOS/index.html","hash":"ebf2f72f4d0fccf6aae7ce3cc724fb7d7c2a11ac","modified":1655278495601},{"_id":"public/page/2/index.html","hash":"06c0721ad46c7d5258b325658f97762a8b5a937e","modified":1655278495601},{"_id":"public/tags/Dev/index.html","hash":"b990922d12a095227ea7fb05b60d87c1d0dc938f","modified":1655278495601},{"_id":"public/tags/C-C/index.html","hash":"841fcadd2f7e6923af571f26b07cd9ee5d80392f","modified":1655278495601},{"_id":"public/tags/Lua/index.html","hash":"c37586cacadfb4338004b49ade8630220434e845","modified":1655278495601},{"_id":"public/tags/Unity/index.html","hash":"55b8d4d0a9557ae67fa9899ef8fa85105d3aa58c","modified":1655278495601},{"_id":"public/tags/swift/index.html","hash":"6b218a12150457fd26e2d89e7885ed6dee0844ce","modified":1655278495601},{"_id":"public/tags/git/index.html","hash":"9442d72ff17fad2ce3b1184af2cda35ad076b4fb","modified":1655278495601},{"_id":"public/tags/使用手册/index.html","hash":"f10132ba9d7a613ed877d2ca5f240465a9e466a8","modified":1655278495601},{"_id":"public/tags/Python/index.html","hash":"e8c2d446a3e34f8eef45858b625c793cacf46488","modified":1655278495601},{"_id":"public/tags/网页/index.html","hash":"6a9a6bb4483ac155ed2df4e4311f6723a14d05ef","modified":1655278495601},{"_id":"public/tags/学习资源/index.html","hash":"6fdc473e08d3275217028adf7bb10c53725d7f07","modified":1655278495601},{"_id":"public/tags/设计模式/index.html","hash":"4e03fbcc3eabd3a50fec24d5b7efcab313b1d8dc","modified":1655278495601},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1655278495607},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1655278495607},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1655278495607},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1655278495607},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1655278495607},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1655278495607},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1655278495607},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1655278495607},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1655278495607},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1655278495607},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1655278495607},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1655278495607},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1655278495607},{"_id":"public/uploads/cppr.png","hash":"1df9e94f25c6897ddcbd9f3d34dc76ff6f14a2ca","modified":1655278495607},{"_id":"public/uploads/cr.png","hash":"cde165844f6615a5af0fa3200c2f790e81a14f97","modified":1655278495607},{"_id":"public/uploads/csr.png","hash":"3ae9379ff235ef747d6615806d8f340529146d5c","modified":1655278495607},{"_id":"public/uploads/wechatpay.png","hash":"1637f48cfd5fbb7e4a5afc7bf7aa93e5fb570c0b","modified":1655278495607},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1655278495607},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1655278495607},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1655278495607},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1655278495607},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1655278495607},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1655278495607},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1655278495607},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1655278495607},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1655278495607},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1655278495607},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1655278496070},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1655278496076},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1655278496080},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1655278496080},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1655278496086},{"_id":"public/js/src/algolia-search.js","hash":"54ca0acff29a414e2c1b7c1790db22f0c775604c","modified":1655278496086},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1655278496086},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1655278496086},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1655278496086},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1655278496086},{"_id":"public/js/src/post-details.js","hash":"3b2d64c2e6ae072ba2a9ebf7f09908a1543abd58","modified":1655278496086},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1655278496086},{"_id":"public/js/src/utils.js","hash":"9ff232a2d39a513b811814480502e3eaac429c52","modified":1655278496086},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1655278496086},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1655278496086},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1655278496086},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1655278496086},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1655278496086},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1655278496086},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1655278496086},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1655278496086},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1655278496086},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1655278496086},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1655278496086},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1655278496086},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1655278496086},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1655278496086},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1655278496086},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1655278496086},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1655278496086},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1655278496087},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1655278496087},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1655278496087},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1655278496087},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1655278496087},{"_id":"public/css/main.css","hash":"28e5d679393fef551deac5ed4ed79be8c9fa224f","modified":1655278496087},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1655278496087},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1655278496087},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1655278496087},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1655278496087},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1655278496087},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1655278496087},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1655278496087},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1655278496087},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1655278496087},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1655278496087},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1655278496087},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1655278496087},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1655278496093}],"Category":[{"name":"iOS","_id":"cl4fa2s9r0005daco9c6h6rsk"},{"name":"C/C++","_id":"cl4fa2s9y000adacopb3wgk6r"},{"name":"Lua","_id":"cl4fa2sa0000fdaco16f8561s"},{"name":"Unity","_id":"cl4fa2sa2000ndaco43m6gdrv"},{"name":"git","_id":"cl4fa2sa4000vdaco91frf97a"},{"name":"Python","_id":"cl4fa2sa50012dacomom0huz0"},{"name":"学习资源","_id":"cl4fa2sa50015dacollutvj30"},{"name":"设计模式","_id":"cl4fa2sa6001adacoud4j19om"},{"name":"Hexo","_id":"cl4fa2sa6001ddacoxeveh4l9"}],"Data":[],"Page":[{"title":"categories","date":"2017-03-19T09:12:45.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-03-19 17:12:45\ntype: \"categories\"\ncomments: false\n---\n","updated":"2022-06-15T07:23:15.003Z","path":"categories/index.html","layout":"page","_id":"cl4fa2s9n0001dacotirj9n3p","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2017-03-19T09:16:48.000Z","type":"about","comments":0,"_content":"日前由于各大笔记都开始收费，本人甚觉得还不如自己整一Blog，因些本Blog多为笔记耳。\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-03-19 17:16:48\ntype: \"about\"\ncomments: false\n---\n日前由于各大笔记都开始收费，本人甚觉得还不如自己整一Blog，因些本Blog多为笔记耳。\n","updated":"2022-06-15T07:23:15.003Z","path":"about/index.html","layout":"page","_id":"cl4fa2s9p0003dacoy7v6dcjm","content":"<p>日前由于各大笔记都开始收费，本人甚觉得还不如自己整一Blog，因些本Blog多为笔记耳。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>日前由于各大笔记都开始收费，本人甚觉得还不如自己整一Blog，因些本Blog多为笔记耳。</p>\n"},{"title":"tags","date":"2017-03-19T09:14:32.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-03-19 17:14:32\ntype: \"tags\"\ncomments: false\n---\n","updated":"2022-06-15T07:23:15.003Z","path":"tags/index.html","layout":"page","_id":"cl4fa2sd1001zdaco647nugwa","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"C/C++/C#导入lua浅析","date":"2018-10-25T06:32:58.000Z","_content":"\n\n# C/C++/C#导入Lua浅入浅出\n\n## 一、C函数导入Lua\n因为Lua虚拟机就是C编写的，C函数导入Lua通过Lua C API就可以完成，相对还是比较简单。需要掌握的知识点就是Lua栈及Lua C API：  \n\n+ Lua栈可以类比于计算机的内存  \n+ Lua C API类似于汇编语言，Lua C API可以操纵Lua栈，通过操纵Lua栈可以达到与Lua交互的目的。[Lua C API 参考](https://cloudwu.github.io/lua53doc/manual.html)\n\n### 1.1 实例    \n\n`lua_tonumber `表示从Lua栈指定`index`处取参数，`lua_pushnumber`表示把number压入栈顶。`Add`函数本质就是从Lua栈上取两个参数然后再将两个参数的计算结果压入Lua栈供Lua获取。   \n\n```  \nint MyAdd(lua_State* l) \n{\n\tint n = lua_tonumber(l,-1);\n\tint n2 = lua_tonumber(l,-2);\n\tint ret = n + n2;\n\tlua_pushnumber(l,ret);\n\treturn 1;\n}\n```\n\n上面定义了一个C函数`MyAdd`，接下来要做的事情就是将C函数导入Lua，`lua_register`（还有其它相关API）就可以将C函数注册到Lua中，`luaL_dostring `执行段Lua代码。   \n\n```\n\nint main(int argc, _TCHAR* argv[])\n{\n\tlua_State *l = luaL_newstate();\n\tluaL_openlibs(l);\n\tlua_register(l,\"MyAdd\",MyAdd);\n\t//执行lua代码\n\tluaL_dostring(l,\"print(\\\"MyAdd result is:\\\");print(MyAdd(100,200))\");   \n}\n\t\n```\n\n![img](img/cr.png)    \n\n\n## 二、C++导入Lua  \n上文已经简单了解了C函数导入Lua的原理，C++类的方法的导入可以通过C函数Wrapper C++的方法，然后再将C函数导入Lua。但是需要注意的是怎么样在Lua访问C++的对象，一般可以通过`userdata`存储C++对象的指针，然后访问时从`userdata`中取。    \n一般将C++类导入Lua里分为三步：  \n\n+ 首先，创建一个`userdata` 存放 C++ 对象指针    \n+ 然后给 `userdata` 添加元表\n+ 用 `__index` 元方法映射 C++ 中的方法。    \n\n### 2.1 实例\n\n#### 1、 准备将要导入Lua的自定义C++ `Account`类\n\n```\nclass Account {\npublic: \n\tAccount(double balance){ m_balance = balance;}\n\tvoid deposit(double amount){m_balance += amount;}\n\tvoid withdraw(double amount){m_balance -= amount;}\n\tdouble balance(){return m_balance;}\nprivate:\n\tdouble m_balance;\n};\n```\n\n#### 2、 “构造”函数\n通过`lua_newuserdata `创建一个`userdata`，并将`Account`对象的指针存储于`userdata`。然后，通过`lua_setmetatable `给`userdata`设置元表（元表会在注册时创建，见下文）。    \n至于为什么需要给`userdata`关联元表，因为`userdata`只是一个指针而已没有任何方法，所以需要设置一个元表（元表也是一个table）。 lua的查找路径：\n\n1. 在当前的表中查找，如果找到，返回该元素，找不到则继续2。\n2. 判断该表是否有元表，如果没有元表，返回nil，有元表则继续3 。\n3. 判断元表有没有 `__index`，如果`__index`方法为nil，则返回nil；如果`__index`的值是一个table，则重复1、2、3；如果`__index`的值是一个function，则返回该函数的返回值。   \n\n\n```\nint create_account(lua_State *L)\n{\n\t\n\tdouble balance = luaL_checknumber(L,1);\n\tAccount **a = (Account**)lua_newuserdata(L,sizeof(Account));\n\t*a = new Account(balance);\n\tprintf(\"construct! balance is: %lf\\n\",balance);\n\tluaL_getmetatable(L,\"Account\");\n\tlua_setmetatable(L,-2);//将userdata与Account metatable关联起来\n\treturn 1;\n}\n```\n\n#### 3、 C++ 类`Account`的方法映射到C函数\n\n每一个函数原理都基本一致：   \n\n+ 首先，从Lua栈顶获取`userdata`   \n+ 取`userdata`保存的C++对象的指针   \n+ 最后，对过C++对象指针访问对应方法   \n\n```\nAccount* checkaccount(lua_State *L, int narg)\n{\n\tluaL_checktype(L,narg, LUA_TUSERDATA);\n\tvoid *ud = luaL_checkudata(L,narg,\"Account\");\n\tluaL_argcheck(L,ud!= NULL,1,\"user data error\");\n\treturn *(Account**)ud;\n}\n\nint deposit(lua_State *L)\n{\n\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);\n\tdouble amount = luaL_checknumber(L,-1);\n\t(a)->deposit(amount);\n\treturn 0;\n}\nint withdraw(lua_State *L)\n{\n\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);\n\tdouble amount = luaL_checknumber(L,-1);\n\t(a)->withdraw(amount);\n\treturn 0;\n}\nint balance(lua_State *L)\n{\n\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);\n\tdouble balance = (a)->balance();\n\tprintf(\"balance is: %lf\\n\",balance);\n\tlua_pushnumber(L,balance);\n\treturn 0;\n}\n```\n\n#### 4、注册\n\n+ 创建一个`metatable` `Account`，`Account`将会关联到存储C++对象的`userdata`\n+ 将第三步的C函数注册到`Account`表\n+ 注册一个`Account`全局函数，可以理解为在Lua中的一个构造函数\n\n```    \n\nstatic const luaL_Reg methods[]= {\n\t//{\"Account\",create_account},\n\t{\"deposit\",deposit},\n\t{\"withdraw\",withdraw},\n\t{\"balance\",balance},\n\t{NULL,NULL}\n};\n\nint luaopen_Account(lua_State *L)\n{\n\tluaL_newmetatable(L,\"Account\");\n\tlua_pushvalue(L,-1);\n\tlua_setfield(L,-2,\"__index\");//Account.__index = Account\n\tluaL_setfuncs(L,methods,0);//register the methods to the table that is on the top\n\treturn 1;\n}\n\nstatic const luaL_Reg libs [] = {\"Account\",luaopen_Account},{NULL,NULL};\nvoid Register(lua_State* L)\n{\n\tconst luaL_Reg *lib = libs;\n\tfor (;lib->func; lib++) \n\t{\n\t\tluaL_requiref(L, lib->name, lib->func, 1);\n\t\tlua_pop(L, 1);  /* remove lib */\n\t}\n\tlua_register(L,\"Account\",create_account);\n}   \n```\n\n#### 5、test.lua  \n\n\n```\nprint(\"start\");\nlocal a  = Account(100);\nprint(a);\nprint(a:balance());\na:deposit(399);\nprint(\"start\");\nprint(a:balance());\nprint(\"end\");\n```\n\n![img](img/cppr.png)    \n\n## 三、C#类导入Lua  \n\nC# 单个函数导入Lua比较简单与 C 导入Lua基本一致，此处就不赘述。C#类的导入则与C++差不多，但是怎么将C#对象存储于`userdata`是一个问题。有两种方案处理这个问题（仅本人所知）：\n\n+ C# 对象可以通过`Marshal.StructureToPtr`转为`IntPtr`的指针，但是要求类添加`[StructLayout(LayoutKind.Sequential)]`标记，如此如果要导出一些非自定义类可能比较麻烦。   \n+ 另一个方法，将一个`int`存储于`userdata`，并以`int`做key C#对象为value缓存于C#字典中，对于`userdata`的其它操作与C++一致。当lua调用该对象时，通过`Marshal.ReadInt32`函数，将返回的`userdata`转为一个`int`的key从C#对象字典中取出实际对象即可。     \n\n接下来就方法二进行一下了解。\n\n### 3.1 实例   \n说明：\n\n+ 将Lua虚拟机制作为Dll，并添加到Unity工程，本文直接使用的Slua来测试的\n+ 本文环境为Unity\n\n#### 1、将要导入Lua的C#类`LuaTestDemo`\n\n```\n    class LuaTestDemo:System.Object\n    {\n        public double Add(double a, double b)\n        {\n            Debug.Log(\"lua call the Add function!!\");\n            double ret = a + b;\n            Debug.Log(\"==========: \"+ret);\n            return ret;\n        }\n    }\n```\n\n#### 2、“构造”函数\n与C++处理流程基本一致，**需要注意的是`userdata`的值是`100`，并将`LuaTestDemo`的实例做为`100`的value存入`Dictionary`**。\n\n```\n      [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]\n       public static int CreateLuaTestDemo(IntPtr l)\n       {\n            Debug.Log(\"lua call the CreateLuaTestDemo function!!\");\n            LuaDLL.luaS_newuserdata(l,100);//userdata is 100\n            LuaTestDemo o = new LuaTestDemo();\n            cache.Add(100,o);//map object to userdata\n            LuaDLL.puaL_getmetatable(l, \"LuaTestDemo\");//connect the userdata to LuaTestDemo metatable\n            LuaDLL.pua_setmetatable(l, -2);\n            return 1;\n        }\n```\n\n#### 3、Wrapper.  \n与C++一致，**需要注意的`userdata`获取的是一个`int`，并以`int`为key获取C#对象，然后访问对应方法;**     **通过[MonoPInvokeCallbackAttribute]标签让C语言可以直接调用C#函数**    \n\n```\n\t\tstatic LuaTestDemo checkuserdata(IntPtr l)\n        {\n            LuaDLL.puaL_checktype(l,1,LuaTypes.LUA_TUSERDATA);\n            IntPtr userdata = LuaDLL.puaL_checkudata(l, 1, \"LuaTestDemo\");\n            int index = Marshal.ReadInt32(userdata);\n            Debug.Log(\"userdata is: \" + index);\n            LuaTestDemo o = cache[index];\n            return o;\n        }\n        \n        [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]\n        static public int AddWrapper(IntPtr l)\n        {\n            Debug.Log(\"lua call the AddWrapper function!!\");\n            LuaTestDemo o = checkuserdata(l);\n            double a = LuaDLL.pua_tonumber(l, -1);\n            double b = LuaDLL.pua_tonumber(l, -2);\n            double ret = o.Add(a,b);\n            LuaDLL.pua_pushnumber(l, ret);\n            return 1;\n        }\n        \n```\n\n#### 4、注册    \n\n```     \n        public static void Reg(IntPtr l)\n        {\n            LuaDLL.puaL_newmetatable(l, \"LuaTestDemo\");\n            LuaDLL.pua_pushvalue(l,-1);\n            LuaDLL.pua_setfield(l,-2,\"__index\");//LuaTestDemo.__index = LuaTestDemo\n            LuaDLL.pua_pushcclosure(l, AddWrapper, 0);\n            LuaDLL.pua_setfield(l,-2,\"Add\");\n            LuaDLL.pua_pop(l,1);\n            \n            LuaDLL.pua_pushcclosure(l, CreateLuaTestDemo , 0);\n            LuaDLL.pua_setglobal(l, \"LuaTestDemo\");\n        }\n    }\n```\n\n#### 5、测试    \n\n```\nIntPtr l = LuaDLL.puaL_newstate();\n\t\tLuaTestDemoWrapper.Reg(l);\n\t\tstring lua = \"\" +\n\t\t             \"local d = LuaTestDemo();\" +\n\t\t             \"local ret = d:Add(100,500);\" +\n\t\t             \"local ret2 = d:Add(1000,5000);\" +\n\t\t             \"print(\\\"ret is:\\\"..ret..\\\"   \\\"..ret2);\" +\n\t\t             \"\";\n\t\tLuaDLL.pua_dostring(l,lua);\n```\n\n![img](img/csr.png)    \n\n## 四、总结\n+ 上文仅是一个入门的学习，没有涉及到内存的管理，内存的管理应该是比较核心的。\n+ C/C++/C#导入Lua的本质可以简单理解为，宿主程序通过Lua栈从Lua获取参数，然后宿主程序将计算结果压入Lua栈供Lua读取","source":"_posts/C-C-C-导入lua浅析.md","raw":"---\ntitle: 'C/C++/C#导入lua浅析'\ndate: 2018-10-25 14:32:58\ntags:\n---\n\n\n# C/C++/C#导入Lua浅入浅出\n\n## 一、C函数导入Lua\n因为Lua虚拟机就是C编写的，C函数导入Lua通过Lua C API就可以完成，相对还是比较简单。需要掌握的知识点就是Lua栈及Lua C API：  \n\n+ Lua栈可以类比于计算机的内存  \n+ Lua C API类似于汇编语言，Lua C API可以操纵Lua栈，通过操纵Lua栈可以达到与Lua交互的目的。[Lua C API 参考](https://cloudwu.github.io/lua53doc/manual.html)\n\n### 1.1 实例    \n\n`lua_tonumber `表示从Lua栈指定`index`处取参数，`lua_pushnumber`表示把number压入栈顶。`Add`函数本质就是从Lua栈上取两个参数然后再将两个参数的计算结果压入Lua栈供Lua获取。   \n\n```  \nint MyAdd(lua_State* l) \n{\n\tint n = lua_tonumber(l,-1);\n\tint n2 = lua_tonumber(l,-2);\n\tint ret = n + n2;\n\tlua_pushnumber(l,ret);\n\treturn 1;\n}\n```\n\n上面定义了一个C函数`MyAdd`，接下来要做的事情就是将C函数导入Lua，`lua_register`（还有其它相关API）就可以将C函数注册到Lua中，`luaL_dostring `执行段Lua代码。   \n\n```\n\nint main(int argc, _TCHAR* argv[])\n{\n\tlua_State *l = luaL_newstate();\n\tluaL_openlibs(l);\n\tlua_register(l,\"MyAdd\",MyAdd);\n\t//执行lua代码\n\tluaL_dostring(l,\"print(\\\"MyAdd result is:\\\");print(MyAdd(100,200))\");   \n}\n\t\n```\n\n![img](img/cr.png)    \n\n\n## 二、C++导入Lua  \n上文已经简单了解了C函数导入Lua的原理，C++类的方法的导入可以通过C函数Wrapper C++的方法，然后再将C函数导入Lua。但是需要注意的是怎么样在Lua访问C++的对象，一般可以通过`userdata`存储C++对象的指针，然后访问时从`userdata`中取。    \n一般将C++类导入Lua里分为三步：  \n\n+ 首先，创建一个`userdata` 存放 C++ 对象指针    \n+ 然后给 `userdata` 添加元表\n+ 用 `__index` 元方法映射 C++ 中的方法。    \n\n### 2.1 实例\n\n#### 1、 准备将要导入Lua的自定义C++ `Account`类\n\n```\nclass Account {\npublic: \n\tAccount(double balance){ m_balance = balance;}\n\tvoid deposit(double amount){m_balance += amount;}\n\tvoid withdraw(double amount){m_balance -= amount;}\n\tdouble balance(){return m_balance;}\nprivate:\n\tdouble m_balance;\n};\n```\n\n#### 2、 “构造”函数\n通过`lua_newuserdata `创建一个`userdata`，并将`Account`对象的指针存储于`userdata`。然后，通过`lua_setmetatable `给`userdata`设置元表（元表会在注册时创建，见下文）。    \n至于为什么需要给`userdata`关联元表，因为`userdata`只是一个指针而已没有任何方法，所以需要设置一个元表（元表也是一个table）。 lua的查找路径：\n\n1. 在当前的表中查找，如果找到，返回该元素，找不到则继续2。\n2. 判断该表是否有元表，如果没有元表，返回nil，有元表则继续3 。\n3. 判断元表有没有 `__index`，如果`__index`方法为nil，则返回nil；如果`__index`的值是一个table，则重复1、2、3；如果`__index`的值是一个function，则返回该函数的返回值。   \n\n\n```\nint create_account(lua_State *L)\n{\n\t\n\tdouble balance = luaL_checknumber(L,1);\n\tAccount **a = (Account**)lua_newuserdata(L,sizeof(Account));\n\t*a = new Account(balance);\n\tprintf(\"construct! balance is: %lf\\n\",balance);\n\tluaL_getmetatable(L,\"Account\");\n\tlua_setmetatable(L,-2);//将userdata与Account metatable关联起来\n\treturn 1;\n}\n```\n\n#### 3、 C++ 类`Account`的方法映射到C函数\n\n每一个函数原理都基本一致：   \n\n+ 首先，从Lua栈顶获取`userdata`   \n+ 取`userdata`保存的C++对象的指针   \n+ 最后，对过C++对象指针访问对应方法   \n\n```\nAccount* checkaccount(lua_State *L, int narg)\n{\n\tluaL_checktype(L,narg, LUA_TUSERDATA);\n\tvoid *ud = luaL_checkudata(L,narg,\"Account\");\n\tluaL_argcheck(L,ud!= NULL,1,\"user data error\");\n\treturn *(Account**)ud;\n}\n\nint deposit(lua_State *L)\n{\n\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);\n\tdouble amount = luaL_checknumber(L,-1);\n\t(a)->deposit(amount);\n\treturn 0;\n}\nint withdraw(lua_State *L)\n{\n\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);\n\tdouble amount = luaL_checknumber(L,-1);\n\t(a)->withdraw(amount);\n\treturn 0;\n}\nint balance(lua_State *L)\n{\n\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);\n\tdouble balance = (a)->balance();\n\tprintf(\"balance is: %lf\\n\",balance);\n\tlua_pushnumber(L,balance);\n\treturn 0;\n}\n```\n\n#### 4、注册\n\n+ 创建一个`metatable` `Account`，`Account`将会关联到存储C++对象的`userdata`\n+ 将第三步的C函数注册到`Account`表\n+ 注册一个`Account`全局函数，可以理解为在Lua中的一个构造函数\n\n```    \n\nstatic const luaL_Reg methods[]= {\n\t//{\"Account\",create_account},\n\t{\"deposit\",deposit},\n\t{\"withdraw\",withdraw},\n\t{\"balance\",balance},\n\t{NULL,NULL}\n};\n\nint luaopen_Account(lua_State *L)\n{\n\tluaL_newmetatable(L,\"Account\");\n\tlua_pushvalue(L,-1);\n\tlua_setfield(L,-2,\"__index\");//Account.__index = Account\n\tluaL_setfuncs(L,methods,0);//register the methods to the table that is on the top\n\treturn 1;\n}\n\nstatic const luaL_Reg libs [] = {\"Account\",luaopen_Account},{NULL,NULL};\nvoid Register(lua_State* L)\n{\n\tconst luaL_Reg *lib = libs;\n\tfor (;lib->func; lib++) \n\t{\n\t\tluaL_requiref(L, lib->name, lib->func, 1);\n\t\tlua_pop(L, 1);  /* remove lib */\n\t}\n\tlua_register(L,\"Account\",create_account);\n}   \n```\n\n#### 5、test.lua  \n\n\n```\nprint(\"start\");\nlocal a  = Account(100);\nprint(a);\nprint(a:balance());\na:deposit(399);\nprint(\"start\");\nprint(a:balance());\nprint(\"end\");\n```\n\n![img](img/cppr.png)    \n\n## 三、C#类导入Lua  \n\nC# 单个函数导入Lua比较简单与 C 导入Lua基本一致，此处就不赘述。C#类的导入则与C++差不多，但是怎么将C#对象存储于`userdata`是一个问题。有两种方案处理这个问题（仅本人所知）：\n\n+ C# 对象可以通过`Marshal.StructureToPtr`转为`IntPtr`的指针，但是要求类添加`[StructLayout(LayoutKind.Sequential)]`标记，如此如果要导出一些非自定义类可能比较麻烦。   \n+ 另一个方法，将一个`int`存储于`userdata`，并以`int`做key C#对象为value缓存于C#字典中，对于`userdata`的其它操作与C++一致。当lua调用该对象时，通过`Marshal.ReadInt32`函数，将返回的`userdata`转为一个`int`的key从C#对象字典中取出实际对象即可。     \n\n接下来就方法二进行一下了解。\n\n### 3.1 实例   \n说明：\n\n+ 将Lua虚拟机制作为Dll，并添加到Unity工程，本文直接使用的Slua来测试的\n+ 本文环境为Unity\n\n#### 1、将要导入Lua的C#类`LuaTestDemo`\n\n```\n    class LuaTestDemo:System.Object\n    {\n        public double Add(double a, double b)\n        {\n            Debug.Log(\"lua call the Add function!!\");\n            double ret = a + b;\n            Debug.Log(\"==========: \"+ret);\n            return ret;\n        }\n    }\n```\n\n#### 2、“构造”函数\n与C++处理流程基本一致，**需要注意的是`userdata`的值是`100`，并将`LuaTestDemo`的实例做为`100`的value存入`Dictionary`**。\n\n```\n      [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]\n       public static int CreateLuaTestDemo(IntPtr l)\n       {\n            Debug.Log(\"lua call the CreateLuaTestDemo function!!\");\n            LuaDLL.luaS_newuserdata(l,100);//userdata is 100\n            LuaTestDemo o = new LuaTestDemo();\n            cache.Add(100,o);//map object to userdata\n            LuaDLL.puaL_getmetatable(l, \"LuaTestDemo\");//connect the userdata to LuaTestDemo metatable\n            LuaDLL.pua_setmetatable(l, -2);\n            return 1;\n        }\n```\n\n#### 3、Wrapper.  \n与C++一致，**需要注意的`userdata`获取的是一个`int`，并以`int`为key获取C#对象，然后访问对应方法;**     **通过[MonoPInvokeCallbackAttribute]标签让C语言可以直接调用C#函数**    \n\n```\n\t\tstatic LuaTestDemo checkuserdata(IntPtr l)\n        {\n            LuaDLL.puaL_checktype(l,1,LuaTypes.LUA_TUSERDATA);\n            IntPtr userdata = LuaDLL.puaL_checkudata(l, 1, \"LuaTestDemo\");\n            int index = Marshal.ReadInt32(userdata);\n            Debug.Log(\"userdata is: \" + index);\n            LuaTestDemo o = cache[index];\n            return o;\n        }\n        \n        [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]\n        static public int AddWrapper(IntPtr l)\n        {\n            Debug.Log(\"lua call the AddWrapper function!!\");\n            LuaTestDemo o = checkuserdata(l);\n            double a = LuaDLL.pua_tonumber(l, -1);\n            double b = LuaDLL.pua_tonumber(l, -2);\n            double ret = o.Add(a,b);\n            LuaDLL.pua_pushnumber(l, ret);\n            return 1;\n        }\n        \n```\n\n#### 4、注册    \n\n```     \n        public static void Reg(IntPtr l)\n        {\n            LuaDLL.puaL_newmetatable(l, \"LuaTestDemo\");\n            LuaDLL.pua_pushvalue(l,-1);\n            LuaDLL.pua_setfield(l,-2,\"__index\");//LuaTestDemo.__index = LuaTestDemo\n            LuaDLL.pua_pushcclosure(l, AddWrapper, 0);\n            LuaDLL.pua_setfield(l,-2,\"Add\");\n            LuaDLL.pua_pop(l,1);\n            \n            LuaDLL.pua_pushcclosure(l, CreateLuaTestDemo , 0);\n            LuaDLL.pua_setglobal(l, \"LuaTestDemo\");\n        }\n    }\n```\n\n#### 5、测试    \n\n```\nIntPtr l = LuaDLL.puaL_newstate();\n\t\tLuaTestDemoWrapper.Reg(l);\n\t\tstring lua = \"\" +\n\t\t             \"local d = LuaTestDemo();\" +\n\t\t             \"local ret = d:Add(100,500);\" +\n\t\t             \"local ret2 = d:Add(1000,5000);\" +\n\t\t             \"print(\\\"ret is:\\\"..ret..\\\"   \\\"..ret2);\" +\n\t\t             \"\";\n\t\tLuaDLL.pua_dostring(l,lua);\n```\n\n![img](img/csr.png)    \n\n## 四、总结\n+ 上文仅是一个入门的学习，没有涉及到内存的管理，内存的管理应该是比较核心的。\n+ C/C++/C#导入Lua的本质可以简单理解为，宿主程序通过Lua栈从Lua获取参数，然后宿主程序将计算结果压入Lua栈供Lua读取","slug":"C-C-C-导入lua浅析","published":1,"updated":"2022-06-15T07:23:23.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4fa2s9j0000daco9lhdx20r","content":"<h1 id=\"C-C-C-导入Lua浅入浅出\"><a href=\"#C-C-C-导入Lua浅入浅出\" class=\"headerlink\" title=\"C/C++/C#导入Lua浅入浅出\"></a>C/C++/C#导入Lua浅入浅出</h1><h2 id=\"一、C函数导入Lua\"><a href=\"#一、C函数导入Lua\" class=\"headerlink\" title=\"一、C函数导入Lua\"></a>一、C函数导入Lua</h2><p>因为Lua虚拟机就是C编写的，C函数导入Lua通过Lua C API就可以完成，相对还是比较简单。需要掌握的知识点就是Lua栈及Lua C API：  </p>\n<ul>\n<li>Lua栈可以类比于计算机的内存  </li>\n<li>Lua C API类似于汇编语言，Lua C API可以操纵Lua栈，通过操纵Lua栈可以达到与Lua交互的目的。<a href=\"https://cloudwu.github.io/lua53doc/manual.html\" target=\"_blank\" rel=\"noopener\">Lua C API 参考</a></li>\n</ul>\n<h3 id=\"1-1-实例\"><a href=\"#1-1-实例\" class=\"headerlink\" title=\"1.1 实例\"></a>1.1 实例</h3><p><code>lua_tonumber</code>表示从Lua栈指定<code>index</code>处取参数，<code>lua_pushnumber</code>表示把number压入栈顶。<code>Add</code>函数本质就是从Lua栈上取两个参数然后再将两个参数的计算结果压入Lua栈供Lua获取。   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int MyAdd(lua_State* l) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n = lua_tonumber(l,-1);</span><br><span class=\"line\">\tint n2 = lua_tonumber(l,-2);</span><br><span class=\"line\">\tint ret = n + n2;</span><br><span class=\"line\">\tlua_pushnumber(l,ret);</span><br><span class=\"line\">\treturn 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面定义了一个C函数<code>MyAdd</code>，接下来要做的事情就是将C函数导入Lua，<code>lua_register</code>（还有其它相关API）就可以将C函数注册到Lua中，<code>luaL_dostring</code>执行段Lua代码。   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">int main(int argc, _TCHAR* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tlua_State *l = luaL_newstate();</span><br><span class=\"line\">\tluaL_openlibs(l);</span><br><span class=\"line\">\tlua_register(l,&quot;MyAdd&quot;,MyAdd);</span><br><span class=\"line\">\t//执行lua代码</span><br><span class=\"line\">\tluaL_dostring(l,&quot;print(\\&quot;MyAdd result is:\\&quot;);print(MyAdd(100,200))&quot;);   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"img/cr.png\" alt=\"img\">    </p>\n<h2 id=\"二、C-导入Lua\"><a href=\"#二、C-导入Lua\" class=\"headerlink\" title=\"二、C++导入Lua\"></a>二、C++导入Lua</h2><p>上文已经简单了解了C函数导入Lua的原理，C++类的方法的导入可以通过C函数Wrapper C++的方法，然后再将C函数导入Lua。但是需要注意的是怎么样在Lua访问C++的对象，一般可以通过<code>userdata</code>存储C++对象的指针，然后访问时从<code>userdata</code>中取。<br>一般将C++类导入Lua里分为三步：  </p>\n<ul>\n<li>首先，创建一个<code>userdata</code> 存放 C++ 对象指针    </li>\n<li>然后给 <code>userdata</code> 添加元表</li>\n<li>用 <code>__index</code> 元方法映射 C++ 中的方法。    </li>\n</ul>\n<h3 id=\"2-1-实例\"><a href=\"#2-1-实例\" class=\"headerlink\" title=\"2.1 实例\"></a>2.1 实例</h3><h4 id=\"1、-准备将要导入Lua的自定义C-Account类\"><a href=\"#1、-准备将要导入Lua的自定义C-Account类\" class=\"headerlink\" title=\"1、 准备将要导入Lua的自定义C++ Account类\"></a>1、 准备将要导入Lua的自定义C++ <code>Account</code>类</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Account &#123;</span><br><span class=\"line\">public: </span><br><span class=\"line\">\tAccount(double balance)&#123; m_balance = balance;&#125;</span><br><span class=\"line\">\tvoid deposit(double amount)&#123;m_balance += amount;&#125;</span><br><span class=\"line\">\tvoid withdraw(double amount)&#123;m_balance -= amount;&#125;</span><br><span class=\"line\">\tdouble balance()&#123;return m_balance;&#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tdouble m_balance;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、-“构造”函数\"><a href=\"#2、-“构造”函数\" class=\"headerlink\" title=\"2、 “构造”函数\"></a>2、 “构造”函数</h4><p>通过<code>lua_newuserdata</code>创建一个<code>userdata</code>，并将<code>Account</code>对象的指针存储于<code>userdata</code>。然后，通过<code>lua_setmetatable</code>给<code>userdata</code>设置元表（元表会在注册时创建，见下文）。<br>至于为什么需要给<code>userdata</code>关联元表，因为<code>userdata</code>只是一个指针而已没有任何方法，所以需要设置一个元表（元表也是一个table）。 lua的查找路径：</p>\n<ol>\n<li>在当前的表中查找，如果找到，返回该元素，找不到则继续2。</li>\n<li>判断该表是否有元表，如果没有元表，返回nil，有元表则继续3 。</li>\n<li>判断元表有没有 <code>__index</code>，如果<code>__index</code>方法为nil，则返回nil；如果<code>__index</code>的值是一个table，则重复1、2、3；如果<code>__index</code>的值是一个function，则返回该函数的返回值。   </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int create_account(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tdouble balance = luaL_checknumber(L,1);</span><br><span class=\"line\">\tAccount **a = (Account**)lua_newuserdata(L,sizeof(Account));</span><br><span class=\"line\">\t*a = new Account(balance);</span><br><span class=\"line\">\tprintf(&quot;construct! balance is: %lf\\n&quot;,balance);</span><br><span class=\"line\">\tluaL_getmetatable(L,&quot;Account&quot;);</span><br><span class=\"line\">\tlua_setmetatable(L,-2);//将userdata与Account metatable关联起来</span><br><span class=\"line\">\treturn 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、-C-类Account的方法映射到C函数\"><a href=\"#3、-C-类Account的方法映射到C函数\" class=\"headerlink\" title=\"3、 C++ 类Account的方法映射到C函数\"></a>3、 C++ 类<code>Account</code>的方法映射到C函数</h4><p>每一个函数原理都基本一致：   </p>\n<ul>\n<li>首先，从Lua栈顶获取<code>userdata</code>   </li>\n<li>取<code>userdata</code>保存的C++对象的指针   </li>\n<li>最后，对过C++对象指针访问对应方法   </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Account* checkaccount(lua_State *L, int narg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tluaL_checktype(L,narg, LUA_TUSERDATA);</span><br><span class=\"line\">\tvoid *ud = luaL_checkudata(L,narg,&quot;Account&quot;);</span><br><span class=\"line\">\tluaL_argcheck(L,ud!= NULL,1,&quot;user data error&quot;);</span><br><span class=\"line\">\treturn *(Account**)ud;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int deposit(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);</span><br><span class=\"line\">\tdouble amount = luaL_checknumber(L,-1);</span><br><span class=\"line\">\t(a)-&gt;deposit(amount);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int withdraw(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);</span><br><span class=\"line\">\tdouble amount = luaL_checknumber(L,-1);</span><br><span class=\"line\">\t(a)-&gt;withdraw(amount);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int balance(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);</span><br><span class=\"line\">\tdouble balance = (a)-&gt;balance();</span><br><span class=\"line\">\tprintf(&quot;balance is: %lf\\n&quot;,balance);</span><br><span class=\"line\">\tlua_pushnumber(L,balance);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4、注册\"><a href=\"#4、注册\" class=\"headerlink\" title=\"4、注册\"></a>4、注册</h4><ul>\n<li>创建一个<code>metatable</code> <code>Account</code>，<code>Account</code>将会关联到存储C++对象的<code>userdata</code></li>\n<li>将第三步的C函数注册到<code>Account</code>表</li>\n<li>注册一个<code>Account</code>全局函数，可以理解为在Lua中的一个构造函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">static const luaL_Reg methods[]= &#123;</span><br><span class=\"line\">\t//&#123;&quot;Account&quot;,create_account&#125;,</span><br><span class=\"line\">\t&#123;&quot;deposit&quot;,deposit&#125;,</span><br><span class=\"line\">\t&#123;&quot;withdraw&quot;,withdraw&#125;,</span><br><span class=\"line\">\t&#123;&quot;balance&quot;,balance&#125;,</span><br><span class=\"line\">\t&#123;NULL,NULL&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int luaopen_Account(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tluaL_newmetatable(L,&quot;Account&quot;);</span><br><span class=\"line\">\tlua_pushvalue(L,-1);</span><br><span class=\"line\">\tlua_setfield(L,-2,&quot;__index&quot;);//Account.__index = Account</span><br><span class=\"line\">\tluaL_setfuncs(L,methods,0);//register the methods to the table that is on the top</span><br><span class=\"line\">\treturn 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static const luaL_Reg libs [] = &#123;&quot;Account&quot;,luaopen_Account&#125;,&#123;NULL,NULL&#125;;</span><br><span class=\"line\">void Register(lua_State* L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tconst luaL_Reg *lib = libs;</span><br><span class=\"line\">\tfor (;lib-&gt;func; lib++) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tluaL_requiref(L, lib-&gt;name, lib-&gt;func, 1);</span><br><span class=\"line\">\t\tlua_pop(L, 1);  /* remove lib */</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlua_register(L,&quot;Account&quot;,create_account);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"5、test-lua\"><a href=\"#5、test-lua\" class=\"headerlink\" title=\"5、test.lua\"></a>5、test.lua</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(&quot;start&quot;);</span><br><span class=\"line\">local a  = Account(100);</span><br><span class=\"line\">print(a);</span><br><span class=\"line\">print(a:balance());</span><br><span class=\"line\">a:deposit(399);</span><br><span class=\"line\">print(&quot;start&quot;);</span><br><span class=\"line\">print(a:balance());</span><br><span class=\"line\">print(&quot;end&quot;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"img/cppr.png\" alt=\"img\">    </p>\n<h2 id=\"三、C-类导入Lua\"><a href=\"#三、C-类导入Lua\" class=\"headerlink\" title=\"三、C#类导入Lua\"></a>三、C#类导入Lua</h2><p>C# 单个函数导入Lua比较简单与 C 导入Lua基本一致，此处就不赘述。C#类的导入则与C++差不多，但是怎么将C#对象存储于<code>userdata</code>是一个问题。有两种方案处理这个问题（仅本人所知）：</p>\n<ul>\n<li>C# 对象可以通过<code>Marshal.StructureToPtr</code>转为<code>IntPtr</code>的指针，但是要求类添加<code>[StructLayout(LayoutKind.Sequential)]</code>标记，如此如果要导出一些非自定义类可能比较麻烦。   </li>\n<li>另一个方法，将一个<code>int</code>存储于<code>userdata</code>，并以<code>int</code>做key C#对象为value缓存于C#字典中，对于<code>userdata</code>的其它操作与C++一致。当lua调用该对象时，通过<code>Marshal.ReadInt32</code>函数，将返回的<code>userdata</code>转为一个<code>int</code>的key从C#对象字典中取出实际对象即可。     </li>\n</ul>\n<p>接下来就方法二进行一下了解。</p>\n<h3 id=\"3-1-实例\"><a href=\"#3-1-实例\" class=\"headerlink\" title=\"3.1 实例\"></a>3.1 实例</h3><p>说明：</p>\n<ul>\n<li>将Lua虚拟机制作为Dll，并添加到Unity工程，本文直接使用的Slua来测试的</li>\n<li>本文环境为Unity</li>\n</ul>\n<h4 id=\"1、将要导入Lua的C-类LuaTestDemo\"><a href=\"#1、将要导入Lua的C-类LuaTestDemo\" class=\"headerlink\" title=\"1、将要导入Lua的C#类LuaTestDemo\"></a>1、将要导入Lua的C#类<code>LuaTestDemo</code></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class LuaTestDemo:System.Object</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public double Add(double a, double b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Debug.Log(&quot;lua call the Add function!!&quot;);</span><br><span class=\"line\">        double ret = a + b;</span><br><span class=\"line\">        Debug.Log(&quot;==========: &quot;+ret);</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、“构造”函数\"><a href=\"#2、“构造”函数\" class=\"headerlink\" title=\"2、“构造”函数\"></a>2、“构造”函数</h4><p>与C++处理流程基本一致，<strong>需要注意的是<code>userdata</code>的值是<code>100</code>，并将<code>LuaTestDemo</code>的实例做为<code>100</code>的value存入<code>Dictionary</code></strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]</span><br><span class=\"line\"> public static int CreateLuaTestDemo(IntPtr l)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      Debug.Log(&quot;lua call the CreateLuaTestDemo function!!&quot;);</span><br><span class=\"line\">      LuaDLL.luaS_newuserdata(l,100);//userdata is 100</span><br><span class=\"line\">      LuaTestDemo o = new LuaTestDemo();</span><br><span class=\"line\">      cache.Add(100,o);//map object to userdata</span><br><span class=\"line\">      LuaDLL.puaL_getmetatable(l, &quot;LuaTestDemo&quot;);//connect the userdata to LuaTestDemo metatable</span><br><span class=\"line\">      LuaDLL.pua_setmetatable(l, -2);</span><br><span class=\"line\">      return 1;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、Wrapper\"><a href=\"#3、Wrapper\" class=\"headerlink\" title=\"3、Wrapper.\"></a>3、Wrapper.</h4><p>与C++一致，<strong>需要注意的<code>userdata</code>获取的是一个<code>int</code>，并以<code>int</code>为key获取C#对象，然后访问对应方法;</strong>     <strong>通过[MonoPInvokeCallbackAttribute]标签让C语言可以直接调用C#函数</strong>    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static LuaTestDemo checkuserdata(IntPtr l)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          LuaDLL.puaL_checktype(l,1,LuaTypes.LUA_TUSERDATA);</span><br><span class=\"line\">          IntPtr userdata = LuaDLL.puaL_checkudata(l, 1, &quot;LuaTestDemo&quot;);</span><br><span class=\"line\">          int index = Marshal.ReadInt32(userdata);</span><br><span class=\"line\">          Debug.Log(&quot;userdata is: &quot; + index);</span><br><span class=\"line\">          LuaTestDemo o = cache[index];</span><br><span class=\"line\">          return o;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]</span><br><span class=\"line\">      static public int AddWrapper(IntPtr l)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          Debug.Log(&quot;lua call the AddWrapper function!!&quot;);</span><br><span class=\"line\">          LuaTestDemo o = checkuserdata(l);</span><br><span class=\"line\">          double a = LuaDLL.pua_tonumber(l, -1);</span><br><span class=\"line\">          double b = LuaDLL.pua_tonumber(l, -2);</span><br><span class=\"line\">          double ret = o.Add(a,b);</span><br><span class=\"line\">          LuaDLL.pua_pushnumber(l, ret);</span><br><span class=\"line\">          return 1;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4、注册-1\"><a href=\"#4、注册-1\" class=\"headerlink\" title=\"4、注册\"></a>4、注册</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    public static void Reg(IntPtr l)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LuaDLL.puaL_newmetatable(l, &quot;LuaTestDemo&quot;);</span><br><span class=\"line\">        LuaDLL.pua_pushvalue(l,-1);</span><br><span class=\"line\">        LuaDLL.pua_setfield(l,-2,&quot;__index&quot;);//LuaTestDemo.__index = LuaTestDemo</span><br><span class=\"line\">        LuaDLL.pua_pushcclosure(l, AddWrapper, 0);</span><br><span class=\"line\">        LuaDLL.pua_setfield(l,-2,&quot;Add&quot;);</span><br><span class=\"line\">        LuaDLL.pua_pop(l,1);</span><br><span class=\"line\">        </span><br><span class=\"line\">        LuaDLL.pua_pushcclosure(l, CreateLuaTestDemo , 0);</span><br><span class=\"line\">        LuaDLL.pua_setglobal(l, &quot;LuaTestDemo&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"5、测试\"><a href=\"#5、测试\" class=\"headerlink\" title=\"5、测试\"></a>5、测试</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntPtr l = LuaDLL.puaL_newstate();</span><br><span class=\"line\">\t\tLuaTestDemoWrapper.Reg(l);</span><br><span class=\"line\">\t\tstring lua = &quot;&quot; +</span><br><span class=\"line\">\t\t             &quot;local d = LuaTestDemo();&quot; +</span><br><span class=\"line\">\t\t             &quot;local ret = d:Add(100,500);&quot; +</span><br><span class=\"line\">\t\t             &quot;local ret2 = d:Add(1000,5000);&quot; +</span><br><span class=\"line\">\t\t             &quot;print(\\&quot;ret is:\\&quot;..ret..\\&quot;   \\&quot;..ret2);&quot; +</span><br><span class=\"line\">\t\t             &quot;&quot;;</span><br><span class=\"line\">\t\tLuaDLL.pua_dostring(l,lua);</span><br></pre></td></tr></table></figure>\n<p><img src=\"img/csr.png\" alt=\"img\">    </p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><ul>\n<li>上文仅是一个入门的学习，没有涉及到内存的管理，内存的管理应该是比较核心的。</li>\n<li>C/C++/C#导入Lua的本质可以简单理解为，宿主程序通过Lua栈从Lua获取参数，然后宿主程序将计算结果压入Lua栈供Lua读取</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C-C-C-导入Lua浅入浅出\"><a href=\"#C-C-C-导入Lua浅入浅出\" class=\"headerlink\" title=\"C/C++/C#导入Lua浅入浅出\"></a>C/C++/C#导入Lua浅入浅出</h1><h2 id=\"一、C函数导入Lua\"><a href=\"#一、C函数导入Lua\" class=\"headerlink\" title=\"一、C函数导入Lua\"></a>一、C函数导入Lua</h2><p>因为Lua虚拟机就是C编写的，C函数导入Lua通过Lua C API就可以完成，相对还是比较简单。需要掌握的知识点就是Lua栈及Lua C API：  </p>\n<ul>\n<li>Lua栈可以类比于计算机的内存  </li>\n<li>Lua C API类似于汇编语言，Lua C API可以操纵Lua栈，通过操纵Lua栈可以达到与Lua交互的目的。<a href=\"https://cloudwu.github.io/lua53doc/manual.html\" target=\"_blank\" rel=\"noopener\">Lua C API 参考</a></li>\n</ul>\n<h3 id=\"1-1-实例\"><a href=\"#1-1-实例\" class=\"headerlink\" title=\"1.1 实例\"></a>1.1 实例</h3><p><code>lua_tonumber</code>表示从Lua栈指定<code>index</code>处取参数，<code>lua_pushnumber</code>表示把number压入栈顶。<code>Add</code>函数本质就是从Lua栈上取两个参数然后再将两个参数的计算结果压入Lua栈供Lua获取。   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int MyAdd(lua_State* l) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint n = lua_tonumber(l,-1);</span><br><span class=\"line\">\tint n2 = lua_tonumber(l,-2);</span><br><span class=\"line\">\tint ret = n + n2;</span><br><span class=\"line\">\tlua_pushnumber(l,ret);</span><br><span class=\"line\">\treturn 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面定义了一个C函数<code>MyAdd</code>，接下来要做的事情就是将C函数导入Lua，<code>lua_register</code>（还有其它相关API）就可以将C函数注册到Lua中，<code>luaL_dostring</code>执行段Lua代码。   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">int main(int argc, _TCHAR* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tlua_State *l = luaL_newstate();</span><br><span class=\"line\">\tluaL_openlibs(l);</span><br><span class=\"line\">\tlua_register(l,&quot;MyAdd&quot;,MyAdd);</span><br><span class=\"line\">\t//执行lua代码</span><br><span class=\"line\">\tluaL_dostring(l,&quot;print(\\&quot;MyAdd result is:\\&quot;);print(MyAdd(100,200))&quot;);   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"img/cr.png\" alt=\"img\">    </p>\n<h2 id=\"二、C-导入Lua\"><a href=\"#二、C-导入Lua\" class=\"headerlink\" title=\"二、C++导入Lua\"></a>二、C++导入Lua</h2><p>上文已经简单了解了C函数导入Lua的原理，C++类的方法的导入可以通过C函数Wrapper C++的方法，然后再将C函数导入Lua。但是需要注意的是怎么样在Lua访问C++的对象，一般可以通过<code>userdata</code>存储C++对象的指针，然后访问时从<code>userdata</code>中取。<br>一般将C++类导入Lua里分为三步：  </p>\n<ul>\n<li>首先，创建一个<code>userdata</code> 存放 C++ 对象指针    </li>\n<li>然后给 <code>userdata</code> 添加元表</li>\n<li>用 <code>__index</code> 元方法映射 C++ 中的方法。    </li>\n</ul>\n<h3 id=\"2-1-实例\"><a href=\"#2-1-实例\" class=\"headerlink\" title=\"2.1 实例\"></a>2.1 实例</h3><h4 id=\"1、-准备将要导入Lua的自定义C-Account类\"><a href=\"#1、-准备将要导入Lua的自定义C-Account类\" class=\"headerlink\" title=\"1、 准备将要导入Lua的自定义C++ Account类\"></a>1、 准备将要导入Lua的自定义C++ <code>Account</code>类</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Account &#123;</span><br><span class=\"line\">public: </span><br><span class=\"line\">\tAccount(double balance)&#123; m_balance = balance;&#125;</span><br><span class=\"line\">\tvoid deposit(double amount)&#123;m_balance += amount;&#125;</span><br><span class=\"line\">\tvoid withdraw(double amount)&#123;m_balance -= amount;&#125;</span><br><span class=\"line\">\tdouble balance()&#123;return m_balance;&#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tdouble m_balance;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、-“构造”函数\"><a href=\"#2、-“构造”函数\" class=\"headerlink\" title=\"2、 “构造”函数\"></a>2、 “构造”函数</h4><p>通过<code>lua_newuserdata</code>创建一个<code>userdata</code>，并将<code>Account</code>对象的指针存储于<code>userdata</code>。然后，通过<code>lua_setmetatable</code>给<code>userdata</code>设置元表（元表会在注册时创建，见下文）。<br>至于为什么需要给<code>userdata</code>关联元表，因为<code>userdata</code>只是一个指针而已没有任何方法，所以需要设置一个元表（元表也是一个table）。 lua的查找路径：</p>\n<ol>\n<li>在当前的表中查找，如果找到，返回该元素，找不到则继续2。</li>\n<li>判断该表是否有元表，如果没有元表，返回nil，有元表则继续3 。</li>\n<li>判断元表有没有 <code>__index</code>，如果<code>__index</code>方法为nil，则返回nil；如果<code>__index</code>的值是一个table，则重复1、2、3；如果<code>__index</code>的值是一个function，则返回该函数的返回值。   </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int create_account(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tdouble balance = luaL_checknumber(L,1);</span><br><span class=\"line\">\tAccount **a = (Account**)lua_newuserdata(L,sizeof(Account));</span><br><span class=\"line\">\t*a = new Account(balance);</span><br><span class=\"line\">\tprintf(&quot;construct! balance is: %lf\\n&quot;,balance);</span><br><span class=\"line\">\tluaL_getmetatable(L,&quot;Account&quot;);</span><br><span class=\"line\">\tlua_setmetatable(L,-2);//将userdata与Account metatable关联起来</span><br><span class=\"line\">\treturn 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、-C-类Account的方法映射到C函数\"><a href=\"#3、-C-类Account的方法映射到C函数\" class=\"headerlink\" title=\"3、 C++ 类Account的方法映射到C函数\"></a>3、 C++ 类<code>Account</code>的方法映射到C函数</h4><p>每一个函数原理都基本一致：   </p>\n<ul>\n<li>首先，从Lua栈顶获取<code>userdata</code>   </li>\n<li>取<code>userdata</code>保存的C++对象的指针   </li>\n<li>最后，对过C++对象指针访问对应方法   </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Account* checkaccount(lua_State *L, int narg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tluaL_checktype(L,narg, LUA_TUSERDATA);</span><br><span class=\"line\">\tvoid *ud = luaL_checkudata(L,narg,&quot;Account&quot;);</span><br><span class=\"line\">\tluaL_argcheck(L,ud!= NULL,1,&quot;user data error&quot;);</span><br><span class=\"line\">\treturn *(Account**)ud;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int deposit(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);</span><br><span class=\"line\">\tdouble amount = luaL_checknumber(L,-1);</span><br><span class=\"line\">\t(a)-&gt;deposit(amount);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int withdraw(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);</span><br><span class=\"line\">\tdouble amount = luaL_checknumber(L,-1);</span><br><span class=\"line\">\t(a)-&gt;withdraw(amount);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int balance(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);</span><br><span class=\"line\">\tdouble balance = (a)-&gt;balance();</span><br><span class=\"line\">\tprintf(&quot;balance is: %lf\\n&quot;,balance);</span><br><span class=\"line\">\tlua_pushnumber(L,balance);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4、注册\"><a href=\"#4、注册\" class=\"headerlink\" title=\"4、注册\"></a>4、注册</h4><ul>\n<li>创建一个<code>metatable</code> <code>Account</code>，<code>Account</code>将会关联到存储C++对象的<code>userdata</code></li>\n<li>将第三步的C函数注册到<code>Account</code>表</li>\n<li>注册一个<code>Account</code>全局函数，可以理解为在Lua中的一个构造函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">static const luaL_Reg methods[]= &#123;</span><br><span class=\"line\">\t//&#123;&quot;Account&quot;,create_account&#125;,</span><br><span class=\"line\">\t&#123;&quot;deposit&quot;,deposit&#125;,</span><br><span class=\"line\">\t&#123;&quot;withdraw&quot;,withdraw&#125;,</span><br><span class=\"line\">\t&#123;&quot;balance&quot;,balance&#125;,</span><br><span class=\"line\">\t&#123;NULL,NULL&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int luaopen_Account(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tluaL_newmetatable(L,&quot;Account&quot;);</span><br><span class=\"line\">\tlua_pushvalue(L,-1);</span><br><span class=\"line\">\tlua_setfield(L,-2,&quot;__index&quot;);//Account.__index = Account</span><br><span class=\"line\">\tluaL_setfuncs(L,methods,0);//register the methods to the table that is on the top</span><br><span class=\"line\">\treturn 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static const luaL_Reg libs [] = &#123;&quot;Account&quot;,luaopen_Account&#125;,&#123;NULL,NULL&#125;;</span><br><span class=\"line\">void Register(lua_State* L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tconst luaL_Reg *lib = libs;</span><br><span class=\"line\">\tfor (;lib-&gt;func; lib++) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tluaL_requiref(L, lib-&gt;name, lib-&gt;func, 1);</span><br><span class=\"line\">\t\tlua_pop(L, 1);  /* remove lib */</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlua_register(L,&quot;Account&quot;,create_account);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"5、test-lua\"><a href=\"#5、test-lua\" class=\"headerlink\" title=\"5、test.lua\"></a>5、test.lua</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(&quot;start&quot;);</span><br><span class=\"line\">local a  = Account(100);</span><br><span class=\"line\">print(a);</span><br><span class=\"line\">print(a:balance());</span><br><span class=\"line\">a:deposit(399);</span><br><span class=\"line\">print(&quot;start&quot;);</span><br><span class=\"line\">print(a:balance());</span><br><span class=\"line\">print(&quot;end&quot;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"img/cppr.png\" alt=\"img\">    </p>\n<h2 id=\"三、C-类导入Lua\"><a href=\"#三、C-类导入Lua\" class=\"headerlink\" title=\"三、C#类导入Lua\"></a>三、C#类导入Lua</h2><p>C# 单个函数导入Lua比较简单与 C 导入Lua基本一致，此处就不赘述。C#类的导入则与C++差不多，但是怎么将C#对象存储于<code>userdata</code>是一个问题。有两种方案处理这个问题（仅本人所知）：</p>\n<ul>\n<li>C# 对象可以通过<code>Marshal.StructureToPtr</code>转为<code>IntPtr</code>的指针，但是要求类添加<code>[StructLayout(LayoutKind.Sequential)]</code>标记，如此如果要导出一些非自定义类可能比较麻烦。   </li>\n<li>另一个方法，将一个<code>int</code>存储于<code>userdata</code>，并以<code>int</code>做key C#对象为value缓存于C#字典中，对于<code>userdata</code>的其它操作与C++一致。当lua调用该对象时，通过<code>Marshal.ReadInt32</code>函数，将返回的<code>userdata</code>转为一个<code>int</code>的key从C#对象字典中取出实际对象即可。     </li>\n</ul>\n<p>接下来就方法二进行一下了解。</p>\n<h3 id=\"3-1-实例\"><a href=\"#3-1-实例\" class=\"headerlink\" title=\"3.1 实例\"></a>3.1 实例</h3><p>说明：</p>\n<ul>\n<li>将Lua虚拟机制作为Dll，并添加到Unity工程，本文直接使用的Slua来测试的</li>\n<li>本文环境为Unity</li>\n</ul>\n<h4 id=\"1、将要导入Lua的C-类LuaTestDemo\"><a href=\"#1、将要导入Lua的C-类LuaTestDemo\" class=\"headerlink\" title=\"1、将要导入Lua的C#类LuaTestDemo\"></a>1、将要导入Lua的C#类<code>LuaTestDemo</code></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class LuaTestDemo:System.Object</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public double Add(double a, double b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Debug.Log(&quot;lua call the Add function!!&quot;);</span><br><span class=\"line\">        double ret = a + b;</span><br><span class=\"line\">        Debug.Log(&quot;==========: &quot;+ret);</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、“构造”函数\"><a href=\"#2、“构造”函数\" class=\"headerlink\" title=\"2、“构造”函数\"></a>2、“构造”函数</h4><p>与C++处理流程基本一致，<strong>需要注意的是<code>userdata</code>的值是<code>100</code>，并将<code>LuaTestDemo</code>的实例做为<code>100</code>的value存入<code>Dictionary</code></strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]</span><br><span class=\"line\"> public static int CreateLuaTestDemo(IntPtr l)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      Debug.Log(&quot;lua call the CreateLuaTestDemo function!!&quot;);</span><br><span class=\"line\">      LuaDLL.luaS_newuserdata(l,100);//userdata is 100</span><br><span class=\"line\">      LuaTestDemo o = new LuaTestDemo();</span><br><span class=\"line\">      cache.Add(100,o);//map object to userdata</span><br><span class=\"line\">      LuaDLL.puaL_getmetatable(l, &quot;LuaTestDemo&quot;);//connect the userdata to LuaTestDemo metatable</span><br><span class=\"line\">      LuaDLL.pua_setmetatable(l, -2);</span><br><span class=\"line\">      return 1;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、Wrapper\"><a href=\"#3、Wrapper\" class=\"headerlink\" title=\"3、Wrapper.\"></a>3、Wrapper.</h4><p>与C++一致，<strong>需要注意的<code>userdata</code>获取的是一个<code>int</code>，并以<code>int</code>为key获取C#对象，然后访问对应方法;</strong>     <strong>通过[MonoPInvokeCallbackAttribute]标签让C语言可以直接调用C#函数</strong>    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static LuaTestDemo checkuserdata(IntPtr l)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          LuaDLL.puaL_checktype(l,1,LuaTypes.LUA_TUSERDATA);</span><br><span class=\"line\">          IntPtr userdata = LuaDLL.puaL_checkudata(l, 1, &quot;LuaTestDemo&quot;);</span><br><span class=\"line\">          int index = Marshal.ReadInt32(userdata);</span><br><span class=\"line\">          Debug.Log(&quot;userdata is: &quot; + index);</span><br><span class=\"line\">          LuaTestDemo o = cache[index];</span><br><span class=\"line\">          return o;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]</span><br><span class=\"line\">      static public int AddWrapper(IntPtr l)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          Debug.Log(&quot;lua call the AddWrapper function!!&quot;);</span><br><span class=\"line\">          LuaTestDemo o = checkuserdata(l);</span><br><span class=\"line\">          double a = LuaDLL.pua_tonumber(l, -1);</span><br><span class=\"line\">          double b = LuaDLL.pua_tonumber(l, -2);</span><br><span class=\"line\">          double ret = o.Add(a,b);</span><br><span class=\"line\">          LuaDLL.pua_pushnumber(l, ret);</span><br><span class=\"line\">          return 1;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4、注册-1\"><a href=\"#4、注册-1\" class=\"headerlink\" title=\"4、注册\"></a>4、注册</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    public static void Reg(IntPtr l)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LuaDLL.puaL_newmetatable(l, &quot;LuaTestDemo&quot;);</span><br><span class=\"line\">        LuaDLL.pua_pushvalue(l,-1);</span><br><span class=\"line\">        LuaDLL.pua_setfield(l,-2,&quot;__index&quot;);//LuaTestDemo.__index = LuaTestDemo</span><br><span class=\"line\">        LuaDLL.pua_pushcclosure(l, AddWrapper, 0);</span><br><span class=\"line\">        LuaDLL.pua_setfield(l,-2,&quot;Add&quot;);</span><br><span class=\"line\">        LuaDLL.pua_pop(l,1);</span><br><span class=\"line\">        </span><br><span class=\"line\">        LuaDLL.pua_pushcclosure(l, CreateLuaTestDemo , 0);</span><br><span class=\"line\">        LuaDLL.pua_setglobal(l, &quot;LuaTestDemo&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"5、测试\"><a href=\"#5、测试\" class=\"headerlink\" title=\"5、测试\"></a>5、测试</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntPtr l = LuaDLL.puaL_newstate();</span><br><span class=\"line\">\t\tLuaTestDemoWrapper.Reg(l);</span><br><span class=\"line\">\t\tstring lua = &quot;&quot; +</span><br><span class=\"line\">\t\t             &quot;local d = LuaTestDemo();&quot; +</span><br><span class=\"line\">\t\t             &quot;local ret = d:Add(100,500);&quot; +</span><br><span class=\"line\">\t\t             &quot;local ret2 = d:Add(1000,5000);&quot; +</span><br><span class=\"line\">\t\t             &quot;print(\\&quot;ret is:\\&quot;..ret..\\&quot;   \\&quot;..ret2);&quot; +</span><br><span class=\"line\">\t\t             &quot;&quot;;</span><br><span class=\"line\">\t\tLuaDLL.pua_dostring(l,lua);</span><br></pre></td></tr></table></figure>\n<p><img src=\"img/csr.png\" alt=\"img\">    </p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><ul>\n<li>上文仅是一个入门的学习，没有涉及到内存的管理，内存的管理应该是比较核心的。</li>\n<li>C/C++/C#导入Lua的本质可以简单理解为，宿主程序通过Lua栈从Lua获取参数，然后宿主程序将计算结果压入Lua栈供Lua读取</li>\n</ul>\n"},{"title":"Blocks in iOS","date":"2017-03-19T03:01:20.000Z","_content":"> 最近由于工作原因，对iOS Block进行一次学习,本篇文章对Block的内存使用相关的内容简要整理一下，解释其中一些原理和使用Block需要注意的问题 。\n\n<!--More-->\n\n# 一、关于Block的内存表示\n## 1.1、`clang -rewite-objc 源文件 -o 目标文件（可以为.txt）`\n+ 首先我们来看一段常见源码，通过上述命令查看其中间文件：\n\n```     \n\n\ttypedef void (^ test1) (BOOL success, NSError *error) ;\n\n\tint main(int argc, char * argv[]) {\n\t    @autoreleasepool {\n\t        int base =10;\n\t        for(int i=0;i<10;i++){\n\t            int a =10;\n\t            // int *b  = (int*)malloc(10*sizeof(int));\n\t            void (^ test) (BOOL success, NSError *error)= ^(BOOL success, NSError *error) {\n\t                NSLog(@\"sssss:%d,base:%d\",success,base);\n\t            } ;\n\t            test(1,nil);\n\t           \n\t        }\n\t\n\t//        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n\t    }\n\t}\n\n```\n\n+ 通过sublime打开目标文件会发现代码远不止上面那寥寥几行，不难从其中可以找到如下与Block相关的代码。\n\n```\n\n\tstruct __block_impl {\n  \t\tvoid *isa;\n  \t\tint Flags;\n  \t\tint Reserved;\n  \t\tvoid *FuncPtr;\n\t};\n```\n\n`struct __block_impl`就是block的真面目，结构还是相当清晰。`isa`对OC开发人员再熟悉不过，是表示其类型或者说本质的，block有三种类型`NSGlobalBlock`，`NSStackBlock`,`NSMallocBlock`，不同类型的block就是通过`isa`字段区分。然后就是`FuncPtr`，顾名思义就是指向某一函数的指针。其实block本质上与c语言中的函数指针是一样的。\n\n```   \n\n\tstruct __main_block_impl_0 {\n\t  struct __block_impl impl;\n\t  struct __main_block_desc_0* Desc;\n\t  int base;\n\t  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _base, int flags=0) : base(_base) {\n\t    impl.isa = &_NSConcreteStackBlock;\n\t    impl.Flags = flags;\n\t    impl.FuncPtr = fp;\n\t    Desc = desc;\n\t  }\n\t};\n\t\n\tstatic void __main_block_func_0(struct __main_block_impl_0 *__cself, BOOL success, NSError *error) {\n\t  int base = __cself->base; // bound by copy\n\t\n\t                NSLog((NSString *)&__NSConstantStringImpl__var_folders_rl_k02s7ny56tj7m7cg3kdrfpbh0000gn_T_main_0c0cda_mi_0,success,base);\n\t            }\n\n\tstatic struct __main_block_desc_0 {\n\t  size_t reserved;\n\t  size_t Block_size;\n\t} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n```\n```\n\n\tint main(int argc, char * argv[]) {\n\t    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n\t        int base =10;\n\t\n\t        for(int i=0;i<10;i++){\n\t            int a =10;\n\t\n\t            void (* test) (BOOL success, NSError *error)= (void (*)(BOOL, NSError *))((id (*)(id, SEL))(void *)objc_msgSend)((id)((void (*)(BOOL, NSError *))&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, base)), sel_registerName(\"copy\"));\n\t            ((void (*)(__block_impl *, BOOL, NSError *))((__block_impl *)test)->FuncPtr)((__block_impl *)test, 1, __null);\n\t\n\t    }\n\t}\n```\n以上这一段代码正是与源码相对应的`struct __main_block_impl_0`是此处block的真正实现，主要分为两部分一个是block的定义一个是block的一些描述。`__main_block_func_0`是具体执行的函数体。接下来就是要`main`函数体中初始化block，然后就大功告成可以便可享用block。\n以上揭示了block的本质。\n# 二、关于Block类型\n## 2.1 Block的类型\n\n|类|对象存储域|\n|:--|:--|\n|_NSConreteStackBlock|栈上|\n|_NSConreteGlobalBlock|全局数据区（.data区）|\n|_NSConreteMallocBlock|堆上|\n>在ARC开启时，将只有 _NSConreteGlobalBlock与_NSConreteMallocBlock。因为ARC下编译器会自己管理对象，默认copy到堆上\n\n其实Block的类型与其自动截获变量有关。\n\n+ _NSConreteGlobalBlock类型\n_NSConreteGlobalBlock类的Block，本质就与一个全局函数一样。不截获任何外部变量，只使用入参或者不使用任何参数，如：   \n\n\t\tvoid (^ blk )(void)= ^{print(\"Global Block\\n\")}\n\n+ _NSConreteStackBlock类型   \n一般来说Block除了Global Block外，首先他必须先是一个_NSConreteStackBlock，也就是配置在栈上的。 因为，Block变量首先得是一个变量，而代码中除了主动申请内存外其它变量都在栈上。\n\n+ _NSConreteMallocBlock类型    \n\n\t**那么关于_NSConreteMallocBlock类型何时才用到呢？由于_NSConreteStackBlock是配置于栈上，所以其生命周期也随其变量在栈上的生命周期。但实际开发中往往需要Block的生命周期更长。所以Block提供了复制，_NSConreteStackBlock可以复制到堆上也就是_NSConreteMallocBlock，在堆上的变量生命周期与栈无关，不会随着栈上变量变化。block 通常不会在源码中直接出现，因为默认它是当一个 block 被 copy 的时候，才会将这个 block 复制到堆中。**\n\t\n## 2.2 对Block进行copy的效果\n\n|类|源存储域|复制效果|   \n|:--|:--|:--|   \n|_NSConreteStackBlock|栈上|从栈复制到堆|   \n|_NSConreteGlobalBlock|全局数据区（.data区）|无效果|   \n|_NSConreteMallocBlock|堆上|引用计数增加|\n> 在ARC中一般不需要显示进行copy操作，编译器会自动判断。\n  \n\n# 三、__block变量\n\n**Block中可以进行修改的值包括三种：**   \n \n+ 全局变量   \n+ 静态变量   \n+ `__block`变量  \n\n前两种不用说，因为其存储在全局区域访问自然无可厚非，本节主要说一下`__block`变量。还是原来的demo，仅将其中的变量`base`声明为`__block`\n\n\t __block int base =10;\n\n经过重写后，结果又大不相同\n\n```\n\n\tstruct __Block_byref_base_0 {\n\t  void *__isa;\n\t__Block_byref_base_0 *__forwarding;\n\t int __flags;\n\t int __size;\n\t int base;\n\t};\n\n\tstruct __main_block_impl_0 {\n\t  struct __block_impl impl;\n\t  struct __main_block_desc_0* Desc;\n\t  __Block_byref_base_0 *base; // by ref\n\t  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_base_0 *_base, int flags=0) : base(_base->__forwarding) {\n\t    impl.isa = &_NSConcreteStackBlock;\n\t    impl.Flags = flags;\n\t    impl.FuncPtr = fp;\n\t    Desc = desc;\n\t  }\n\t};\n\tstatic void __main_block_func_0(struct __main_block_impl_0 *__cself, BOOL success, NSError *error) {\n\t  __Block_byref_base_0 *base = __cself->base; // bound by ref\n\t\n\t                NSLog((NSString *)&__NSConstantStringImpl__var_folders_rl_k02s7ny56tj7m7cg3kdrfpbh0000gn_T_main_5fdc20_mi_0,success,(base->__forwarding->base));\n\t            }\n\tstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&dst->base, (void*)src->base, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\t\n\tstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src->base, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\t\n\tstatic struct __main_block_desc_0 {\n\t  size_t reserved;\n\t  size_t Block_size;\n\t  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n\t  void (*dispose)(struct __main_block_impl_0*);\n\t} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};\n\tint main(int argc, char * argv[]) {\n\t    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n\t        __attribute__((__blocks__(byref))) __Block_byref_base_0 base = {(void*)0,(__Block_byref_base_0 *)&base, 0, sizeof(__Block_byref_base_0), 10};\n\t        for(int i=0;i<10;i++){\n\t            int a =10;\n\t\n\t            void (* test) (BOOL success, NSError *error)= ((void (*)(BOOL, NSError *))&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, (__Block_byref_base_0 *)&base, 570425344)) ;\n\t            ((void (*)(__block_impl *, BOOL, NSError *))((__block_impl *)test)->FuncPtr)((__block_impl *)test, 1, __null);\n\t\n\t        }\n\t\n\t\n\t    }\n\t}\n```    \n\n不难发现一个`__block`变量竟然是一个结构体。注意`main`函数中的`__block`变量的初始化已经演变成如下代码：     \n\n\t__attribute__((__blocks__(byref))) __Block_byref_base_0 base = \n\t{(void*)0,\n\t(__Block_byref_base_0 *)&base,\n\t 0, \n\tsizeof(__Block_byref_base_0), \n\t10\n\t};\n\n### __block变量在Block内外都可以访问\n\n注意结合该结构体声明分析。值得关注的是其`__forwarding`指针指向了自己本身。     \n**<font color = red>__forwarding的存在是为了不管__block变量是在堆上还是栈上都可以访问该变量，因为在复制__block变量到堆上是会改变栈上__block结构中的__forwarding指向堆上的，而堆上的__block变量指向自己本身，因此堆上与栈上都能可以该变量。</font>**\n\n\n# 总结\n### 1、 Block是一个OC对象\n### 2、__block变量可以有Block内外都可以访问，是由于`__forwarding`的存在\n### 3、虽然本文是研究Block的内存表象，但对于Block的常见问题还是得提一下，注意Block循环引用问题","source":"_posts/Blocks-in-iOS.md","raw":"---\ntitle: Blocks in iOS\ndate: 2017-03-19 11:01:20\ncategories: iOS\ntags: [iOS, Dev]\n---\n> 最近由于工作原因，对iOS Block进行一次学习,本篇文章对Block的内存使用相关的内容简要整理一下，解释其中一些原理和使用Block需要注意的问题 。\n\n<!--More-->\n\n# 一、关于Block的内存表示\n## 1.1、`clang -rewite-objc 源文件 -o 目标文件（可以为.txt）`\n+ 首先我们来看一段常见源码，通过上述命令查看其中间文件：\n\n```     \n\n\ttypedef void (^ test1) (BOOL success, NSError *error) ;\n\n\tint main(int argc, char * argv[]) {\n\t    @autoreleasepool {\n\t        int base =10;\n\t        for(int i=0;i<10;i++){\n\t            int a =10;\n\t            // int *b  = (int*)malloc(10*sizeof(int));\n\t            void (^ test) (BOOL success, NSError *error)= ^(BOOL success, NSError *error) {\n\t                NSLog(@\"sssss:%d,base:%d\",success,base);\n\t            } ;\n\t            test(1,nil);\n\t           \n\t        }\n\t\n\t//        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n\t    }\n\t}\n\n```\n\n+ 通过sublime打开目标文件会发现代码远不止上面那寥寥几行，不难从其中可以找到如下与Block相关的代码。\n\n```\n\n\tstruct __block_impl {\n  \t\tvoid *isa;\n  \t\tint Flags;\n  \t\tint Reserved;\n  \t\tvoid *FuncPtr;\n\t};\n```\n\n`struct __block_impl`就是block的真面目，结构还是相当清晰。`isa`对OC开发人员再熟悉不过，是表示其类型或者说本质的，block有三种类型`NSGlobalBlock`，`NSStackBlock`,`NSMallocBlock`，不同类型的block就是通过`isa`字段区分。然后就是`FuncPtr`，顾名思义就是指向某一函数的指针。其实block本质上与c语言中的函数指针是一样的。\n\n```   \n\n\tstruct __main_block_impl_0 {\n\t  struct __block_impl impl;\n\t  struct __main_block_desc_0* Desc;\n\t  int base;\n\t  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _base, int flags=0) : base(_base) {\n\t    impl.isa = &_NSConcreteStackBlock;\n\t    impl.Flags = flags;\n\t    impl.FuncPtr = fp;\n\t    Desc = desc;\n\t  }\n\t};\n\t\n\tstatic void __main_block_func_0(struct __main_block_impl_0 *__cself, BOOL success, NSError *error) {\n\t  int base = __cself->base; // bound by copy\n\t\n\t                NSLog((NSString *)&__NSConstantStringImpl__var_folders_rl_k02s7ny56tj7m7cg3kdrfpbh0000gn_T_main_0c0cda_mi_0,success,base);\n\t            }\n\n\tstatic struct __main_block_desc_0 {\n\t  size_t reserved;\n\t  size_t Block_size;\n\t} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n```\n```\n\n\tint main(int argc, char * argv[]) {\n\t    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n\t        int base =10;\n\t\n\t        for(int i=0;i<10;i++){\n\t            int a =10;\n\t\n\t            void (* test) (BOOL success, NSError *error)= (void (*)(BOOL, NSError *))((id (*)(id, SEL))(void *)objc_msgSend)((id)((void (*)(BOOL, NSError *))&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, base)), sel_registerName(\"copy\"));\n\t            ((void (*)(__block_impl *, BOOL, NSError *))((__block_impl *)test)->FuncPtr)((__block_impl *)test, 1, __null);\n\t\n\t    }\n\t}\n```\n以上这一段代码正是与源码相对应的`struct __main_block_impl_0`是此处block的真正实现，主要分为两部分一个是block的定义一个是block的一些描述。`__main_block_func_0`是具体执行的函数体。接下来就是要`main`函数体中初始化block，然后就大功告成可以便可享用block。\n以上揭示了block的本质。\n# 二、关于Block类型\n## 2.1 Block的类型\n\n|类|对象存储域|\n|:--|:--|\n|_NSConreteStackBlock|栈上|\n|_NSConreteGlobalBlock|全局数据区（.data区）|\n|_NSConreteMallocBlock|堆上|\n>在ARC开启时，将只有 _NSConreteGlobalBlock与_NSConreteMallocBlock。因为ARC下编译器会自己管理对象，默认copy到堆上\n\n其实Block的类型与其自动截获变量有关。\n\n+ _NSConreteGlobalBlock类型\n_NSConreteGlobalBlock类的Block，本质就与一个全局函数一样。不截获任何外部变量，只使用入参或者不使用任何参数，如：   \n\n\t\tvoid (^ blk )(void)= ^{print(\"Global Block\\n\")}\n\n+ _NSConreteStackBlock类型   \n一般来说Block除了Global Block外，首先他必须先是一个_NSConreteStackBlock，也就是配置在栈上的。 因为，Block变量首先得是一个变量，而代码中除了主动申请内存外其它变量都在栈上。\n\n+ _NSConreteMallocBlock类型    \n\n\t**那么关于_NSConreteMallocBlock类型何时才用到呢？由于_NSConreteStackBlock是配置于栈上，所以其生命周期也随其变量在栈上的生命周期。但实际开发中往往需要Block的生命周期更长。所以Block提供了复制，_NSConreteStackBlock可以复制到堆上也就是_NSConreteMallocBlock，在堆上的变量生命周期与栈无关，不会随着栈上变量变化。block 通常不会在源码中直接出现，因为默认它是当一个 block 被 copy 的时候，才会将这个 block 复制到堆中。**\n\t\n## 2.2 对Block进行copy的效果\n\n|类|源存储域|复制效果|   \n|:--|:--|:--|   \n|_NSConreteStackBlock|栈上|从栈复制到堆|   \n|_NSConreteGlobalBlock|全局数据区（.data区）|无效果|   \n|_NSConreteMallocBlock|堆上|引用计数增加|\n> 在ARC中一般不需要显示进行copy操作，编译器会自动判断。\n  \n\n# 三、__block变量\n\n**Block中可以进行修改的值包括三种：**   \n \n+ 全局变量   \n+ 静态变量   \n+ `__block`变量  \n\n前两种不用说，因为其存储在全局区域访问自然无可厚非，本节主要说一下`__block`变量。还是原来的demo，仅将其中的变量`base`声明为`__block`\n\n\t __block int base =10;\n\n经过重写后，结果又大不相同\n\n```\n\n\tstruct __Block_byref_base_0 {\n\t  void *__isa;\n\t__Block_byref_base_0 *__forwarding;\n\t int __flags;\n\t int __size;\n\t int base;\n\t};\n\n\tstruct __main_block_impl_0 {\n\t  struct __block_impl impl;\n\t  struct __main_block_desc_0* Desc;\n\t  __Block_byref_base_0 *base; // by ref\n\t  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_base_0 *_base, int flags=0) : base(_base->__forwarding) {\n\t    impl.isa = &_NSConcreteStackBlock;\n\t    impl.Flags = flags;\n\t    impl.FuncPtr = fp;\n\t    Desc = desc;\n\t  }\n\t};\n\tstatic void __main_block_func_0(struct __main_block_impl_0 *__cself, BOOL success, NSError *error) {\n\t  __Block_byref_base_0 *base = __cself->base; // bound by ref\n\t\n\t                NSLog((NSString *)&__NSConstantStringImpl__var_folders_rl_k02s7ny56tj7m7cg3kdrfpbh0000gn_T_main_5fdc20_mi_0,success,(base->__forwarding->base));\n\t            }\n\tstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&dst->base, (void*)src->base, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\t\n\tstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src->base, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\t\n\tstatic struct __main_block_desc_0 {\n\t  size_t reserved;\n\t  size_t Block_size;\n\t  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n\t  void (*dispose)(struct __main_block_impl_0*);\n\t} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};\n\tint main(int argc, char * argv[]) {\n\t    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n\t        __attribute__((__blocks__(byref))) __Block_byref_base_0 base = {(void*)0,(__Block_byref_base_0 *)&base, 0, sizeof(__Block_byref_base_0), 10};\n\t        for(int i=0;i<10;i++){\n\t            int a =10;\n\t\n\t            void (* test) (BOOL success, NSError *error)= ((void (*)(BOOL, NSError *))&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, (__Block_byref_base_0 *)&base, 570425344)) ;\n\t            ((void (*)(__block_impl *, BOOL, NSError *))((__block_impl *)test)->FuncPtr)((__block_impl *)test, 1, __null);\n\t\n\t        }\n\t\n\t\n\t    }\n\t}\n```    \n\n不难发现一个`__block`变量竟然是一个结构体。注意`main`函数中的`__block`变量的初始化已经演变成如下代码：     \n\n\t__attribute__((__blocks__(byref))) __Block_byref_base_0 base = \n\t{(void*)0,\n\t(__Block_byref_base_0 *)&base,\n\t 0, \n\tsizeof(__Block_byref_base_0), \n\t10\n\t};\n\n### __block变量在Block内外都可以访问\n\n注意结合该结构体声明分析。值得关注的是其`__forwarding`指针指向了自己本身。     \n**<font color = red>__forwarding的存在是为了不管__block变量是在堆上还是栈上都可以访问该变量，因为在复制__block变量到堆上是会改变栈上__block结构中的__forwarding指向堆上的，而堆上的__block变量指向自己本身，因此堆上与栈上都能可以该变量。</font>**\n\n\n# 总结\n### 1、 Block是一个OC对象\n### 2、__block变量可以有Block内外都可以访问，是由于`__forwarding`的存在\n### 3、虽然本文是研究Block的内存表象，但对于Block的常见问题还是得提一下，注意Block循环引用问题","slug":"Blocks-in-iOS","published":1,"updated":"2022-06-15T07:23:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4fa2s9o0002daco0s5lc8bi","content":"<blockquote>\n<p>最近由于工作原因，对iOS Block进行一次学习,本篇文章对Block的内存使用相关的内容简要整理一下，解释其中一些原理和使用Block需要注意的问题 。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"一、关于Block的内存表示\"><a href=\"#一、关于Block的内存表示\" class=\"headerlink\" title=\"一、关于Block的内存表示\"></a>一、关于Block的内存表示</h1><h2 id=\"1-1、clang-rewite-objc-源文件-o-目标文件（可以为-txt）\"><a href=\"#1-1、clang-rewite-objc-源文件-o-目标文件（可以为-txt）\" class=\"headerlink\" title=\"1.1、clang -rewite-objc 源文件 -o 目标文件（可以为.txt）\"></a>1.1、<code>clang -rewite-objc 源文件 -o 目标文件（可以为.txt）</code></h2><ul>\n<li>首先我们来看一段常见源码，通过上述命令查看其中间文件：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">typedef void (^ test1) (BOOL success, NSError *error) ;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        int base =10;</span><br><span class=\"line\">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class=\"line\">            int a =10;</span><br><span class=\"line\">            // int *b  = (int*)malloc(10*sizeof(int));</span><br><span class=\"line\">            void (^ test) (BOOL success, NSError *error)= ^(BOOL success, NSError *error) &#123;</span><br><span class=\"line\">                NSLog(@&quot;sssss:%d,base:%d&quot;,success,base);</span><br><span class=\"line\">            &#125; ;</span><br><span class=\"line\">            test(1,nil);</span><br><span class=\"line\">           </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过sublime打开目标文件会发现代码远不止上面那寥寥几行，不难从其中可以找到如下与Block相关的代码。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">struct __block_impl &#123;</span><br><span class=\"line\"> \t\tvoid *isa;</span><br><span class=\"line\"> \t\tint Flags;</span><br><span class=\"line\"> \t\tint Reserved;</span><br><span class=\"line\"> \t\tvoid *FuncPtr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>struct __block_impl</code>就是block的真面目，结构还是相当清晰。<code>isa</code>对OC开发人员再熟悉不过，是表示其类型或者说本质的，block有三种类型<code>NSGlobalBlock</code>，<code>NSStackBlock</code>,<code>NSMallocBlock</code>，不同类型的block就是通过<code>isa</code>字段区分。然后就是<code>FuncPtr</code>，顾名思义就是指向某一函数的指针。其实block本质上与c语言中的函数指针是一样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  struct __block_impl impl;</span><br><span class=\"line\">  struct __main_block_desc_0* Desc;</span><br><span class=\"line\">  int base;</span><br><span class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _base, int flags=0) : base(_base) &#123;</span><br><span class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">    impl.Flags = flags;</span><br><span class=\"line\">    impl.FuncPtr = fp;</span><br><span class=\"line\">    Desc = desc;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself, BOOL success, NSError *error) &#123;</span><br><span class=\"line\">  int base = __cself-&gt;base; // bound by copy</span><br><span class=\"line\"></span><br><span class=\"line\">                NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_rl_k02s7ny56tj7m7cg3kdrfpbh0000gn_T_main_0c0cda_mi_0,success,base);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static struct __main_block_desc_0 &#123;</span><br><span class=\"line\">  size_t reserved;</span><br><span class=\"line\">  size_t Block_size;</span><br><span class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char * argv[]) &#123;</span><br><span class=\"line\">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class=\"line\">        int base =10;</span><br><span class=\"line\"></span><br><span class=\"line\">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class=\"line\">            int a =10;</span><br><span class=\"line\"></span><br><span class=\"line\">            void (* test) (BOOL success, NSError *error)= (void (*)(BOOL, NSError *))((id (*)(id, SEL))(void *)objc_msgSend)((id)((void (*)(BOOL, NSError *))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, base)), sel_registerName(&quot;copy&quot;));</span><br><span class=\"line\">            ((void (*)(__block_impl *, BOOL, NSError *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test, 1, __null);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上这一段代码正是与源码相对应的<code>struct __main_block_impl_0</code>是此处block的真正实现，主要分为两部分一个是block的定义一个是block的一些描述。<code>__main_block_func_0</code>是具体执行的函数体。接下来就是要<code>main</code>函数体中初始化block，然后就大功告成可以便可享用block。<br>以上揭示了block的本质。</p>\n<h1 id=\"二、关于Block类型\"><a href=\"#二、关于Block类型\" class=\"headerlink\" title=\"二、关于Block类型\"></a>二、关于Block类型</h1><h2 id=\"2-1-Block的类型\"><a href=\"#2-1-Block的类型\" class=\"headerlink\" title=\"2.1 Block的类型\"></a>2.1 Block的类型</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类</th>\n<th style=\"text-align:left\">对象存储域</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">_NSConreteStackBlock</td>\n<td style=\"text-align:left\">栈上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">_NSConreteGlobalBlock</td>\n<td style=\"text-align:left\">全局数据区（.data区）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">_NSConreteMallocBlock</td>\n<td style=\"text-align:left\">堆上</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>在ARC开启时，将只有 _NSConreteGlobalBlock与_NSConreteMallocBlock。因为ARC下编译器会自己管理对象，默认copy到堆上</p>\n</blockquote>\n<p>其实Block的类型与其自动截获变量有关。</p>\n<ul>\n<li><p>_NSConreteGlobalBlock类型<br>_NSConreteGlobalBlock类的Block，本质就与一个全局函数一样。不截获任何外部变量，只使用入参或者不使用任何参数，如：   </p>\n<pre><code>void (^ blk )(void)= ^{print(&quot;Global Block\\n&quot;)}\n</code></pre></li>\n<li><p>_NSConreteStackBlock类型<br>一般来说Block除了Global Block外，首先他必须先是一个_NSConreteStackBlock，也就是配置在栈上的。 因为，Block变量首先得是一个变量，而代码中除了主动申请内存外其它变量都在栈上。</p>\n</li>\n<li><p>_NSConreteMallocBlock类型    </p>\n<p>  <strong>那么关于_NSConreteMallocBlock类型何时才用到呢？由于_NSConreteStackBlock是配置于栈上，所以其生命周期也随其变量在栈上的生命周期。但实际开发中往往需要Block的生命周期更长。所以Block提供了复制，_NSConreteStackBlock可以复制到堆上也就是_NSConreteMallocBlock，在堆上的变量生命周期与栈无关，不会随着栈上变量变化。block 通常不会在源码中直接出现，因为默认它是当一个 block 被 copy 的时候，才会将这个 block 复制到堆中。</strong></p>\n</li>\n</ul>\n<h2 id=\"2-2-对Block进行copy的效果\"><a href=\"#2-2-对Block进行copy的效果\" class=\"headerlink\" title=\"2.2 对Block进行copy的效果\"></a>2.2 对Block进行copy的效果</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类</th>\n<th style=\"text-align:left\">源存储域</th>\n<th style=\"text-align:left\">复制效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">_NSConreteStackBlock</td>\n<td style=\"text-align:left\">栈上</td>\n<td style=\"text-align:left\">从栈复制到堆</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">_NSConreteGlobalBlock</td>\n<td style=\"text-align:left\">全局数据区（.data区）</td>\n<td style=\"text-align:left\">无效果</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">_NSConreteMallocBlock</td>\n<td style=\"text-align:left\">堆上</td>\n<td style=\"text-align:left\">引用计数增加</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>在ARC中一般不需要显示进行copy操作，编译器会自动判断。</p>\n</blockquote>\n<h1 id=\"三、-block变量\"><a href=\"#三、-block变量\" class=\"headerlink\" title=\"三、__block变量\"></a>三、__block变量</h1><p><strong>Block中可以进行修改的值包括三种：</strong>   </p>\n<ul>\n<li>全局变量   </li>\n<li>静态变量   </li>\n<li><code>__block</code>变量  </li>\n</ul>\n<p>前两种不用说，因为其存储在全局区域访问自然无可厚非，本节主要说一下<code>__block</code>变量。还是原来的demo，仅将其中的变量<code>base</code>声明为<code>__block</code></p>\n<pre><code>__block int base =10;\n</code></pre><p>经过重写后，结果又大不相同</p>\n<pre><code>\nstruct __Block_byref_base_0 {\n  void *__isa;\n__Block_byref_base_0 *__forwarding;\n int __flags;\n int __size;\n int base;\n};\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __Block_byref_base_0 *base; // by ref\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_base_0 *_base, int flags=0) : base(_base-&gt;__forwarding) {\n    impl.isa = &amp;_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself, BOOL success, NSError *error) {\n  __Block_byref_base_0 *base = __cself-&gt;base; // bound by ref\n\n                NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_rl_k02s7ny56tj7m7cg3kdrfpbh0000gn_T_main_5fdc20_mi_0,success,(base-&gt;__forwarding-&gt;base));\n            }\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;base, (void*)src-&gt;base, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;base, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n  void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};\nint main(int argc, char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        __attribute__((__blocks__(byref))) __Block_byref_base_0 base = {(void*)0,(__Block_byref_base_0 *)&amp;base, 0, sizeof(__Block_byref_base_0), 10};\n        for(int i=0;i&lt;10;i++){\n            int a =10;\n\n            void (* test) (BOOL success, NSError *error)= ((void (*)(BOOL, NSError *))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_base_0 *)&amp;base, 570425344)) ;\n            ((void (*)(__block_impl *, BOOL, NSError *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test, 1, __null);\n\n        }\n\n\n    }\n}\n</code></pre><p>不难发现一个<code>__block</code>变量竟然是一个结构体。注意<code>main</code>函数中的<code>__block</code>变量的初始化已经演变成如下代码：     </p>\n<pre><code>__attribute__((__blocks__(byref))) __Block_byref_base_0 base = \n{(void*)0,\n(__Block_byref_base_0 *)&amp;base,\n 0, \nsizeof(__Block_byref_base_0), \n10\n};\n</code></pre><h3 id=\"block变量在Block内外都可以访问\"><a href=\"#block变量在Block内外都可以访问\" class=\"headerlink\" title=\"__block变量在Block内外都可以访问\"></a>__block变量在Block内外都可以访问</h3><p>注意结合该结构体声明分析。值得关注的是其<code>__forwarding</code>指针指向了自己本身。<br><strong><font color=\"red\"><strong>forwarding的存在是为了不管</strong>block变量是在堆上还是栈上都可以访问该变量，因为在复制<strong>block变量到堆上是会改变栈上</strong>block结构中的<strong>forwarding指向堆上的，而堆上的</strong>block变量指向自己本身，因此堆上与栈上都能可以该变量。</font></strong></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h3 id=\"1、-Block是一个OC对象\"><a href=\"#1、-Block是一个OC对象\" class=\"headerlink\" title=\"1、 Block是一个OC对象\"></a>1、 Block是一个OC对象</h3><h3 id=\"2、block变量可以有Block内外都可以访问，是由于-forwarding-的存在\"><a href=\"#2、block变量可以有Block内外都可以访问，是由于-forwarding-的存在\" class=\"headerlink\" title=\"2、block变量可以有Block内外都可以访问，是由于`forwarding`的存在\"></a>2、<strong>block变量可以有Block内外都可以访问，是由于`</strong>forwarding`的存在</h3><h3 id=\"3、虽然本文是研究Block的内存表象，但对于Block的常见问题还是得提一下，注意Block循环引用问题\"><a href=\"#3、虽然本文是研究Block的内存表象，但对于Block的常见问题还是得提一下，注意Block循环引用问题\" class=\"headerlink\" title=\"3、虽然本文是研究Block的内存表象，但对于Block的常见问题还是得提一下，注意Block循环引用问题\"></a>3、虽然本文是研究Block的内存表象，但对于Block的常见问题还是得提一下，注意Block循环引用问题</h3>","site":{"data":{}},"excerpt":"<blockquote>\n<p>最近由于工作原因，对iOS Block进行一次学习,本篇文章对Block的内存使用相关的内容简要整理一下，解释其中一些原理和使用Block需要注意的问题 。</p>\n</blockquote>","more":"<h1 id=\"一、关于Block的内存表示\"><a href=\"#一、关于Block的内存表示\" class=\"headerlink\" title=\"一、关于Block的内存表示\"></a>一、关于Block的内存表示</h1><h2 id=\"1-1、clang-rewite-objc-源文件-o-目标文件（可以为-txt）\"><a href=\"#1-1、clang-rewite-objc-源文件-o-目标文件（可以为-txt）\" class=\"headerlink\" title=\"1.1、clang -rewite-objc 源文件 -o 目标文件（可以为.txt）\"></a>1.1、<code>clang -rewite-objc 源文件 -o 目标文件（可以为.txt）</code></h2><ul>\n<li>首先我们来看一段常见源码，通过上述命令查看其中间文件：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">typedef void (^ test1) (BOOL success, NSError *error) ;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        int base =10;</span><br><span class=\"line\">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class=\"line\">            int a =10;</span><br><span class=\"line\">            // int *b  = (int*)malloc(10*sizeof(int));</span><br><span class=\"line\">            void (^ test) (BOOL success, NSError *error)= ^(BOOL success, NSError *error) &#123;</span><br><span class=\"line\">                NSLog(@&quot;sssss:%d,base:%d&quot;,success,base);</span><br><span class=\"line\">            &#125; ;</span><br><span class=\"line\">            test(1,nil);</span><br><span class=\"line\">           </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过sublime打开目标文件会发现代码远不止上面那寥寥几行，不难从其中可以找到如下与Block相关的代码。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">struct __block_impl &#123;</span><br><span class=\"line\"> \t\tvoid *isa;</span><br><span class=\"line\"> \t\tint Flags;</span><br><span class=\"line\"> \t\tint Reserved;</span><br><span class=\"line\"> \t\tvoid *FuncPtr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>struct __block_impl</code>就是block的真面目，结构还是相当清晰。<code>isa</code>对OC开发人员再熟悉不过，是表示其类型或者说本质的，block有三种类型<code>NSGlobalBlock</code>，<code>NSStackBlock</code>,<code>NSMallocBlock</code>，不同类型的block就是通过<code>isa</code>字段区分。然后就是<code>FuncPtr</code>，顾名思义就是指向某一函数的指针。其实block本质上与c语言中的函数指针是一样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  struct __block_impl impl;</span><br><span class=\"line\">  struct __main_block_desc_0* Desc;</span><br><span class=\"line\">  int base;</span><br><span class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _base, int flags=0) : base(_base) &#123;</span><br><span class=\"line\">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">    impl.Flags = flags;</span><br><span class=\"line\">    impl.FuncPtr = fp;</span><br><span class=\"line\">    Desc = desc;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself, BOOL success, NSError *error) &#123;</span><br><span class=\"line\">  int base = __cself-&gt;base; // bound by copy</span><br><span class=\"line\"></span><br><span class=\"line\">                NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_rl_k02s7ny56tj7m7cg3kdrfpbh0000gn_T_main_0c0cda_mi_0,success,base);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static struct __main_block_desc_0 &#123;</span><br><span class=\"line\">  size_t reserved;</span><br><span class=\"line\">  size_t Block_size;</span><br><span class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char * argv[]) &#123;</span><br><span class=\"line\">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class=\"line\">        int base =10;</span><br><span class=\"line\"></span><br><span class=\"line\">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class=\"line\">            int a =10;</span><br><span class=\"line\"></span><br><span class=\"line\">            void (* test) (BOOL success, NSError *error)= (void (*)(BOOL, NSError *))((id (*)(id, SEL))(void *)objc_msgSend)((id)((void (*)(BOOL, NSError *))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, base)), sel_registerName(&quot;copy&quot;));</span><br><span class=\"line\">            ((void (*)(__block_impl *, BOOL, NSError *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test, 1, __null);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上这一段代码正是与源码相对应的<code>struct __main_block_impl_0</code>是此处block的真正实现，主要分为两部分一个是block的定义一个是block的一些描述。<code>__main_block_func_0</code>是具体执行的函数体。接下来就是要<code>main</code>函数体中初始化block，然后就大功告成可以便可享用block。<br>以上揭示了block的本质。</p>\n<h1 id=\"二、关于Block类型\"><a href=\"#二、关于Block类型\" class=\"headerlink\" title=\"二、关于Block类型\"></a>二、关于Block类型</h1><h2 id=\"2-1-Block的类型\"><a href=\"#2-1-Block的类型\" class=\"headerlink\" title=\"2.1 Block的类型\"></a>2.1 Block的类型</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类</th>\n<th style=\"text-align:left\">对象存储域</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">_NSConreteStackBlock</td>\n<td style=\"text-align:left\">栈上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">_NSConreteGlobalBlock</td>\n<td style=\"text-align:left\">全局数据区（.data区）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">_NSConreteMallocBlock</td>\n<td style=\"text-align:left\">堆上</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>在ARC开启时，将只有 _NSConreteGlobalBlock与_NSConreteMallocBlock。因为ARC下编译器会自己管理对象，默认copy到堆上</p>\n</blockquote>\n<p>其实Block的类型与其自动截获变量有关。</p>\n<ul>\n<li><p>_NSConreteGlobalBlock类型<br>_NSConreteGlobalBlock类的Block，本质就与一个全局函数一样。不截获任何外部变量，只使用入参或者不使用任何参数，如：   </p>\n<pre><code>void (^ blk )(void)= ^{print(&quot;Global Block\\n&quot;)}\n</code></pre></li>\n<li><p>_NSConreteStackBlock类型<br>一般来说Block除了Global Block外，首先他必须先是一个_NSConreteStackBlock，也就是配置在栈上的。 因为，Block变量首先得是一个变量，而代码中除了主动申请内存外其它变量都在栈上。</p>\n</li>\n<li><p>_NSConreteMallocBlock类型    </p>\n<p>  <strong>那么关于_NSConreteMallocBlock类型何时才用到呢？由于_NSConreteStackBlock是配置于栈上，所以其生命周期也随其变量在栈上的生命周期。但实际开发中往往需要Block的生命周期更长。所以Block提供了复制，_NSConreteStackBlock可以复制到堆上也就是_NSConreteMallocBlock，在堆上的变量生命周期与栈无关，不会随着栈上变量变化。block 通常不会在源码中直接出现，因为默认它是当一个 block 被 copy 的时候，才会将这个 block 复制到堆中。</strong></p>\n</li>\n</ul>\n<h2 id=\"2-2-对Block进行copy的效果\"><a href=\"#2-2-对Block进行copy的效果\" class=\"headerlink\" title=\"2.2 对Block进行copy的效果\"></a>2.2 对Block进行copy的效果</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类</th>\n<th style=\"text-align:left\">源存储域</th>\n<th style=\"text-align:left\">复制效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">_NSConreteStackBlock</td>\n<td style=\"text-align:left\">栈上</td>\n<td style=\"text-align:left\">从栈复制到堆</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">_NSConreteGlobalBlock</td>\n<td style=\"text-align:left\">全局数据区（.data区）</td>\n<td style=\"text-align:left\">无效果</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">_NSConreteMallocBlock</td>\n<td style=\"text-align:left\">堆上</td>\n<td style=\"text-align:left\">引用计数增加</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>在ARC中一般不需要显示进行copy操作，编译器会自动判断。</p>\n</blockquote>\n<h1 id=\"三、-block变量\"><a href=\"#三、-block变量\" class=\"headerlink\" title=\"三、__block变量\"></a>三、__block变量</h1><p><strong>Block中可以进行修改的值包括三种：</strong>   </p>\n<ul>\n<li>全局变量   </li>\n<li>静态变量   </li>\n<li><code>__block</code>变量  </li>\n</ul>\n<p>前两种不用说，因为其存储在全局区域访问自然无可厚非，本节主要说一下<code>__block</code>变量。还是原来的demo，仅将其中的变量<code>base</code>声明为<code>__block</code></p>\n<pre><code>__block int base =10;\n</code></pre><p>经过重写后，结果又大不相同</p>\n<pre><code>\nstruct __Block_byref_base_0 {\n  void *__isa;\n__Block_byref_base_0 *__forwarding;\n int __flags;\n int __size;\n int base;\n};\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __Block_byref_base_0 *base; // by ref\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_base_0 *_base, int flags=0) : base(_base-&gt;__forwarding) {\n    impl.isa = &amp;_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself, BOOL success, NSError *error) {\n  __Block_byref_base_0 *base = __cself-&gt;base; // bound by ref\n\n                NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_rl_k02s7ny56tj7m7cg3kdrfpbh0000gn_T_main_5fdc20_mi_0,success,(base-&gt;__forwarding-&gt;base));\n            }\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;base, (void*)src-&gt;base, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;base, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n  void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};\nint main(int argc, char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; \n        __attribute__((__blocks__(byref))) __Block_byref_base_0 base = {(void*)0,(__Block_byref_base_0 *)&amp;base, 0, sizeof(__Block_byref_base_0), 10};\n        for(int i=0;i&lt;10;i++){\n            int a =10;\n\n            void (* test) (BOOL success, NSError *error)= ((void (*)(BOOL, NSError *))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_base_0 *)&amp;base, 570425344)) ;\n            ((void (*)(__block_impl *, BOOL, NSError *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test, 1, __null);\n\n        }\n\n\n    }\n}\n</code></pre><p>不难发现一个<code>__block</code>变量竟然是一个结构体。注意<code>main</code>函数中的<code>__block</code>变量的初始化已经演变成如下代码：     </p>\n<pre><code>__attribute__((__blocks__(byref))) __Block_byref_base_0 base = \n{(void*)0,\n(__Block_byref_base_0 *)&amp;base,\n 0, \nsizeof(__Block_byref_base_0), \n10\n};\n</code></pre><h3 id=\"block变量在Block内外都可以访问\"><a href=\"#block变量在Block内外都可以访问\" class=\"headerlink\" title=\"__block变量在Block内外都可以访问\"></a>__block变量在Block内外都可以访问</h3><p>注意结合该结构体声明分析。值得关注的是其<code>__forwarding</code>指针指向了自己本身。<br><strong><font color=\"red\"><strong>forwarding的存在是为了不管</strong>block变量是在堆上还是栈上都可以访问该变量，因为在复制<strong>block变量到堆上是会改变栈上</strong>block结构中的<strong>forwarding指向堆上的，而堆上的</strong>block变量指向自己本身，因此堆上与栈上都能可以该变量。</font></strong></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h3 id=\"1、-Block是一个OC对象\"><a href=\"#1、-Block是一个OC对象\" class=\"headerlink\" title=\"1、 Block是一个OC对象\"></a>1、 Block是一个OC对象</h3><h3 id=\"2、block变量可以有Block内外都可以访问，是由于-forwarding-的存在\"><a href=\"#2、block变量可以有Block内外都可以访问，是由于-forwarding-的存在\" class=\"headerlink\" title=\"2、block变量可以有Block内外都可以访问，是由于`forwarding`的存在\"></a>2、<strong>block变量可以有Block内外都可以访问，是由于`</strong>forwarding`的存在</h3><h3 id=\"3、虽然本文是研究Block的内存表象，但对于Block的常见问题还是得提一下，注意Block循环引用问题\"><a href=\"#3、虽然本文是研究Block的内存表象，但对于Block的常见问题还是得提一下，注意Block循环引用问题\" class=\"headerlink\" title=\"3、虽然本文是研究Block的内存表象，但对于Block的常见问题还是得提一下，注意Block循环引用问题\"></a>3、虽然本文是研究Block的内存表象，但对于Block的常见问题还是得提一下，注意Block循环引用问题</h3>"},{"title":"C/C++ Dev","date":"2017-03-19T09:27:29.000Z","_content":"\n> C/C++ 相关知识储备\n\n<!-- More-->\n\n# 一、基础知识\n## 1、关于类的静态成员赋值问题\n静态成员在实现文件中直接初始化不能在头文件里进行就地初始化，如：\n**错误**\n\n\n\n\tClass A   \n\t{     \n\t   static n = 10;\n\t}      \n  \n\n\n\n**正确：**在实现文件中   \n\n\n\n\tint A：：n=10；//不需要static 关键字\n \n \n**原因**\n因为class的声明都通常在头文件中，如果允许这样做其实就相当于在头文件里定义了一个非const的变量。头文件因为会被包含到多个文件中去，而非const变量的链接属性是内部链接也就是不会在编译时在导出符号表中，因此在某个文件中对其修改不会影响到别的文件，而这不是我们想要的结果。另外，const变量的可以的，因为const变量是只读的而且链接属性是外部链接也就是在编译时会导出符号表，就不存在上述现象。**c/c++在编译时会生成三个符号表：未解决符号表（待填入的变量如extern），导出符号表（用于链接到别的模块的变量与函数），重定位符号表（用于在链接时组成可运行程序内的全局地址）**       \n\n## 2、关于内联函数在头文件里定义的原因\n因为编译时每一个单元之间是不通的也就是相互独立，如果将内联函数定义在.cpp文件中就那么就只能这一个cpp文件可以用到这个内联函数了，其它的单元会因为找不到这个定义而无法进行函数展开。（与.h /.cpp不一样的原因是内联函数其实是在编译时进行一个展开，而一般的函数并不进行展开）\n\n## 3、关于枚举变量\n\n\n\tenum weekly {sun,sat,frid};weekly test;\n\ttest = sun;/*test 只能赋予 {sun,sat,frid}中枚举出的值，或者进行强制类型转换的赋值如：test = (weekly)0，意为将枚举中的第0个元素赋予test*/\n\n\n## 4、关于float变量\n\n1，规范IEEE754有关于0的描述。  \n\n\n2，由于float是不确定的描述，所以一般不要对其进行比较！\n\n## 5、关于构造函数（派生类与父类的调用关系）  \n\n**原则就是父类的构造函数一定要调用不管是显示还是隐式**\n\n1、如果子类没有定义构造函数，则调用父类无参构造函数（默认构造函数）；\n\n2、如果子类定义了有参构造函数，创建子类对象时候，先执行父类无参构造函数，然后执行子类构造 函数；\n\n3、如果子类构造函数没有显示调用父类构造函数，则会调用父类默认无参构造函数；\n\n4、如果子类构造函数没有显示调用父类构造函数且父类提供了无参构造函数，则会调用父类的无参默认构造函数\n\n5、如果子类构造函数没有显示调用 父类构造函数且父类只定义了有参构造函数，则会出错  \n\n## 6、关于C/C++符号表问题\n1、C++支持重载C不支持重载的原因：C在编译时生成符号表时只根据<font color = red>**函数名**</font>生成，而C++生成的符号表是由<font color = red>**函数名+参数**</font>生成的   \n\n\n2、C++不能以返回值不同作为重载区分的原因：同上，由于C++生成的符号表是由<font color = red>**函数名+参数**</font>生成的，并不包含返回值    \n\n## 7、关于C++继承访问控制问题\n\n|  父类访问控制| public | protected | private |    \n| -- | -- | -- | --|    \n|public 继承| public |  protected | 不可用 |      \n|protected 继承| protected |  protected | 不可用 |     \n|private 继承|  private  |   private | 不可用 |      \n\n**protected**：不可以被用户访问，只可以被派生类访问  \n\n**private**：都不可以访问，除了自己外。    \n\n# 8、[重写，重载，覆盖的关系]( http://blog.csdn.net/ericbaner/article/details/3857268)   \n\n+ 重写= 覆盖，是子类重写（覆盖）父类的方法，也就是同名同参数的方法   \n\n+ 重载，是一个作用域内有两个或者多个同名的方法（参数不一样），重载不能根据返回值不同进行重载       \n\n## 9.静态变量也全局变量的区别\n+ 从内存分配来说：     \n  + 静态变量与全局变量都是在程序静态区域      \n+ 从链接属性来说：     \n  + 静态全局变量只能在本文件访问，全局变量能在多文件间访问     \n\n静态全局变量与全局变量的区别就在于链接属性\n\n## 二、关于编码问题\n\n1、**Ascii**：c语言中的ascii表，一个字节\n\n2、**unicode**：为了拓展表示更多的语言，例如中文就无法用ascii码表示，二个字节\n\n3、**utf-8**：用unicode可以解决编码的问题，但是全部采用二个字节一般情况下是比较浪费的，所以就出现了可变长的unicode编码方式。utf-8根据不同的字符编码成1-6个字节的可变长，常用 的英文字母就编码成一个字节与ascii码一至，中方字符则编码成三个字节。这样utf-8其实是包括了ascii的。\n\n## 三、关于`static`关键字问题\n\n1、**静态变量**属于静态存储方式，其存储空间为内存中的静态数据区（在静态存储区内分配存储单元）；\n\n2、**静态变量**可以在任何可以申请的地方申请，一旦申请成功后，它将不再接受其他的同样申请。 函数体内如果在定义静态变量的同时进行了初始化，则以后程序不再进行初始化操作（出现在函数内部的基本类型的的静态变量初始化语句只有在第一次调用才执行）。而对自动变量赋初值是在函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语句 例如：\n\n\n```   \n\n\tclass test\n\t\n\t{\n\t\n\tprivate :\n\t int a;\n\tpublic :\n\t    test( int _a): a (_a)\n\t\n\t    {\n\t\n\t        NSLog ( @\"test:%d\\n\" , a );\n\t\n\t\n\t    }\n\t\n\t};\n\t\n\tvoid testFunction( int a)\n\t\n\t{\n\t  static test te(a);\n\t    NSLog ( @\"\\n%p\\n\" ,&te);\n\t    static int bb= 10 ;\n\t    NSLog ( @\"\\nbb value:%d\\n\" ,bb);\n\t\n\t    bb ++;\n\t  NSLog ( @\"\\nbb value:%d\\n\" ,bb);\n\t\n\t}\n\t\n\tvoid TEST()\n\t\n\t{\n\t\n\t     testFunction ( 10 );\n\t\n\t    testFunction ( 11 );\n\t}\n\n```\n\nbb的结果：\n\n```\n\n\t10\n\t\n\t11\n\t\n\t11\n\t\n\t12\n\n```\n\n同理，test类的构造函数也只会调用一次 \n\n>  它将不再接受其他的同样申请       \n\n\n\n\n## 四、关于递归函数问题\n\n1、我们都知道递归层次过多会导致栈溢出，那么关于递归优化我们可以使用循环`while`来进行改写，其实我们也可以使用[尾递归]( https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8)的方式进行改写。   \n\n2、尾调用，先来看一段代码：\n\n```\n\n\tfunc ()\n\t\n\t{\n\t\n\t.....\n\t\n\treturn g()\n\t\n\t}\n\n```\n\n上述例子中，func调用了g函数，在这种情况下当g函数运行完时无须返回到func函数中去，因此，栈中就不需要保存func的信息。**CAUTION**: `return g()`不能有多余的操作。尾递归其实就是一种尾调用。*但是现在一些编译器没有真的实现尾递归*。    \n\n## 五、继承与组合   \n\n+ 目中减少使用继承，另外也不宜使用深继承。因为继承使用对象之间形成强耦合关系。   \n\n## 六、命令式编程，函数式编程及响应式编程\n\n+ 在命令式编程环境中, a= b+c  表示将表达式b+c的结果赋给a ，而之后b改变 或 c 的值不会影响a 。但在响应式编程中，a 的值会随着 b 或 c 的更新而更新。   \n\n+ 一般的编程语言是命令式编程（指令式编程），响应式可以联想到KVO,Notification   \n+ 函数式编程是以函数为主[参考](http://coolshell.cn/articles/10822.html)\n\n## 七、void *test = &test 理解：“=”是左结合性运算符，所以就可以理解了，然后就是void *是可以指向任何指针，so done\n\n\n\n\n","source":"_posts/C-C-Dev.md","raw":"---\ntitle: C/C++ Dev\ndate: 2017-03-19 17:27:29\ncategories: C/C++\ntags: [C/C++,Dev]\n---\n\n> C/C++ 相关知识储备\n\n<!-- More-->\n\n# 一、基础知识\n## 1、关于类的静态成员赋值问题\n静态成员在实现文件中直接初始化不能在头文件里进行就地初始化，如：\n**错误**\n\n\n\n\tClass A   \n\t{     \n\t   static n = 10;\n\t}      \n  \n\n\n\n**正确：**在实现文件中   \n\n\n\n\tint A：：n=10；//不需要static 关键字\n \n \n**原因**\n因为class的声明都通常在头文件中，如果允许这样做其实就相当于在头文件里定义了一个非const的变量。头文件因为会被包含到多个文件中去，而非const变量的链接属性是内部链接也就是不会在编译时在导出符号表中，因此在某个文件中对其修改不会影响到别的文件，而这不是我们想要的结果。另外，const变量的可以的，因为const变量是只读的而且链接属性是外部链接也就是在编译时会导出符号表，就不存在上述现象。**c/c++在编译时会生成三个符号表：未解决符号表（待填入的变量如extern），导出符号表（用于链接到别的模块的变量与函数），重定位符号表（用于在链接时组成可运行程序内的全局地址）**       \n\n## 2、关于内联函数在头文件里定义的原因\n因为编译时每一个单元之间是不通的也就是相互独立，如果将内联函数定义在.cpp文件中就那么就只能这一个cpp文件可以用到这个内联函数了，其它的单元会因为找不到这个定义而无法进行函数展开。（与.h /.cpp不一样的原因是内联函数其实是在编译时进行一个展开，而一般的函数并不进行展开）\n\n## 3、关于枚举变量\n\n\n\tenum weekly {sun,sat,frid};weekly test;\n\ttest = sun;/*test 只能赋予 {sun,sat,frid}中枚举出的值，或者进行强制类型转换的赋值如：test = (weekly)0，意为将枚举中的第0个元素赋予test*/\n\n\n## 4、关于float变量\n\n1，规范IEEE754有关于0的描述。  \n\n\n2，由于float是不确定的描述，所以一般不要对其进行比较！\n\n## 5、关于构造函数（派生类与父类的调用关系）  \n\n**原则就是父类的构造函数一定要调用不管是显示还是隐式**\n\n1、如果子类没有定义构造函数，则调用父类无参构造函数（默认构造函数）；\n\n2、如果子类定义了有参构造函数，创建子类对象时候，先执行父类无参构造函数，然后执行子类构造 函数；\n\n3、如果子类构造函数没有显示调用父类构造函数，则会调用父类默认无参构造函数；\n\n4、如果子类构造函数没有显示调用父类构造函数且父类提供了无参构造函数，则会调用父类的无参默认构造函数\n\n5、如果子类构造函数没有显示调用 父类构造函数且父类只定义了有参构造函数，则会出错  \n\n## 6、关于C/C++符号表问题\n1、C++支持重载C不支持重载的原因：C在编译时生成符号表时只根据<font color = red>**函数名**</font>生成，而C++生成的符号表是由<font color = red>**函数名+参数**</font>生成的   \n\n\n2、C++不能以返回值不同作为重载区分的原因：同上，由于C++生成的符号表是由<font color = red>**函数名+参数**</font>生成的，并不包含返回值    \n\n## 7、关于C++继承访问控制问题\n\n|  父类访问控制| public | protected | private |    \n| -- | -- | -- | --|    \n|public 继承| public |  protected | 不可用 |      \n|protected 继承| protected |  protected | 不可用 |     \n|private 继承|  private  |   private | 不可用 |      \n\n**protected**：不可以被用户访问，只可以被派生类访问  \n\n**private**：都不可以访问，除了自己外。    \n\n# 8、[重写，重载，覆盖的关系]( http://blog.csdn.net/ericbaner/article/details/3857268)   \n\n+ 重写= 覆盖，是子类重写（覆盖）父类的方法，也就是同名同参数的方法   \n\n+ 重载，是一个作用域内有两个或者多个同名的方法（参数不一样），重载不能根据返回值不同进行重载       \n\n## 9.静态变量也全局变量的区别\n+ 从内存分配来说：     \n  + 静态变量与全局变量都是在程序静态区域      \n+ 从链接属性来说：     \n  + 静态全局变量只能在本文件访问，全局变量能在多文件间访问     \n\n静态全局变量与全局变量的区别就在于链接属性\n\n## 二、关于编码问题\n\n1、**Ascii**：c语言中的ascii表，一个字节\n\n2、**unicode**：为了拓展表示更多的语言，例如中文就无法用ascii码表示，二个字节\n\n3、**utf-8**：用unicode可以解决编码的问题，但是全部采用二个字节一般情况下是比较浪费的，所以就出现了可变长的unicode编码方式。utf-8根据不同的字符编码成1-6个字节的可变长，常用 的英文字母就编码成一个字节与ascii码一至，中方字符则编码成三个字节。这样utf-8其实是包括了ascii的。\n\n## 三、关于`static`关键字问题\n\n1、**静态变量**属于静态存储方式，其存储空间为内存中的静态数据区（在静态存储区内分配存储单元）；\n\n2、**静态变量**可以在任何可以申请的地方申请，一旦申请成功后，它将不再接受其他的同样申请。 函数体内如果在定义静态变量的同时进行了初始化，则以后程序不再进行初始化操作（出现在函数内部的基本类型的的静态变量初始化语句只有在第一次调用才执行）。而对自动变量赋初值是在函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语句 例如：\n\n\n```   \n\n\tclass test\n\t\n\t{\n\t\n\tprivate :\n\t int a;\n\tpublic :\n\t    test( int _a): a (_a)\n\t\n\t    {\n\t\n\t        NSLog ( @\"test:%d\\n\" , a );\n\t\n\t\n\t    }\n\t\n\t};\n\t\n\tvoid testFunction( int a)\n\t\n\t{\n\t  static test te(a);\n\t    NSLog ( @\"\\n%p\\n\" ,&te);\n\t    static int bb= 10 ;\n\t    NSLog ( @\"\\nbb value:%d\\n\" ,bb);\n\t\n\t    bb ++;\n\t  NSLog ( @\"\\nbb value:%d\\n\" ,bb);\n\t\n\t}\n\t\n\tvoid TEST()\n\t\n\t{\n\t\n\t     testFunction ( 10 );\n\t\n\t    testFunction ( 11 );\n\t}\n\n```\n\nbb的结果：\n\n```\n\n\t10\n\t\n\t11\n\t\n\t11\n\t\n\t12\n\n```\n\n同理，test类的构造函数也只会调用一次 \n\n>  它将不再接受其他的同样申请       \n\n\n\n\n## 四、关于递归函数问题\n\n1、我们都知道递归层次过多会导致栈溢出，那么关于递归优化我们可以使用循环`while`来进行改写，其实我们也可以使用[尾递归]( https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8)的方式进行改写。   \n\n2、尾调用，先来看一段代码：\n\n```\n\n\tfunc ()\n\t\n\t{\n\t\n\t.....\n\t\n\treturn g()\n\t\n\t}\n\n```\n\n上述例子中，func调用了g函数，在这种情况下当g函数运行完时无须返回到func函数中去，因此，栈中就不需要保存func的信息。**CAUTION**: `return g()`不能有多余的操作。尾递归其实就是一种尾调用。*但是现在一些编译器没有真的实现尾递归*。    \n\n## 五、继承与组合   \n\n+ 目中减少使用继承，另外也不宜使用深继承。因为继承使用对象之间形成强耦合关系。   \n\n## 六、命令式编程，函数式编程及响应式编程\n\n+ 在命令式编程环境中, a= b+c  表示将表达式b+c的结果赋给a ，而之后b改变 或 c 的值不会影响a 。但在响应式编程中，a 的值会随着 b 或 c 的更新而更新。   \n\n+ 一般的编程语言是命令式编程（指令式编程），响应式可以联想到KVO,Notification   \n+ 函数式编程是以函数为主[参考](http://coolshell.cn/articles/10822.html)\n\n## 七、void *test = &test 理解：“=”是左结合性运算符，所以就可以理解了，然后就是void *是可以指向任何指针，so done\n\n\n\n\n","slug":"C-C-Dev","published":1,"updated":"2022-06-15T07:23:15.001Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4fa2s9q0004daco914aug2h","content":"<blockquote>\n<p>C/C++ 相关知识储备</p>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h1><h2 id=\"1、关于类的静态成员赋值问题\"><a href=\"#1、关于类的静态成员赋值问题\" class=\"headerlink\" title=\"1、关于类的静态成员赋值问题\"></a>1、关于类的静态成员赋值问题</h2><p>静态成员在实现文件中直接初始化不能在头文件里进行就地初始化，如：<br><strong>错误</strong></p>\n<pre><code>Class A   \n{     \n   static n = 10;\n}      \n</code></pre><p><strong>正确：</strong>在实现文件中   </p>\n<pre><code>int A：：n=10；//不需要static 关键字\n</code></pre><p><strong>原因</strong><br>因为class的声明都通常在头文件中，如果允许这样做其实就相当于在头文件里定义了一个非const的变量。头文件因为会被包含到多个文件中去，而非const变量的链接属性是内部链接也就是不会在编译时在导出符号表中，因此在某个文件中对其修改不会影响到别的文件，而这不是我们想要的结果。另外，const变量的可以的，因为const变量是只读的而且链接属性是外部链接也就是在编译时会导出符号表，就不存在上述现象。<strong>c/c++在编译时会生成三个符号表：未解决符号表（待填入的变量如extern），导出符号表（用于链接到别的模块的变量与函数），重定位符号表（用于在链接时组成可运行程序内的全局地址）</strong>       </p>\n<h2 id=\"2、关于内联函数在头文件里定义的原因\"><a href=\"#2、关于内联函数在头文件里定义的原因\" class=\"headerlink\" title=\"2、关于内联函数在头文件里定义的原因\"></a>2、关于内联函数在头文件里定义的原因</h2><p>因为编译时每一个单元之间是不通的也就是相互独立，如果将内联函数定义在.cpp文件中就那么就只能这一个cpp文件可以用到这个内联函数了，其它的单元会因为找不到这个定义而无法进行函数展开。（与.h /.cpp不一样的原因是内联函数其实是在编译时进行一个展开，而一般的函数并不进行展开）</p>\n<h2 id=\"3、关于枚举变量\"><a href=\"#3、关于枚举变量\" class=\"headerlink\" title=\"3、关于枚举变量\"></a>3、关于枚举变量</h2><pre><code>enum weekly {sun,sat,frid};weekly test;\ntest = sun;/*test 只能赋予 {sun,sat,frid}中枚举出的值，或者进行强制类型转换的赋值如：test = (weekly)0，意为将枚举中的第0个元素赋予test*/\n</code></pre><h2 id=\"4、关于float变量\"><a href=\"#4、关于float变量\" class=\"headerlink\" title=\"4、关于float变量\"></a>4、关于float变量</h2><p>1，规范IEEE754有关于0的描述。  </p>\n<p>2，由于float是不确定的描述，所以一般不要对其进行比较！</p>\n<h2 id=\"5、关于构造函数（派生类与父类的调用关系）\"><a href=\"#5、关于构造函数（派生类与父类的调用关系）\" class=\"headerlink\" title=\"5、关于构造函数（派生类与父类的调用关系）\"></a>5、关于构造函数（派生类与父类的调用关系）</h2><p><strong>原则就是父类的构造函数一定要调用不管是显示还是隐式</strong></p>\n<p>1、如果子类没有定义构造函数，则调用父类无参构造函数（默认构造函数）；</p>\n<p>2、如果子类定义了有参构造函数，创建子类对象时候，先执行父类无参构造函数，然后执行子类构造 函数；</p>\n<p>3、如果子类构造函数没有显示调用父类构造函数，则会调用父类默认无参构造函数；</p>\n<p>4、如果子类构造函数没有显示调用父类构造函数且父类提供了无参构造函数，则会调用父类的无参默认构造函数</p>\n<p>5、如果子类构造函数没有显示调用 父类构造函数且父类只定义了有参构造函数，则会出错  </p>\n<h2 id=\"6、关于C-C-符号表问题\"><a href=\"#6、关于C-C-符号表问题\" class=\"headerlink\" title=\"6、关于C/C++符号表问题\"></a>6、关于C/C++符号表问题</h2><p>1、C++支持重载C不支持重载的原因：C在编译时生成符号表时只根据<font color=\"red\"><strong>函数名</strong></font>生成，而C++生成的符号表是由<font color=\"red\"><strong>函数名+参数</strong></font>生成的   </p>\n<p>2、C++不能以返回值不同作为重载区分的原因：同上，由于C++生成的符号表是由<font color=\"red\"><strong>函数名+参数</strong></font>生成的，并不包含返回值    </p>\n<h2 id=\"7、关于C-继承访问控制问题\"><a href=\"#7、关于C-继承访问控制问题\" class=\"headerlink\" title=\"7、关于C++继承访问控制问题\"></a>7、关于C++继承访问控制问题</h2><table>\n<thead>\n<tr>\n<th>父类访问控制</th>\n<th>public</th>\n<th>protected</th>\n<th>private</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public 继承</td>\n<td>public</td>\n<td>protected</td>\n<td>不可用</td>\n</tr>\n<tr>\n<td>protected 继承</td>\n<td>protected</td>\n<td>protected</td>\n<td>不可用</td>\n</tr>\n<tr>\n<td>private 继承</td>\n<td>private</td>\n<td>private</td>\n<td>不可用</td>\n</tr>\n</tbody>\n</table>\n<p><strong>protected</strong>：不可以被用户访问，只可以被派生类访问  </p>\n<p><strong>private</strong>：都不可以访问，除了自己外。    </p>\n<h1 id=\"8、重写，重载，覆盖的关系\"><a href=\"#8、重写，重载，覆盖的关系\" class=\"headerlink\" title=\"8、重写，重载，覆盖的关系\"></a>8、<a href=\"http://blog.csdn.net/ericbaner/article/details/3857268\" target=\"_blank\" rel=\"noopener\">重写，重载，覆盖的关系</a></h1><ul>\n<li><p>重写= 覆盖，是子类重写（覆盖）父类的方法，也就是同名同参数的方法   </p>\n</li>\n<li><p>重载，是一个作用域内有两个或者多个同名的方法（参数不一样），重载不能根据返回值不同进行重载       </p>\n</li>\n</ul>\n<h2 id=\"9-静态变量也全局变量的区别\"><a href=\"#9-静态变量也全局变量的区别\" class=\"headerlink\" title=\"9.静态变量也全局变量的区别\"></a>9.静态变量也全局变量的区别</h2><ul>\n<li>从内存分配来说：     <ul>\n<li>静态变量与全局变量都是在程序静态区域      </li>\n</ul>\n</li>\n<li>从链接属性来说：     <ul>\n<li>静态全局变量只能在本文件访问，全局变量能在多文件间访问     </li>\n</ul>\n</li>\n</ul>\n<p>静态全局变量与全局变量的区别就在于链接属性</p>\n<h2 id=\"二、关于编码问题\"><a href=\"#二、关于编码问题\" class=\"headerlink\" title=\"二、关于编码问题\"></a>二、关于编码问题</h2><p>1、<strong>Ascii</strong>：c语言中的ascii表，一个字节</p>\n<p>2、<strong>unicode</strong>：为了拓展表示更多的语言，例如中文就无法用ascii码表示，二个字节</p>\n<p>3、<strong>utf-8</strong>：用unicode可以解决编码的问题，但是全部采用二个字节一般情况下是比较浪费的，所以就出现了可变长的unicode编码方式。utf-8根据不同的字符编码成1-6个字节的可变长，常用 的英文字母就编码成一个字节与ascii码一至，中方字符则编码成三个字节。这样utf-8其实是包括了ascii的。</p>\n<h2 id=\"三、关于static关键字问题\"><a href=\"#三、关于static关键字问题\" class=\"headerlink\" title=\"三、关于static关键字问题\"></a>三、关于<code>static</code>关键字问题</h2><p>1、<strong>静态变量</strong>属于静态存储方式，其存储空间为内存中的静态数据区（在静态存储区内分配存储单元）；</p>\n<p>2、<strong>静态变量</strong>可以在任何可以申请的地方申请，一旦申请成功后，它将不再接受其他的同样申请。 函数体内如果在定义静态变量的同时进行了初始化，则以后程序不再进行初始化操作（出现在函数内部的基本类型的的静态变量初始化语句只有在第一次调用才执行）。而对自动变量赋初值是在函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语句 例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">class test</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">private :</span><br><span class=\"line\"> int a;</span><br><span class=\"line\">public :</span><br><span class=\"line\">    test( int _a): a (_a)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        NSLog ( @&quot;test:%d\\n&quot; , a );</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void testFunction( int a)</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  static test te(a);</span><br><span class=\"line\">    NSLog ( @&quot;\\n%p\\n&quot; ,&amp;te);</span><br><span class=\"line\">    static int bb= 10 ;</span><br><span class=\"line\">    NSLog ( @&quot;\\nbb value:%d\\n&quot; ,bb);</span><br><span class=\"line\"></span><br><span class=\"line\">    bb ++;</span><br><span class=\"line\">  NSLog ( @&quot;\\nbb value:%d\\n&quot; ,bb);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void TEST()</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     testFunction ( 10 );</span><br><span class=\"line\"></span><br><span class=\"line\">    testFunction ( 11 );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>bb的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">10</span><br><span class=\"line\"></span><br><span class=\"line\">11</span><br><span class=\"line\"></span><br><span class=\"line\">11</span><br><span class=\"line\"></span><br><span class=\"line\">12</span><br></pre></td></tr></table></figure>\n<p>同理，test类的构造函数也只会调用一次 </p>\n<blockquote>\n<p> 它将不再接受其他的同样申请       </p>\n</blockquote>\n<h2 id=\"四、关于递归函数问题\"><a href=\"#四、关于递归函数问题\" class=\"headerlink\" title=\"四、关于递归函数问题\"></a>四、关于递归函数问题</h2><p>1、我们都知道递归层次过多会导致栈溢出，那么关于递归优化我们可以使用循环<code>while</code>来进行改写，其实我们也可以使用<a href=\"https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8\" target=\"_blank\" rel=\"noopener\">尾递归</a>的方式进行改写。   </p>\n<p>2、尾调用，先来看一段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">func ()</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">.....</span><br><span class=\"line\"></span><br><span class=\"line\">return g()</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述例子中，func调用了g函数，在这种情况下当g函数运行完时无须返回到func函数中去，因此，栈中就不需要保存func的信息。<strong>CAUTION</strong>: <code>return g()</code>不能有多余的操作。尾递归其实就是一种尾调用。<em>但是现在一些编译器没有真的实现尾递归</em>。    </p>\n<h2 id=\"五、继承与组合\"><a href=\"#五、继承与组合\" class=\"headerlink\" title=\"五、继承与组合\"></a>五、继承与组合</h2><ul>\n<li>目中减少使用继承，另外也不宜使用深继承。因为继承使用对象之间形成强耦合关系。   </li>\n</ul>\n<h2 id=\"六、命令式编程，函数式编程及响应式编程\"><a href=\"#六、命令式编程，函数式编程及响应式编程\" class=\"headerlink\" title=\"六、命令式编程，函数式编程及响应式编程\"></a>六、命令式编程，函数式编程及响应式编程</h2><ul>\n<li><p>在命令式编程环境中, a= b+c  表示将表达式b+c的结果赋给a ，而之后b改变 或 c 的值不会影响a 。但在响应式编程中，a 的值会随着 b 或 c 的更新而更新。   </p>\n</li>\n<li><p>一般的编程语言是命令式编程（指令式编程），响应式可以联想到KVO,Notification   </p>\n</li>\n<li>函数式编程是以函数为主<a href=\"http://coolshell.cn/articles/10822.html\" target=\"_blank\" rel=\"noopener\">参考</a></li>\n</ul>\n<h2 id=\"七、void-test-amp-test-理解：“-”是左结合性运算符，所以就可以理解了，然后就是void-是可以指向任何指针，so-done\"><a href=\"#七、void-test-amp-test-理解：“-”是左结合性运算符，所以就可以理解了，然后就是void-是可以指向任何指针，so-done\" class=\"headerlink\" title=\"七、void test = &amp;test 理解：“=”是左结合性运算符，所以就可以理解了，然后就是void 是可以指向任何指针，so done\"></a>七、void <em>test = &amp;test 理解：“=”是左结合性运算符，所以就可以理解了，然后就是void </em>是可以指向任何指针，so done</h2>","site":{"data":{}},"excerpt":"<blockquote>\n<p>C/C++ 相关知识储备</p>\n</blockquote>","more":"<h1 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h1><h2 id=\"1、关于类的静态成员赋值问题\"><a href=\"#1、关于类的静态成员赋值问题\" class=\"headerlink\" title=\"1、关于类的静态成员赋值问题\"></a>1、关于类的静态成员赋值问题</h2><p>静态成员在实现文件中直接初始化不能在头文件里进行就地初始化，如：<br><strong>错误</strong></p>\n<pre><code>Class A   \n{     \n   static n = 10;\n}      \n</code></pre><p><strong>正确：</strong>在实现文件中   </p>\n<pre><code>int A：：n=10；//不需要static 关键字\n</code></pre><p><strong>原因</strong><br>因为class的声明都通常在头文件中，如果允许这样做其实就相当于在头文件里定义了一个非const的变量。头文件因为会被包含到多个文件中去，而非const变量的链接属性是内部链接也就是不会在编译时在导出符号表中，因此在某个文件中对其修改不会影响到别的文件，而这不是我们想要的结果。另外，const变量的可以的，因为const变量是只读的而且链接属性是外部链接也就是在编译时会导出符号表，就不存在上述现象。<strong>c/c++在编译时会生成三个符号表：未解决符号表（待填入的变量如extern），导出符号表（用于链接到别的模块的变量与函数），重定位符号表（用于在链接时组成可运行程序内的全局地址）</strong>       </p>\n<h2 id=\"2、关于内联函数在头文件里定义的原因\"><a href=\"#2、关于内联函数在头文件里定义的原因\" class=\"headerlink\" title=\"2、关于内联函数在头文件里定义的原因\"></a>2、关于内联函数在头文件里定义的原因</h2><p>因为编译时每一个单元之间是不通的也就是相互独立，如果将内联函数定义在.cpp文件中就那么就只能这一个cpp文件可以用到这个内联函数了，其它的单元会因为找不到这个定义而无法进行函数展开。（与.h /.cpp不一样的原因是内联函数其实是在编译时进行一个展开，而一般的函数并不进行展开）</p>\n<h2 id=\"3、关于枚举变量\"><a href=\"#3、关于枚举变量\" class=\"headerlink\" title=\"3、关于枚举变量\"></a>3、关于枚举变量</h2><pre><code>enum weekly {sun,sat,frid};weekly test;\ntest = sun;/*test 只能赋予 {sun,sat,frid}中枚举出的值，或者进行强制类型转换的赋值如：test = (weekly)0，意为将枚举中的第0个元素赋予test*/\n</code></pre><h2 id=\"4、关于float变量\"><a href=\"#4、关于float变量\" class=\"headerlink\" title=\"4、关于float变量\"></a>4、关于float变量</h2><p>1，规范IEEE754有关于0的描述。  </p>\n<p>2，由于float是不确定的描述，所以一般不要对其进行比较！</p>\n<h2 id=\"5、关于构造函数（派生类与父类的调用关系）\"><a href=\"#5、关于构造函数（派生类与父类的调用关系）\" class=\"headerlink\" title=\"5、关于构造函数（派生类与父类的调用关系）\"></a>5、关于构造函数（派生类与父类的调用关系）</h2><p><strong>原则就是父类的构造函数一定要调用不管是显示还是隐式</strong></p>\n<p>1、如果子类没有定义构造函数，则调用父类无参构造函数（默认构造函数）；</p>\n<p>2、如果子类定义了有参构造函数，创建子类对象时候，先执行父类无参构造函数，然后执行子类构造 函数；</p>\n<p>3、如果子类构造函数没有显示调用父类构造函数，则会调用父类默认无参构造函数；</p>\n<p>4、如果子类构造函数没有显示调用父类构造函数且父类提供了无参构造函数，则会调用父类的无参默认构造函数</p>\n<p>5、如果子类构造函数没有显示调用 父类构造函数且父类只定义了有参构造函数，则会出错  </p>\n<h2 id=\"6、关于C-C-符号表问题\"><a href=\"#6、关于C-C-符号表问题\" class=\"headerlink\" title=\"6、关于C/C++符号表问题\"></a>6、关于C/C++符号表问题</h2><p>1、C++支持重载C不支持重载的原因：C在编译时生成符号表时只根据<font color=\"red\"><strong>函数名</strong></font>生成，而C++生成的符号表是由<font color=\"red\"><strong>函数名+参数</strong></font>生成的   </p>\n<p>2、C++不能以返回值不同作为重载区分的原因：同上，由于C++生成的符号表是由<font color=\"red\"><strong>函数名+参数</strong></font>生成的，并不包含返回值    </p>\n<h2 id=\"7、关于C-继承访问控制问题\"><a href=\"#7、关于C-继承访问控制问题\" class=\"headerlink\" title=\"7、关于C++继承访问控制问题\"></a>7、关于C++继承访问控制问题</h2><table>\n<thead>\n<tr>\n<th>父类访问控制</th>\n<th>public</th>\n<th>protected</th>\n<th>private</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public 继承</td>\n<td>public</td>\n<td>protected</td>\n<td>不可用</td>\n</tr>\n<tr>\n<td>protected 继承</td>\n<td>protected</td>\n<td>protected</td>\n<td>不可用</td>\n</tr>\n<tr>\n<td>private 继承</td>\n<td>private</td>\n<td>private</td>\n<td>不可用</td>\n</tr>\n</tbody>\n</table>\n<p><strong>protected</strong>：不可以被用户访问，只可以被派生类访问  </p>\n<p><strong>private</strong>：都不可以访问，除了自己外。    </p>\n<h1 id=\"8、重写，重载，覆盖的关系\"><a href=\"#8、重写，重载，覆盖的关系\" class=\"headerlink\" title=\"8、重写，重载，覆盖的关系\"></a>8、<a href=\"http://blog.csdn.net/ericbaner/article/details/3857268\" target=\"_blank\" rel=\"noopener\">重写，重载，覆盖的关系</a></h1><ul>\n<li><p>重写= 覆盖，是子类重写（覆盖）父类的方法，也就是同名同参数的方法   </p>\n</li>\n<li><p>重载，是一个作用域内有两个或者多个同名的方法（参数不一样），重载不能根据返回值不同进行重载       </p>\n</li>\n</ul>\n<h2 id=\"9-静态变量也全局变量的区别\"><a href=\"#9-静态变量也全局变量的区别\" class=\"headerlink\" title=\"9.静态变量也全局变量的区别\"></a>9.静态变量也全局变量的区别</h2><ul>\n<li>从内存分配来说：     <ul>\n<li>静态变量与全局变量都是在程序静态区域      </li>\n</ul>\n</li>\n<li>从链接属性来说：     <ul>\n<li>静态全局变量只能在本文件访问，全局变量能在多文件间访问     </li>\n</ul>\n</li>\n</ul>\n<p>静态全局变量与全局变量的区别就在于链接属性</p>\n<h2 id=\"二、关于编码问题\"><a href=\"#二、关于编码问题\" class=\"headerlink\" title=\"二、关于编码问题\"></a>二、关于编码问题</h2><p>1、<strong>Ascii</strong>：c语言中的ascii表，一个字节</p>\n<p>2、<strong>unicode</strong>：为了拓展表示更多的语言，例如中文就无法用ascii码表示，二个字节</p>\n<p>3、<strong>utf-8</strong>：用unicode可以解决编码的问题，但是全部采用二个字节一般情况下是比较浪费的，所以就出现了可变长的unicode编码方式。utf-8根据不同的字符编码成1-6个字节的可变长，常用 的英文字母就编码成一个字节与ascii码一至，中方字符则编码成三个字节。这样utf-8其实是包括了ascii的。</p>\n<h2 id=\"三、关于static关键字问题\"><a href=\"#三、关于static关键字问题\" class=\"headerlink\" title=\"三、关于static关键字问题\"></a>三、关于<code>static</code>关键字问题</h2><p>1、<strong>静态变量</strong>属于静态存储方式，其存储空间为内存中的静态数据区（在静态存储区内分配存储单元）；</p>\n<p>2、<strong>静态变量</strong>可以在任何可以申请的地方申请，一旦申请成功后，它将不再接受其他的同样申请。 函数体内如果在定义静态变量的同时进行了初始化，则以后程序不再进行初始化操作（出现在函数内部的基本类型的的静态变量初始化语句只有在第一次调用才执行）。而对自动变量赋初值是在函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语句 例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">class test</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">private :</span><br><span class=\"line\"> int a;</span><br><span class=\"line\">public :</span><br><span class=\"line\">    test( int _a): a (_a)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        NSLog ( @&quot;test:%d\\n&quot; , a );</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void testFunction( int a)</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  static test te(a);</span><br><span class=\"line\">    NSLog ( @&quot;\\n%p\\n&quot; ,&amp;te);</span><br><span class=\"line\">    static int bb= 10 ;</span><br><span class=\"line\">    NSLog ( @&quot;\\nbb value:%d\\n&quot; ,bb);</span><br><span class=\"line\"></span><br><span class=\"line\">    bb ++;</span><br><span class=\"line\">  NSLog ( @&quot;\\nbb value:%d\\n&quot; ,bb);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void TEST()</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     testFunction ( 10 );</span><br><span class=\"line\"></span><br><span class=\"line\">    testFunction ( 11 );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>bb的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">10</span><br><span class=\"line\"></span><br><span class=\"line\">11</span><br><span class=\"line\"></span><br><span class=\"line\">11</span><br><span class=\"line\"></span><br><span class=\"line\">12</span><br></pre></td></tr></table></figure>\n<p>同理，test类的构造函数也只会调用一次 </p>\n<blockquote>\n<p> 它将不再接受其他的同样申请       </p>\n</blockquote>\n<h2 id=\"四、关于递归函数问题\"><a href=\"#四、关于递归函数问题\" class=\"headerlink\" title=\"四、关于递归函数问题\"></a>四、关于递归函数问题</h2><p>1、我们都知道递归层次过多会导致栈溢出，那么关于递归优化我们可以使用循环<code>while</code>来进行改写，其实我们也可以使用<a href=\"https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8\" target=\"_blank\" rel=\"noopener\">尾递归</a>的方式进行改写。   </p>\n<p>2、尾调用，先来看一段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">func ()</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">.....</span><br><span class=\"line\"></span><br><span class=\"line\">return g()</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述例子中，func调用了g函数，在这种情况下当g函数运行完时无须返回到func函数中去，因此，栈中就不需要保存func的信息。<strong>CAUTION</strong>: <code>return g()</code>不能有多余的操作。尾递归其实就是一种尾调用。<em>但是现在一些编译器没有真的实现尾递归</em>。    </p>\n<h2 id=\"五、继承与组合\"><a href=\"#五、继承与组合\" class=\"headerlink\" title=\"五、继承与组合\"></a>五、继承与组合</h2><ul>\n<li>目中减少使用继承，另外也不宜使用深继承。因为继承使用对象之间形成强耦合关系。   </li>\n</ul>\n<h2 id=\"六、命令式编程，函数式编程及响应式编程\"><a href=\"#六、命令式编程，函数式编程及响应式编程\" class=\"headerlink\" title=\"六、命令式编程，函数式编程及响应式编程\"></a>六、命令式编程，函数式编程及响应式编程</h2><ul>\n<li><p>在命令式编程环境中, a= b+c  表示将表达式b+c的结果赋给a ，而之后b改变 或 c 的值不会影响a 。但在响应式编程中，a 的值会随着 b 或 c 的更新而更新。   </p>\n</li>\n<li><p>一般的编程语言是命令式编程（指令式编程），响应式可以联想到KVO,Notification   </p>\n</li>\n<li>函数式编程是以函数为主<a href=\"http://coolshell.cn/articles/10822.html\" target=\"_blank\" rel=\"noopener\">参考</a></li>\n</ul>\n<h2 id=\"七、void-test-amp-test-理解：“-”是左结合性运算符，所以就可以理解了，然后就是void-是可以指向任何指针，so-done\"><a href=\"#七、void-test-amp-test-理解：“-”是左结合性运算符，所以就可以理解了，然后就是void-是可以指向任何指针，so-done\" class=\"headerlink\" title=\"七、void test = &amp;test 理解：“=”是左结合性运算符，所以就可以理解了，然后就是void 是可以指向任何指针，so done\"></a>七、void <em>test = &amp;test 理解：“=”是左结合性运算符，所以就可以理解了，然后就是void </em>是可以指向任何指针，so done</h2>"},{"title":"Lua学习笔记","date":"2017-07-10T09:06:34.000Z","_content":"\n> Lua 学习笔记\n\n<!--More-->\n\n# 一、基础知识\n## 1.1、 Lua源码学习\n### 1.1.1、C语言函数名与宏定义冲突问题\n所望的语言函数名与宏定义冲突问题，就是指宏定义与函数相同时编译器不知道标识符该怎么处理。如下代码：\n\n\t#pragma once\n\n\t#include <stdio.h>\n\t#define f() printf(\"this is define \");\n\tvoid f();\n\n上述代码在VS2010会检测出`Error:不允许使用不完整定义`。解决方案很简单，如下：\n\n\t#pragma once\n\n\t#include <stdio.h>\n\t#define f() printf(\"this is define \");\n\tvoid (f)();\n\n在函数名上添加小括号即可解决问题。这也就是为什么lua.h头文件里为什么那么函数名都带括号的原因:\n\n\t/*\n\t** access functions (stack -> C)\n\t*/\n\t\n\tLUA_API int             (lua_isnumber) (lua_State *L, int idx);\n\tLUA_API int             (lua_isstring) (lua_State *L, int idx);\n\tLUA_API int             (lua_iscfunction) (lua_State *L, int idx);\n\tLUA_API int             (lua_isinteger) (lua_State *L, int idx);\n\tLUA_API int             (lua_isuserdata) (lua_State *L, int idx);\n\tLUA_API int             (lua_type) (lua_State *L, int idx);\n\tLUA_API const char     *(lua_typename) (lua_State *L, int tp);\n\t\n\tLUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);\n\tLUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);\n\tLUA_API int             (lua_toboolean) (lua_State *L, int idx);\n\tLUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);\n\tLUA_API size_t          (lua_rawlen) (lua_State *L, int idx);\n\tLUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);\n\tLUA_API void\t       *(lua_touserdata) (lua_State *L, int idx);\n\tLUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);\n\tLUA_API const void     *(lua_topointer) (lua_State *L, int idx);\n\t....\n\n### 1.1.2、C语言大量使用宏定义\n\n+ 宏定义函数，减少函数调用开销\n+ 宏定义方便    \n\n### 1.1.3、VS编译lua源码  \n\n+ 参考： [https://www.kancloud.cn/digest/luanote/119932](https://www.kancloud.cn/digest/luanote/119932)     \n+ 注意要把你的测试project设置成启动项目，否则会出现错误：无法启动程序：xxxx.lib 指定文件格式无法识别或不支持二进制  \n\n## 2、Lua语法\n\n### 2.1、Lua函数调用方法`.`与`:`区别    \n\n+ `.`:是一般的调用     \n+ `:`:自带第一个参数`self`    \n+ `s.xxx(s,arg) == s:xxx(arg)`\n\n\n### 2.2、lua在查找一个表元素的时候，其步如下 \n\n1. 在表中查找，如果找到的话，则返回该元素，找不到则继续。    \n2. 判断该表是否有metatable表，如果没有metatable表，返回nil，有元表则继续。    \n3. **判断metatable是否有__index方法，如果__index方法为nil，则返回nil;如果__index方法是一个表，则重复1、2、3步骤;如果__index方法是一个函数，则返回该函数的返回值。**\n4. **__index中的function会增加一个默认入参，而且是第一个参数**    \n例如调用 foo.bar 时，如果在 foo 中没有找到名为 bar 的域时，则会调用 Metatable：__index(foo, bar)。于是：  \n\n\n### 2.3、__newindex元方法 \n__newindex元方法用来对表更新，而__index则用来对表进行访问。当你给表的一个缺少的索引赋值的时，解释器就会查找__newindex元方法；如果存在则调用这个函数而不进行赋值操作。     \n\n\n## 3、实战\n### C++ 类导入lua\n\n```\n/***********C++ Class to Lua*********************/\nclass Account {\npublic: \n\tAccount(double balance){ m_balance = balance;}\n\tvoid deposit(double amount){m_balance += amount;}\n\tvoid withdraw(double amount){m_balance -= amount;}\n\tdouble balance(){return m_balance;}\nprivate:\n\tdouble m_balance;\n};\n\n//class WrapperAccount {\n\n\nAccount* checkaccount(lua_State *L, int narg)\n{\n\tluaL_checktype(L,narg, LUA_TUSERDATA);\n\tvoid *ud = luaL_checkudata(L,narg,\"Account\");\n\tluaL_argcheck(L,ud!= NULL,1,\"user data error\");\n\treturn *(Account**)ud;\n}\n\nint create_account(lua_State *L)\n{\n\t\n\tdouble balance = luaL_checknumber(L,1);\n\tAccount **a = (Account**)lua_newuserdata(L,sizeof(Account));\n\t*a = new Account(balance);\n\tprintf(\"construct! balance is: %lf\\n\",balance);\n\tluaL_getmetatable(L,\"Account\");\n\tlua_setmetatable(L,-2);\n\treturn 1;\n}\nint deposit(lua_State *L)\n{\n\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);\n\tdouble amount = luaL_checknumber(L,-1);\n\t(a)->deposit(amount);\n\treturn 0;\n}\nint withdraw(lua_State *L)\n{\n\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);\n\tdouble amount = luaL_checknumber(L,-1);\n\t(a)->withdraw(amount);\n\treturn 0;\n}\nint balance(lua_State *L)\n{\n\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);\n\tdouble balance = (a)->balance();\n\tprintf(\"balance is: %lf\\n\",balance);\n\tlua_pushnumber(L,balance);\n\treturn 0;\n}\n//public:\n\nconst char className[10] = \"Account\";\nstatic const luaL_Reg methods[]= {\n\t//{\"Account\",create_account},\n\t{\"deposit\",deposit},\n\t{\"withdraw\",withdraw},\n\t{\"balance\",balance},\n\t{NULL,NULL}\n};\n\nint luaopen_Account(lua_State *L)\n{\n\tluaL_newmetatable(L,\"Account\");\n\tlua_pushvalue(L,-1);\n\tlua_setfield(L,-2,\"__index\");//AAccount.__index = AAccount\n\tluaL_setfuncs(L,methods,0);//register the methods to the table that is on the top\n\t//luaL_newlib(L,methods);\n\tprintf(\"xxxxxxxxxx\\n\");\n\treturn 1;\n}\n\nstatic const luaL_Reg libs [] = {{\"Account\",luaopen_Account},{NULL,NULL}};\nvoid Register(lua_State* L)\n{\n\tconst luaL_Reg *lib = libs;\n\tfor (;lib->func; lib++) \n\t{\n\t\tluaL_requiref(L, lib->name, lib->func, 1);\n\t\tlua_pop(L, 1);  /* remove lib */\n\t}\n\tlua_register(L,\"Account\",create_account);\n}\n\n+++++++++ lua中使用++++++++\nprint(\"start\");\rlocal a  = Account(100);\rprint(a);\rprint(a:balance());\ra:deposit(399);\rprint(\"start\");\rprint(a:balance());\rprint(\"end\");\n\n```","source":"_posts/Lua学习笔记.md","raw":"---\ntitle: Lua学习笔记\ndate: 2017-07-10 17:06:34\ntags: [Lua, Dev]\ncategories: Lua\n---\n\n> Lua 学习笔记\n\n<!--More-->\n\n# 一、基础知识\n## 1.1、 Lua源码学习\n### 1.1.1、C语言函数名与宏定义冲突问题\n所望的语言函数名与宏定义冲突问题，就是指宏定义与函数相同时编译器不知道标识符该怎么处理。如下代码：\n\n\t#pragma once\n\n\t#include <stdio.h>\n\t#define f() printf(\"this is define \");\n\tvoid f();\n\n上述代码在VS2010会检测出`Error:不允许使用不完整定义`。解决方案很简单，如下：\n\n\t#pragma once\n\n\t#include <stdio.h>\n\t#define f() printf(\"this is define \");\n\tvoid (f)();\n\n在函数名上添加小括号即可解决问题。这也就是为什么lua.h头文件里为什么那么函数名都带括号的原因:\n\n\t/*\n\t** access functions (stack -> C)\n\t*/\n\t\n\tLUA_API int             (lua_isnumber) (lua_State *L, int idx);\n\tLUA_API int             (lua_isstring) (lua_State *L, int idx);\n\tLUA_API int             (lua_iscfunction) (lua_State *L, int idx);\n\tLUA_API int             (lua_isinteger) (lua_State *L, int idx);\n\tLUA_API int             (lua_isuserdata) (lua_State *L, int idx);\n\tLUA_API int             (lua_type) (lua_State *L, int idx);\n\tLUA_API const char     *(lua_typename) (lua_State *L, int tp);\n\t\n\tLUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);\n\tLUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);\n\tLUA_API int             (lua_toboolean) (lua_State *L, int idx);\n\tLUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);\n\tLUA_API size_t          (lua_rawlen) (lua_State *L, int idx);\n\tLUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);\n\tLUA_API void\t       *(lua_touserdata) (lua_State *L, int idx);\n\tLUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);\n\tLUA_API const void     *(lua_topointer) (lua_State *L, int idx);\n\t....\n\n### 1.1.2、C语言大量使用宏定义\n\n+ 宏定义函数，减少函数调用开销\n+ 宏定义方便    \n\n### 1.1.3、VS编译lua源码  \n\n+ 参考： [https://www.kancloud.cn/digest/luanote/119932](https://www.kancloud.cn/digest/luanote/119932)     \n+ 注意要把你的测试project设置成启动项目，否则会出现错误：无法启动程序：xxxx.lib 指定文件格式无法识别或不支持二进制  \n\n## 2、Lua语法\n\n### 2.1、Lua函数调用方法`.`与`:`区别    \n\n+ `.`:是一般的调用     \n+ `:`:自带第一个参数`self`    \n+ `s.xxx(s,arg) == s:xxx(arg)`\n\n\n### 2.2、lua在查找一个表元素的时候，其步如下 \n\n1. 在表中查找，如果找到的话，则返回该元素，找不到则继续。    \n2. 判断该表是否有metatable表，如果没有metatable表，返回nil，有元表则继续。    \n3. **判断metatable是否有__index方法，如果__index方法为nil，则返回nil;如果__index方法是一个表，则重复1、2、3步骤;如果__index方法是一个函数，则返回该函数的返回值。**\n4. **__index中的function会增加一个默认入参，而且是第一个参数**    \n例如调用 foo.bar 时，如果在 foo 中没有找到名为 bar 的域时，则会调用 Metatable：__index(foo, bar)。于是：  \n\n\n### 2.3、__newindex元方法 \n__newindex元方法用来对表更新，而__index则用来对表进行访问。当你给表的一个缺少的索引赋值的时，解释器就会查找__newindex元方法；如果存在则调用这个函数而不进行赋值操作。     \n\n\n## 3、实战\n### C++ 类导入lua\n\n```\n/***********C++ Class to Lua*********************/\nclass Account {\npublic: \n\tAccount(double balance){ m_balance = balance;}\n\tvoid deposit(double amount){m_balance += amount;}\n\tvoid withdraw(double amount){m_balance -= amount;}\n\tdouble balance(){return m_balance;}\nprivate:\n\tdouble m_balance;\n};\n\n//class WrapperAccount {\n\n\nAccount* checkaccount(lua_State *L, int narg)\n{\n\tluaL_checktype(L,narg, LUA_TUSERDATA);\n\tvoid *ud = luaL_checkudata(L,narg,\"Account\");\n\tluaL_argcheck(L,ud!= NULL,1,\"user data error\");\n\treturn *(Account**)ud;\n}\n\nint create_account(lua_State *L)\n{\n\t\n\tdouble balance = luaL_checknumber(L,1);\n\tAccount **a = (Account**)lua_newuserdata(L,sizeof(Account));\n\t*a = new Account(balance);\n\tprintf(\"construct! balance is: %lf\\n\",balance);\n\tluaL_getmetatable(L,\"Account\");\n\tlua_setmetatable(L,-2);\n\treturn 1;\n}\nint deposit(lua_State *L)\n{\n\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);\n\tdouble amount = luaL_checknumber(L,-1);\n\t(a)->deposit(amount);\n\treturn 0;\n}\nint withdraw(lua_State *L)\n{\n\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);\n\tdouble amount = luaL_checknumber(L,-1);\n\t(a)->withdraw(amount);\n\treturn 0;\n}\nint balance(lua_State *L)\n{\n\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);\n\tdouble balance = (a)->balance();\n\tprintf(\"balance is: %lf\\n\",balance);\n\tlua_pushnumber(L,balance);\n\treturn 0;\n}\n//public:\n\nconst char className[10] = \"Account\";\nstatic const luaL_Reg methods[]= {\n\t//{\"Account\",create_account},\n\t{\"deposit\",deposit},\n\t{\"withdraw\",withdraw},\n\t{\"balance\",balance},\n\t{NULL,NULL}\n};\n\nint luaopen_Account(lua_State *L)\n{\n\tluaL_newmetatable(L,\"Account\");\n\tlua_pushvalue(L,-1);\n\tlua_setfield(L,-2,\"__index\");//AAccount.__index = AAccount\n\tluaL_setfuncs(L,methods,0);//register the methods to the table that is on the top\n\t//luaL_newlib(L,methods);\n\tprintf(\"xxxxxxxxxx\\n\");\n\treturn 1;\n}\n\nstatic const luaL_Reg libs [] = {{\"Account\",luaopen_Account},{NULL,NULL}};\nvoid Register(lua_State* L)\n{\n\tconst luaL_Reg *lib = libs;\n\tfor (;lib->func; lib++) \n\t{\n\t\tluaL_requiref(L, lib->name, lib->func, 1);\n\t\tlua_pop(L, 1);  /* remove lib */\n\t}\n\tlua_register(L,\"Account\",create_account);\n}\n\n+++++++++ lua中使用++++++++\nprint(\"start\");\rlocal a  = Account(100);\rprint(a);\rprint(a:balance());\ra:deposit(399);\rprint(\"start\");\rprint(a:balance());\rprint(\"end\");\n\n```","slug":"Lua学习笔记","published":1,"updated":"2022-06-15T07:23:15.001Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4fa2s9t0007daco68bmg6a0","content":"<blockquote>\n<p>Lua 学习笔记</p>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h1><h2 id=\"1-1、-Lua源码学习\"><a href=\"#1-1、-Lua源码学习\" class=\"headerlink\" title=\"1.1、 Lua源码学习\"></a>1.1、 Lua源码学习</h2><h3 id=\"1-1-1、C语言函数名与宏定义冲突问题\"><a href=\"#1-1-1、C语言函数名与宏定义冲突问题\" class=\"headerlink\" title=\"1.1.1、C语言函数名与宏定义冲突问题\"></a>1.1.1、C语言函数名与宏定义冲突问题</h3><p>所望的语言函数名与宏定义冲突问题，就是指宏定义与函数相同时编译器不知道标识符该怎么处理。如下代码：</p>\n<pre><code>#pragma once\n\n#include &lt;stdio.h&gt;\n#define f() printf(&quot;this is define &quot;);\nvoid f();\n</code></pre><p>上述代码在VS2010会检测出<code>Error:不允许使用不完整定义</code>。解决方案很简单，如下：</p>\n<pre><code>#pragma once\n\n#include &lt;stdio.h&gt;\n#define f() printf(&quot;this is define &quot;);\nvoid (f)();\n</code></pre><p>在函数名上添加小括号即可解决问题。这也就是为什么lua.h头文件里为什么那么函数名都带括号的原因:</p>\n<pre><code>/*\n** access functions (stack -&gt; C)\n*/\n\nLUA_API int             (lua_isnumber) (lua_State *L, int idx);\nLUA_API int             (lua_isstring) (lua_State *L, int idx);\nLUA_API int             (lua_iscfunction) (lua_State *L, int idx);\nLUA_API int             (lua_isinteger) (lua_State *L, int idx);\nLUA_API int             (lua_isuserdata) (lua_State *L, int idx);\nLUA_API int             (lua_type) (lua_State *L, int idx);\nLUA_API const char     *(lua_typename) (lua_State *L, int tp);\n\nLUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);\nLUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);\nLUA_API int             (lua_toboolean) (lua_State *L, int idx);\nLUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);\nLUA_API size_t          (lua_rawlen) (lua_State *L, int idx);\nLUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);\nLUA_API void           *(lua_touserdata) (lua_State *L, int idx);\nLUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);\nLUA_API const void     *(lua_topointer) (lua_State *L, int idx);\n....\n</code></pre><h3 id=\"1-1-2、C语言大量使用宏定义\"><a href=\"#1-1-2、C语言大量使用宏定义\" class=\"headerlink\" title=\"1.1.2、C语言大量使用宏定义\"></a>1.1.2、C语言大量使用宏定义</h3><ul>\n<li>宏定义函数，减少函数调用开销</li>\n<li>宏定义方便    </li>\n</ul>\n<h3 id=\"1-1-3、VS编译lua源码\"><a href=\"#1-1-3、VS编译lua源码\" class=\"headerlink\" title=\"1.1.3、VS编译lua源码\"></a>1.1.3、VS编译lua源码</h3><ul>\n<li>参考： <a href=\"https://www.kancloud.cn/digest/luanote/119932\" target=\"_blank\" rel=\"noopener\">https://www.kancloud.cn/digest/luanote/119932</a>     </li>\n<li>注意要把你的测试project设置成启动项目，否则会出现错误：无法启动程序：xxxx.lib 指定文件格式无法识别或不支持二进制  </li>\n</ul>\n<h2 id=\"2、Lua语法\"><a href=\"#2、Lua语法\" class=\"headerlink\" title=\"2、Lua语法\"></a>2、Lua语法</h2><h3 id=\"2-1、Lua函数调用方法-与-区别\"><a href=\"#2-1、Lua函数调用方法-与-区别\" class=\"headerlink\" title=\"2.1、Lua函数调用方法.与:区别\"></a>2.1、Lua函数调用方法<code>.</code>与<code>:</code>区别</h3><ul>\n<li><code>.</code>:是一般的调用     </li>\n<li><code>:</code>:自带第一个参数<code>self</code>    </li>\n<li><code>s.xxx(s,arg) == s:xxx(arg)</code></li>\n</ul>\n<h3 id=\"2-2、lua在查找一个表元素的时候，其步如下\"><a href=\"#2-2、lua在查找一个表元素的时候，其步如下\" class=\"headerlink\" title=\"2.2、lua在查找一个表元素的时候，其步如下\"></a>2.2、lua在查找一个表元素的时候，其步如下</h3><ol>\n<li>在表中查找，如果找到的话，则返回该元素，找不到则继续。    </li>\n<li>判断该表是否有metatable表，如果没有metatable表，返回nil，有元表则继续。    </li>\n<li><strong>判断metatable是否有<strong>index方法，如果</strong>index方法为nil，则返回nil;如果<strong>index方法是一个表，则重复1、2、3步骤;如果</strong>index方法是一个函数，则返回该函数的返回值。</strong></li>\n<li><strong>__index中的function会增加一个默认入参，而且是第一个参数</strong><br>例如调用 foo.bar 时，如果在 foo 中没有找到名为 bar 的域时，则会调用 Metatable：__index(foo, bar)。于是：  </li>\n</ol>\n<h3 id=\"2-3、-newindex元方法\"><a href=\"#2-3、-newindex元方法\" class=\"headerlink\" title=\"2.3、__newindex元方法\"></a>2.3、__newindex元方法</h3><p><strong>newindex元方法用来对表更新，而</strong>index则用来对表进行访问。当你给表的一个缺少的索引赋值的时，解释器就会查找__newindex元方法；如果存在则调用这个函数而不进行赋值操作。     </p>\n<h2 id=\"3、实战\"><a href=\"#3、实战\" class=\"headerlink\" title=\"3、实战\"></a>3、实战</h2><h3 id=\"C-类导入lua\"><a href=\"#C-类导入lua\" class=\"headerlink\" title=\"C++ 类导入lua\"></a>C++ 类导入lua</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/***********C++ Class to Lua*********************/</span><br><span class=\"line\">class Account &#123;</span><br><span class=\"line\">public: </span><br><span class=\"line\">\tAccount(double balance)&#123; m_balance = balance;&#125;</span><br><span class=\"line\">\tvoid deposit(double amount)&#123;m_balance += amount;&#125;</span><br><span class=\"line\">\tvoid withdraw(double amount)&#123;m_balance -= amount;&#125;</span><br><span class=\"line\">\tdouble balance()&#123;return m_balance;&#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tdouble m_balance;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//class WrapperAccount &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Account* checkaccount(lua_State *L, int narg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tluaL_checktype(L,narg, LUA_TUSERDATA);</span><br><span class=\"line\">\tvoid *ud = luaL_checkudata(L,narg,&quot;Account&quot;);</span><br><span class=\"line\">\tluaL_argcheck(L,ud!= NULL,1,&quot;user data error&quot;);</span><br><span class=\"line\">\treturn *(Account**)ud;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int create_account(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tdouble balance = luaL_checknumber(L,1);</span><br><span class=\"line\">\tAccount **a = (Account**)lua_newuserdata(L,sizeof(Account));</span><br><span class=\"line\">\t*a = new Account(balance);</span><br><span class=\"line\">\tprintf(&quot;construct! balance is: %lf\\n&quot;,balance);</span><br><span class=\"line\">\tluaL_getmetatable(L,&quot;Account&quot;);</span><br><span class=\"line\">\tlua_setmetatable(L,-2);</span><br><span class=\"line\">\treturn 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int deposit(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);</span><br><span class=\"line\">\tdouble amount = luaL_checknumber(L,-1);</span><br><span class=\"line\">\t(a)-&gt;deposit(amount);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int withdraw(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);</span><br><span class=\"line\">\tdouble amount = luaL_checknumber(L,-1);</span><br><span class=\"line\">\t(a)-&gt;withdraw(amount);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int balance(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);</span><br><span class=\"line\">\tdouble balance = (a)-&gt;balance();</span><br><span class=\"line\">\tprintf(&quot;balance is: %lf\\n&quot;,balance);</span><br><span class=\"line\">\tlua_pushnumber(L,balance);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//public:</span><br><span class=\"line\"></span><br><span class=\"line\">const char className[10] = &quot;Account&quot;;</span><br><span class=\"line\">static const luaL_Reg methods[]= &#123;</span><br><span class=\"line\">\t//&#123;&quot;Account&quot;,create_account&#125;,</span><br><span class=\"line\">\t&#123;&quot;deposit&quot;,deposit&#125;,</span><br><span class=\"line\">\t&#123;&quot;withdraw&quot;,withdraw&#125;,</span><br><span class=\"line\">\t&#123;&quot;balance&quot;,balance&#125;,</span><br><span class=\"line\">\t&#123;NULL,NULL&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int luaopen_Account(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tluaL_newmetatable(L,&quot;Account&quot;);</span><br><span class=\"line\">\tlua_pushvalue(L,-1);</span><br><span class=\"line\">\tlua_setfield(L,-2,&quot;__index&quot;);//AAccount.__index = AAccount</span><br><span class=\"line\">\tluaL_setfuncs(L,methods,0);//register the methods to the table that is on the top</span><br><span class=\"line\">\t//luaL_newlib(L,methods);</span><br><span class=\"line\">\tprintf(&quot;xxxxxxxxxx\\n&quot;);</span><br><span class=\"line\">\treturn 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static const luaL_Reg libs [] = &#123;&#123;&quot;Account&quot;,luaopen_Account&#125;,&#123;NULL,NULL&#125;&#125;;</span><br><span class=\"line\">void Register(lua_State* L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tconst luaL_Reg *lib = libs;</span><br><span class=\"line\">\tfor (;lib-&gt;func; lib++) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tluaL_requiref(L, lib-&gt;name, lib-&gt;func, 1);</span><br><span class=\"line\">\t\tlua_pop(L, 1);  /* remove lib */</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlua_register(L,&quot;Account&quot;,create_account);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+++++++++ lua中使用++++++++</span><br><span class=\"line\">print(&quot;start&quot;);\rlocal a  = Account(100);\rprint(a);\rprint(a:balance());\ra:deposit(399);\rprint(&quot;start&quot;);\rprint(a:balance());\rprint(&quot;end&quot;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<blockquote>\n<p>Lua 学习笔记</p>\n</blockquote>","more":"<h1 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h1><h2 id=\"1-1、-Lua源码学习\"><a href=\"#1-1、-Lua源码学习\" class=\"headerlink\" title=\"1.1、 Lua源码学习\"></a>1.1、 Lua源码学习</h2><h3 id=\"1-1-1、C语言函数名与宏定义冲突问题\"><a href=\"#1-1-1、C语言函数名与宏定义冲突问题\" class=\"headerlink\" title=\"1.1.1、C语言函数名与宏定义冲突问题\"></a>1.1.1、C语言函数名与宏定义冲突问题</h3><p>所望的语言函数名与宏定义冲突问题，就是指宏定义与函数相同时编译器不知道标识符该怎么处理。如下代码：</p>\n<pre><code>#pragma once\n\n#include &lt;stdio.h&gt;\n#define f() printf(&quot;this is define &quot;);\nvoid f();\n</code></pre><p>上述代码在VS2010会检测出<code>Error:不允许使用不完整定义</code>。解决方案很简单，如下：</p>\n<pre><code>#pragma once\n\n#include &lt;stdio.h&gt;\n#define f() printf(&quot;this is define &quot;);\nvoid (f)();\n</code></pre><p>在函数名上添加小括号即可解决问题。这也就是为什么lua.h头文件里为什么那么函数名都带括号的原因:</p>\n<pre><code>/*\n** access functions (stack -&gt; C)\n*/\n\nLUA_API int             (lua_isnumber) (lua_State *L, int idx);\nLUA_API int             (lua_isstring) (lua_State *L, int idx);\nLUA_API int             (lua_iscfunction) (lua_State *L, int idx);\nLUA_API int             (lua_isinteger) (lua_State *L, int idx);\nLUA_API int             (lua_isuserdata) (lua_State *L, int idx);\nLUA_API int             (lua_type) (lua_State *L, int idx);\nLUA_API const char     *(lua_typename) (lua_State *L, int tp);\n\nLUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);\nLUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);\nLUA_API int             (lua_toboolean) (lua_State *L, int idx);\nLUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);\nLUA_API size_t          (lua_rawlen) (lua_State *L, int idx);\nLUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);\nLUA_API void           *(lua_touserdata) (lua_State *L, int idx);\nLUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);\nLUA_API const void     *(lua_topointer) (lua_State *L, int idx);\n....\n</code></pre><h3 id=\"1-1-2、C语言大量使用宏定义\"><a href=\"#1-1-2、C语言大量使用宏定义\" class=\"headerlink\" title=\"1.1.2、C语言大量使用宏定义\"></a>1.1.2、C语言大量使用宏定义</h3><ul>\n<li>宏定义函数，减少函数调用开销</li>\n<li>宏定义方便    </li>\n</ul>\n<h3 id=\"1-1-3、VS编译lua源码\"><a href=\"#1-1-3、VS编译lua源码\" class=\"headerlink\" title=\"1.1.3、VS编译lua源码\"></a>1.1.3、VS编译lua源码</h3><ul>\n<li>参考： <a href=\"https://www.kancloud.cn/digest/luanote/119932\" target=\"_blank\" rel=\"noopener\">https://www.kancloud.cn/digest/luanote/119932</a>     </li>\n<li>注意要把你的测试project设置成启动项目，否则会出现错误：无法启动程序：xxxx.lib 指定文件格式无法识别或不支持二进制  </li>\n</ul>\n<h2 id=\"2、Lua语法\"><a href=\"#2、Lua语法\" class=\"headerlink\" title=\"2、Lua语法\"></a>2、Lua语法</h2><h3 id=\"2-1、Lua函数调用方法-与-区别\"><a href=\"#2-1、Lua函数调用方法-与-区别\" class=\"headerlink\" title=\"2.1、Lua函数调用方法.与:区别\"></a>2.1、Lua函数调用方法<code>.</code>与<code>:</code>区别</h3><ul>\n<li><code>.</code>:是一般的调用     </li>\n<li><code>:</code>:自带第一个参数<code>self</code>    </li>\n<li><code>s.xxx(s,arg) == s:xxx(arg)</code></li>\n</ul>\n<h3 id=\"2-2、lua在查找一个表元素的时候，其步如下\"><a href=\"#2-2、lua在查找一个表元素的时候，其步如下\" class=\"headerlink\" title=\"2.2、lua在查找一个表元素的时候，其步如下\"></a>2.2、lua在查找一个表元素的时候，其步如下</h3><ol>\n<li>在表中查找，如果找到的话，则返回该元素，找不到则继续。    </li>\n<li>判断该表是否有metatable表，如果没有metatable表，返回nil，有元表则继续。    </li>\n<li><strong>判断metatable是否有<strong>index方法，如果</strong>index方法为nil，则返回nil;如果<strong>index方法是一个表，则重复1、2、3步骤;如果</strong>index方法是一个函数，则返回该函数的返回值。</strong></li>\n<li><strong>__index中的function会增加一个默认入参，而且是第一个参数</strong><br>例如调用 foo.bar 时，如果在 foo 中没有找到名为 bar 的域时，则会调用 Metatable：__index(foo, bar)。于是：  </li>\n</ol>\n<h3 id=\"2-3、-newindex元方法\"><a href=\"#2-3、-newindex元方法\" class=\"headerlink\" title=\"2.3、__newindex元方法\"></a>2.3、__newindex元方法</h3><p><strong>newindex元方法用来对表更新，而</strong>index则用来对表进行访问。当你给表的一个缺少的索引赋值的时，解释器就会查找__newindex元方法；如果存在则调用这个函数而不进行赋值操作。     </p>\n<h2 id=\"3、实战\"><a href=\"#3、实战\" class=\"headerlink\" title=\"3、实战\"></a>3、实战</h2><h3 id=\"C-类导入lua\"><a href=\"#C-类导入lua\" class=\"headerlink\" title=\"C++ 类导入lua\"></a>C++ 类导入lua</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/***********C++ Class to Lua*********************/</span><br><span class=\"line\">class Account &#123;</span><br><span class=\"line\">public: </span><br><span class=\"line\">\tAccount(double balance)&#123; m_balance = balance;&#125;</span><br><span class=\"line\">\tvoid deposit(double amount)&#123;m_balance += amount;&#125;</span><br><span class=\"line\">\tvoid withdraw(double amount)&#123;m_balance -= amount;&#125;</span><br><span class=\"line\">\tdouble balance()&#123;return m_balance;&#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tdouble m_balance;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//class WrapperAccount &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Account* checkaccount(lua_State *L, int narg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tluaL_checktype(L,narg, LUA_TUSERDATA);</span><br><span class=\"line\">\tvoid *ud = luaL_checkudata(L,narg,&quot;Account&quot;);</span><br><span class=\"line\">\tluaL_argcheck(L,ud!= NULL,1,&quot;user data error&quot;);</span><br><span class=\"line\">\treturn *(Account**)ud;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int create_account(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tdouble balance = luaL_checknumber(L,1);</span><br><span class=\"line\">\tAccount **a = (Account**)lua_newuserdata(L,sizeof(Account));</span><br><span class=\"line\">\t*a = new Account(balance);</span><br><span class=\"line\">\tprintf(&quot;construct! balance is: %lf\\n&quot;,balance);</span><br><span class=\"line\">\tluaL_getmetatable(L,&quot;Account&quot;);</span><br><span class=\"line\">\tlua_setmetatable(L,-2);</span><br><span class=\"line\">\treturn 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int deposit(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);</span><br><span class=\"line\">\tdouble amount = luaL_checknumber(L,-1);</span><br><span class=\"line\">\t(a)-&gt;deposit(amount);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int withdraw(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);</span><br><span class=\"line\">\tdouble amount = luaL_checknumber(L,-1);</span><br><span class=\"line\">\t(a)-&gt;withdraw(amount);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int balance(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tAccount *a = checkaccount(L,1);//(Account**)lua_touserdata(L,1);</span><br><span class=\"line\">\tdouble balance = (a)-&gt;balance();</span><br><span class=\"line\">\tprintf(&quot;balance is: %lf\\n&quot;,balance);</span><br><span class=\"line\">\tlua_pushnumber(L,balance);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//public:</span><br><span class=\"line\"></span><br><span class=\"line\">const char className[10] = &quot;Account&quot;;</span><br><span class=\"line\">static const luaL_Reg methods[]= &#123;</span><br><span class=\"line\">\t//&#123;&quot;Account&quot;,create_account&#125;,</span><br><span class=\"line\">\t&#123;&quot;deposit&quot;,deposit&#125;,</span><br><span class=\"line\">\t&#123;&quot;withdraw&quot;,withdraw&#125;,</span><br><span class=\"line\">\t&#123;&quot;balance&quot;,balance&#125;,</span><br><span class=\"line\">\t&#123;NULL,NULL&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int luaopen_Account(lua_State *L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tluaL_newmetatable(L,&quot;Account&quot;);</span><br><span class=\"line\">\tlua_pushvalue(L,-1);</span><br><span class=\"line\">\tlua_setfield(L,-2,&quot;__index&quot;);//AAccount.__index = AAccount</span><br><span class=\"line\">\tluaL_setfuncs(L,methods,0);//register the methods to the table that is on the top</span><br><span class=\"line\">\t//luaL_newlib(L,methods);</span><br><span class=\"line\">\tprintf(&quot;xxxxxxxxxx\\n&quot;);</span><br><span class=\"line\">\treturn 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static const luaL_Reg libs [] = &#123;&#123;&quot;Account&quot;,luaopen_Account&#125;,&#123;NULL,NULL&#125;&#125;;</span><br><span class=\"line\">void Register(lua_State* L)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tconst luaL_Reg *lib = libs;</span><br><span class=\"line\">\tfor (;lib-&gt;func; lib++) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tluaL_requiref(L, lib-&gt;name, lib-&gt;func, 1);</span><br><span class=\"line\">\t\tlua_pop(L, 1);  /* remove lib */</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlua_register(L,&quot;Account&quot;,create_account);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+++++++++ lua中使用++++++++</span><br><span class=\"line\">print(&quot;start&quot;);\rlocal a  = Account(100);\rprint(a);\rprint(a:balance());\ra:deposit(399);\rprint(&quot;start&quot;);\rprint(a:balance());\rprint(&quot;end&quot;);</span><br></pre></td></tr></table></figure>"},{"title":"Unity 学习笔记","date":"2017-06-27T07:23:37.000Z","_content":"> Unity 学习笔记(包括C#)\n\n<!--More-->\n\n# Reference\n+ [Unity manualt翻译](https://nuysoft.gitbooks.io/unity-manual/content/)\n+ [Unity mannual](https://docs.unity3d.com/Manual/index.html)\n+ [Unity圣典](http://www.ceeger.com/forum/)\n+ [Unity 蛮牛](http://www.manew.com/)    \n\n# 一、基础\n## 1.1 Gameobject\n\nGameobject是游戏中最重要的一个角色，游戏中任务一个对象都是一个Gameobject。\n## 1.2 prefab\n\n预设 (Prefabs) 是可重复用于场景中的游戏对象 (GameObject) 和组件 (Component) 的集合。一个预设 (Prefab) 可创建多个相同对象，称之为实例化。Prefab可以理解为结构蓝图，如果蓝图变了实例也会跟着一起变。\n\n## 1.3 Shader，Material，Texture，Mesh\n\n\n|unity| 物体 |     \n|:--|:--|     \n|Texture|表面呈现的图案，bitmap images|   \n|Material|表示物体的材料与质感：光滑度，透明度，反射率，发光度等，由Texture+Shader|    \n|[Shader](https://onevcat.com/2013/07/shader-tutorial-1/)|是一个脚本，将贴图，颜色，mesh进行mix，然后输出可绘制的单元|     \n|Mesh|物体的外形|     \n\n\n\n[参考](http://docs.manew.com/Manual/index.htm)      \n\n着色器(Shader)可定义以下事项：\n\n+ 渲染对象的方法。这包括使用不同方法，具体取决于最终用户的图形卡。\n+ 用于渲染的任何顶点照明和部分照明程序。\n+ 材质 (Materials) 内可供分配的纹理属性。\n+ 材质 (Materials) 内可供分配的颜色和数量设置。    \n\n材质 (Materials) 可定义：　　　\n\n+ 渲染使用的纹理。　　\n+ 渲染使用的颜色。　　\n+ 任何其他资源，如着色器进行渲染所需的立方体贴图 (Cubemap)。　　　\n\n着色器由图形程序员编写。程序员使用非常简单的 ShaderLab 语言创建着色器。但是，让着色器在各种不同图形卡上充分发挥其作用是一项复杂的工作，这需要对图形卡运行原理有非常全面地了解。\n\n## 1.4 Unity线程，协程\n\n### unity是一个单线程引擎，主要原因是UnityEngine相关SDK只能在主线程中跑 \n\n协程：   \n\n+ yield; 在下一帧上调用所有 Update 函数后，协同程序将继续运行。\n+ yield WaitForSeconds(2); 在指定的时间延迟之后，为此帧调用所有 Update 函数之后继续运行\n+ yield WaitForFixedUpdate(); 在所有脚本上调用所有 FixedUpdate 后继续运行\n+ yield WWW 完成 WWW 下载后继续运行。\n+ yield StartCoroutine(MyFunc); 连接协同程序，并等待 MyFunc coroutine 首先结束。\n\n## 1.5 Unity Life Cycle\n\n![img](https://docs.unity3d.com/uploads/Main/monobehaviour_flowchart.svg)  \n\n## 1.6 Unity坐标系\n![img](http://answers.unity3d.com/storage/temp/8053-spaces.jpg)   \n\n## 1.7 iOS编译问题\n\n从Unity导出iOS工程时需要注意是否使用了一些JIT(just in time compiler)特性的语法（例如C# Linq的排序）。因为iOS编译是AOT((Ahead-Of-Time，静态编译)不支持动态编译。\n\n# 二、实践\n## 2.1 Unity使用DLL（动态链接库）\n### 2.1.1、 生成DLL\n\nDLL的生成是需要借助于VS的，Unity自己是无法做到的。    \n\n+ 新建C#**类库项目**，注意项目类型必须是类库项目\n\n+ 编写代码，与正常开发无异\n+ 将项目属性 -> 应用程序 -> 目标框架：改为` .NET Framework 3.5`或以下 。这一步很重要，因为Unity3D（当前的Unity3D版本是3.5版） 支持的 .Net 是3.5版。\n\n然后run一下就会生成一个DLL库\n\n### 2.1.2、Unity使用DLL\nUnity使用DLL就相当简单了，只需要将DLL拖入Unity工程随便什么目录都可以，一般是放置到Plugin目录下。然后，C#就可以正常使用DLL中的代码。","source":"_posts/Unity-学习笔记.md","raw":"---\ntitle: Unity 学习笔记\ndate: 2017-06-27 15:23:37\ntags: [Unity, Dev]\ncategories: Unity\n---\n> Unity 学习笔记(包括C#)\n\n<!--More-->\n\n# Reference\n+ [Unity manualt翻译](https://nuysoft.gitbooks.io/unity-manual/content/)\n+ [Unity mannual](https://docs.unity3d.com/Manual/index.html)\n+ [Unity圣典](http://www.ceeger.com/forum/)\n+ [Unity 蛮牛](http://www.manew.com/)    \n\n# 一、基础\n## 1.1 Gameobject\n\nGameobject是游戏中最重要的一个角色，游戏中任务一个对象都是一个Gameobject。\n## 1.2 prefab\n\n预设 (Prefabs) 是可重复用于场景中的游戏对象 (GameObject) 和组件 (Component) 的集合。一个预设 (Prefab) 可创建多个相同对象，称之为实例化。Prefab可以理解为结构蓝图，如果蓝图变了实例也会跟着一起变。\n\n## 1.3 Shader，Material，Texture，Mesh\n\n\n|unity| 物体 |     \n|:--|:--|     \n|Texture|表面呈现的图案，bitmap images|   \n|Material|表示物体的材料与质感：光滑度，透明度，反射率，发光度等，由Texture+Shader|    \n|[Shader](https://onevcat.com/2013/07/shader-tutorial-1/)|是一个脚本，将贴图，颜色，mesh进行mix，然后输出可绘制的单元|     \n|Mesh|物体的外形|     \n\n\n\n[参考](http://docs.manew.com/Manual/index.htm)      \n\n着色器(Shader)可定义以下事项：\n\n+ 渲染对象的方法。这包括使用不同方法，具体取决于最终用户的图形卡。\n+ 用于渲染的任何顶点照明和部分照明程序。\n+ 材质 (Materials) 内可供分配的纹理属性。\n+ 材质 (Materials) 内可供分配的颜色和数量设置。    \n\n材质 (Materials) 可定义：　　　\n\n+ 渲染使用的纹理。　　\n+ 渲染使用的颜色。　　\n+ 任何其他资源，如着色器进行渲染所需的立方体贴图 (Cubemap)。　　　\n\n着色器由图形程序员编写。程序员使用非常简单的 ShaderLab 语言创建着色器。但是，让着色器在各种不同图形卡上充分发挥其作用是一项复杂的工作，这需要对图形卡运行原理有非常全面地了解。\n\n## 1.4 Unity线程，协程\n\n### unity是一个单线程引擎，主要原因是UnityEngine相关SDK只能在主线程中跑 \n\n协程：   \n\n+ yield; 在下一帧上调用所有 Update 函数后，协同程序将继续运行。\n+ yield WaitForSeconds(2); 在指定的时间延迟之后，为此帧调用所有 Update 函数之后继续运行\n+ yield WaitForFixedUpdate(); 在所有脚本上调用所有 FixedUpdate 后继续运行\n+ yield WWW 完成 WWW 下载后继续运行。\n+ yield StartCoroutine(MyFunc); 连接协同程序，并等待 MyFunc coroutine 首先结束。\n\n## 1.5 Unity Life Cycle\n\n![img](https://docs.unity3d.com/uploads/Main/monobehaviour_flowchart.svg)  \n\n## 1.6 Unity坐标系\n![img](http://answers.unity3d.com/storage/temp/8053-spaces.jpg)   \n\n## 1.7 iOS编译问题\n\n从Unity导出iOS工程时需要注意是否使用了一些JIT(just in time compiler)特性的语法（例如C# Linq的排序）。因为iOS编译是AOT((Ahead-Of-Time，静态编译)不支持动态编译。\n\n# 二、实践\n## 2.1 Unity使用DLL（动态链接库）\n### 2.1.1、 生成DLL\n\nDLL的生成是需要借助于VS的，Unity自己是无法做到的。    \n\n+ 新建C#**类库项目**，注意项目类型必须是类库项目\n\n+ 编写代码，与正常开发无异\n+ 将项目属性 -> 应用程序 -> 目标框架：改为` .NET Framework 3.5`或以下 。这一步很重要，因为Unity3D（当前的Unity3D版本是3.5版） 支持的 .Net 是3.5版。\n\n然后run一下就会生成一个DLL库\n\n### 2.1.2、Unity使用DLL\nUnity使用DLL就相当简单了，只需要将DLL拖入Unity工程随便什么目录都可以，一般是放置到Plugin目录下。然后，C#就可以正常使用DLL中的代码。","slug":"Unity-学习笔记","published":1,"updated":"2022-06-15T07:23:15.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4fa2s9w0008dacoz4oppgyh","content":"<blockquote>\n<p>Unity 学习笔记(包括C#)</p>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://nuysoft.gitbooks.io/unity-manual/content/\" target=\"_blank\" rel=\"noopener\">Unity manualt翻译</a></li>\n<li><a href=\"https://docs.unity3d.com/Manual/index.html\" target=\"_blank\" rel=\"noopener\">Unity mannual</a></li>\n<li><a href=\"http://www.ceeger.com/forum/\" target=\"_blank\" rel=\"noopener\">Unity圣典</a></li>\n<li><a href=\"http://www.manew.com/\" target=\"_blank\" rel=\"noopener\">Unity 蛮牛</a>    </li>\n</ul>\n<h1 id=\"一、基础\"><a href=\"#一、基础\" class=\"headerlink\" title=\"一、基础\"></a>一、基础</h1><h2 id=\"1-1-Gameobject\"><a href=\"#1-1-Gameobject\" class=\"headerlink\" title=\"1.1 Gameobject\"></a>1.1 Gameobject</h2><p>Gameobject是游戏中最重要的一个角色，游戏中任务一个对象都是一个Gameobject。</p>\n<h2 id=\"1-2-prefab\"><a href=\"#1-2-prefab\" class=\"headerlink\" title=\"1.2 prefab\"></a>1.2 prefab</h2><p>预设 (Prefabs) 是可重复用于场景中的游戏对象 (GameObject) 和组件 (Component) 的集合。一个预设 (Prefab) 可创建多个相同对象，称之为实例化。Prefab可以理解为结构蓝图，如果蓝图变了实例也会跟着一起变。</p>\n<h2 id=\"1-3-Shader，Material，Texture，Mesh\"><a href=\"#1-3-Shader，Material，Texture，Mesh\" class=\"headerlink\" title=\"1.3 Shader，Material，Texture，Mesh\"></a>1.3 Shader，Material，Texture，Mesh</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">unity</th>\n<th style=\"text-align:left\">物体</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Texture</td>\n<td style=\"text-align:left\">表面呈现的图案，bitmap images</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Material</td>\n<td style=\"text-align:left\">表示物体的材料与质感：光滑度，透明度，反射率，发光度等，由Texture+Shader</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><a href=\"https://onevcat.com/2013/07/shader-tutorial-1/\" target=\"_blank\" rel=\"noopener\">Shader</a></td>\n<td style=\"text-align:left\">是一个脚本，将贴图，颜色，mesh进行mix，然后输出可绘制的单元</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Mesh</td>\n<td style=\"text-align:left\">物体的外形</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"http://docs.manew.com/Manual/index.htm\" target=\"_blank\" rel=\"noopener\">参考</a>      </p>\n<p>着色器(Shader)可定义以下事项：</p>\n<ul>\n<li>渲染对象的方法。这包括使用不同方法，具体取决于最终用户的图形卡。</li>\n<li>用于渲染的任何顶点照明和部分照明程序。</li>\n<li>材质 (Materials) 内可供分配的纹理属性。</li>\n<li>材质 (Materials) 内可供分配的颜色和数量设置。    </li>\n</ul>\n<p>材质 (Materials) 可定义：　　　</p>\n<ul>\n<li>渲染使用的纹理。　　</li>\n<li>渲染使用的颜色。　　</li>\n<li>任何其他资源，如着色器进行渲染所需的立方体贴图 (Cubemap)。　　　</li>\n</ul>\n<p>着色器由图形程序员编写。程序员使用非常简单的 ShaderLab 语言创建着色器。但是，让着色器在各种不同图形卡上充分发挥其作用是一项复杂的工作，这需要对图形卡运行原理有非常全面地了解。</p>\n<h2 id=\"1-4-Unity线程，协程\"><a href=\"#1-4-Unity线程，协程\" class=\"headerlink\" title=\"1.4 Unity线程，协程\"></a>1.4 Unity线程，协程</h2><h3 id=\"unity是一个单线程引擎，主要原因是UnityEngine相关SDK只能在主线程中跑\"><a href=\"#unity是一个单线程引擎，主要原因是UnityEngine相关SDK只能在主线程中跑\" class=\"headerlink\" title=\"unity是一个单线程引擎，主要原因是UnityEngine相关SDK只能在主线程中跑\"></a>unity是一个单线程引擎，主要原因是UnityEngine相关SDK只能在主线程中跑</h3><p>协程：   </p>\n<ul>\n<li>yield; 在下一帧上调用所有 Update 函数后，协同程序将继续运行。</li>\n<li>yield WaitForSeconds(2); 在指定的时间延迟之后，为此帧调用所有 Update 函数之后继续运行</li>\n<li>yield WaitForFixedUpdate(); 在所有脚本上调用所有 FixedUpdate 后继续运行</li>\n<li>yield WWW 完成 WWW 下载后继续运行。</li>\n<li>yield StartCoroutine(MyFunc); 连接协同程序，并等待 MyFunc coroutine 首先结束。</li>\n</ul>\n<h2 id=\"1-5-Unity-Life-Cycle\"><a href=\"#1-5-Unity-Life-Cycle\" class=\"headerlink\" title=\"1.5 Unity Life Cycle\"></a>1.5 Unity Life Cycle</h2><p><img src=\"https://docs.unity3d.com/uploads/Main/monobehaviour_flowchart.svg\" alt=\"img\">  </p>\n<h2 id=\"1-6-Unity坐标系\"><a href=\"#1-6-Unity坐标系\" class=\"headerlink\" title=\"1.6 Unity坐标系\"></a>1.6 Unity坐标系</h2><p><img src=\"http://answers.unity3d.com/storage/temp/8053-spaces.jpg\" alt=\"img\">   </p>\n<h2 id=\"1-7-iOS编译问题\"><a href=\"#1-7-iOS编译问题\" class=\"headerlink\" title=\"1.7 iOS编译问题\"></a>1.7 iOS编译问题</h2><p>从Unity导出iOS工程时需要注意是否使用了一些JIT(just in time compiler)特性的语法（例如C# Linq的排序）。因为iOS编译是AOT((Ahead-Of-Time，静态编译)不支持动态编译。</p>\n<h1 id=\"二、实践\"><a href=\"#二、实践\" class=\"headerlink\" title=\"二、实践\"></a>二、实践</h1><h2 id=\"2-1-Unity使用DLL（动态链接库）\"><a href=\"#2-1-Unity使用DLL（动态链接库）\" class=\"headerlink\" title=\"2.1 Unity使用DLL（动态链接库）\"></a>2.1 Unity使用DLL（动态链接库）</h2><h3 id=\"2-1-1、-生成DLL\"><a href=\"#2-1-1、-生成DLL\" class=\"headerlink\" title=\"2.1.1、 生成DLL\"></a>2.1.1、 生成DLL</h3><p>DLL的生成是需要借助于VS的，Unity自己是无法做到的。    </p>\n<ul>\n<li><p>新建C#<strong>类库项目</strong>，注意项目类型必须是类库项目</p>\n</li>\n<li><p>编写代码，与正常开发无异</p>\n</li>\n<li>将项目属性 -&gt; 应用程序 -&gt; 目标框架：改为<code>.NET Framework 3.5</code>或以下 。这一步很重要，因为Unity3D（当前的Unity3D版本是3.5版） 支持的 .Net 是3.5版。</li>\n</ul>\n<p>然后run一下就会生成一个DLL库</p>\n<h3 id=\"2-1-2、Unity使用DLL\"><a href=\"#2-1-2、Unity使用DLL\" class=\"headerlink\" title=\"2.1.2、Unity使用DLL\"></a>2.1.2、Unity使用DLL</h3><p>Unity使用DLL就相当简单了，只需要将DLL拖入Unity工程随便什么目录都可以，一般是放置到Plugin目录下。然后，C#就可以正常使用DLL中的代码。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Unity 学习笔记(包括C#)</p>\n</blockquote>","more":"<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><a href=\"https://nuysoft.gitbooks.io/unity-manual/content/\" target=\"_blank\" rel=\"noopener\">Unity manualt翻译</a></li>\n<li><a href=\"https://docs.unity3d.com/Manual/index.html\" target=\"_blank\" rel=\"noopener\">Unity mannual</a></li>\n<li><a href=\"http://www.ceeger.com/forum/\" target=\"_blank\" rel=\"noopener\">Unity圣典</a></li>\n<li><a href=\"http://www.manew.com/\" target=\"_blank\" rel=\"noopener\">Unity 蛮牛</a>    </li>\n</ul>\n<h1 id=\"一、基础\"><a href=\"#一、基础\" class=\"headerlink\" title=\"一、基础\"></a>一、基础</h1><h2 id=\"1-1-Gameobject\"><a href=\"#1-1-Gameobject\" class=\"headerlink\" title=\"1.1 Gameobject\"></a>1.1 Gameobject</h2><p>Gameobject是游戏中最重要的一个角色，游戏中任务一个对象都是一个Gameobject。</p>\n<h2 id=\"1-2-prefab\"><a href=\"#1-2-prefab\" class=\"headerlink\" title=\"1.2 prefab\"></a>1.2 prefab</h2><p>预设 (Prefabs) 是可重复用于场景中的游戏对象 (GameObject) 和组件 (Component) 的集合。一个预设 (Prefab) 可创建多个相同对象，称之为实例化。Prefab可以理解为结构蓝图，如果蓝图变了实例也会跟着一起变。</p>\n<h2 id=\"1-3-Shader，Material，Texture，Mesh\"><a href=\"#1-3-Shader，Material，Texture，Mesh\" class=\"headerlink\" title=\"1.3 Shader，Material，Texture，Mesh\"></a>1.3 Shader，Material，Texture，Mesh</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">unity</th>\n<th style=\"text-align:left\">物体</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Texture</td>\n<td style=\"text-align:left\">表面呈现的图案，bitmap images</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Material</td>\n<td style=\"text-align:left\">表示物体的材料与质感：光滑度，透明度，反射率，发光度等，由Texture+Shader</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><a href=\"https://onevcat.com/2013/07/shader-tutorial-1/\" target=\"_blank\" rel=\"noopener\">Shader</a></td>\n<td style=\"text-align:left\">是一个脚本，将贴图，颜色，mesh进行mix，然后输出可绘制的单元</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Mesh</td>\n<td style=\"text-align:left\">物体的外形</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"http://docs.manew.com/Manual/index.htm\" target=\"_blank\" rel=\"noopener\">参考</a>      </p>\n<p>着色器(Shader)可定义以下事项：</p>\n<ul>\n<li>渲染对象的方法。这包括使用不同方法，具体取决于最终用户的图形卡。</li>\n<li>用于渲染的任何顶点照明和部分照明程序。</li>\n<li>材质 (Materials) 内可供分配的纹理属性。</li>\n<li>材质 (Materials) 内可供分配的颜色和数量设置。    </li>\n</ul>\n<p>材质 (Materials) 可定义：　　　</p>\n<ul>\n<li>渲染使用的纹理。　　</li>\n<li>渲染使用的颜色。　　</li>\n<li>任何其他资源，如着色器进行渲染所需的立方体贴图 (Cubemap)。　　　</li>\n</ul>\n<p>着色器由图形程序员编写。程序员使用非常简单的 ShaderLab 语言创建着色器。但是，让着色器在各种不同图形卡上充分发挥其作用是一项复杂的工作，这需要对图形卡运行原理有非常全面地了解。</p>\n<h2 id=\"1-4-Unity线程，协程\"><a href=\"#1-4-Unity线程，协程\" class=\"headerlink\" title=\"1.4 Unity线程，协程\"></a>1.4 Unity线程，协程</h2><h3 id=\"unity是一个单线程引擎，主要原因是UnityEngine相关SDK只能在主线程中跑\"><a href=\"#unity是一个单线程引擎，主要原因是UnityEngine相关SDK只能在主线程中跑\" class=\"headerlink\" title=\"unity是一个单线程引擎，主要原因是UnityEngine相关SDK只能在主线程中跑\"></a>unity是一个单线程引擎，主要原因是UnityEngine相关SDK只能在主线程中跑</h3><p>协程：   </p>\n<ul>\n<li>yield; 在下一帧上调用所有 Update 函数后，协同程序将继续运行。</li>\n<li>yield WaitForSeconds(2); 在指定的时间延迟之后，为此帧调用所有 Update 函数之后继续运行</li>\n<li>yield WaitForFixedUpdate(); 在所有脚本上调用所有 FixedUpdate 后继续运行</li>\n<li>yield WWW 完成 WWW 下载后继续运行。</li>\n<li>yield StartCoroutine(MyFunc); 连接协同程序，并等待 MyFunc coroutine 首先结束。</li>\n</ul>\n<h2 id=\"1-5-Unity-Life-Cycle\"><a href=\"#1-5-Unity-Life-Cycle\" class=\"headerlink\" title=\"1.5 Unity Life Cycle\"></a>1.5 Unity Life Cycle</h2><p><img src=\"https://docs.unity3d.com/uploads/Main/monobehaviour_flowchart.svg\" alt=\"img\">  </p>\n<h2 id=\"1-6-Unity坐标系\"><a href=\"#1-6-Unity坐标系\" class=\"headerlink\" title=\"1.6 Unity坐标系\"></a>1.6 Unity坐标系</h2><p><img src=\"http://answers.unity3d.com/storage/temp/8053-spaces.jpg\" alt=\"img\">   </p>\n<h2 id=\"1-7-iOS编译问题\"><a href=\"#1-7-iOS编译问题\" class=\"headerlink\" title=\"1.7 iOS编译问题\"></a>1.7 iOS编译问题</h2><p>从Unity导出iOS工程时需要注意是否使用了一些JIT(just in time compiler)特性的语法（例如C# Linq的排序）。因为iOS编译是AOT((Ahead-Of-Time，静态编译)不支持动态编译。</p>\n<h1 id=\"二、实践\"><a href=\"#二、实践\" class=\"headerlink\" title=\"二、实践\"></a>二、实践</h1><h2 id=\"2-1-Unity使用DLL（动态链接库）\"><a href=\"#2-1-Unity使用DLL（动态链接库）\" class=\"headerlink\" title=\"2.1 Unity使用DLL（动态链接库）\"></a>2.1 Unity使用DLL（动态链接库）</h2><h3 id=\"2-1-1、-生成DLL\"><a href=\"#2-1-1、-生成DLL\" class=\"headerlink\" title=\"2.1.1、 生成DLL\"></a>2.1.1、 生成DLL</h3><p>DLL的生成是需要借助于VS的，Unity自己是无法做到的。    </p>\n<ul>\n<li><p>新建C#<strong>类库项目</strong>，注意项目类型必须是类库项目</p>\n</li>\n<li><p>编写代码，与正常开发无异</p>\n</li>\n<li>将项目属性 -&gt; 应用程序 -&gt; 目标框架：改为<code>.NET Framework 3.5</code>或以下 。这一步很重要，因为Unity3D（当前的Unity3D版本是3.5版） 支持的 .Net 是3.5版。</li>\n</ul>\n<p>然后run一下就会生成一个DLL库</p>\n<h3 id=\"2-1-2、Unity使用DLL\"><a href=\"#2-1-2、Unity使用DLL\" class=\"headerlink\" title=\"2.1.2、Unity使用DLL\"></a>2.1.2、Unity使用DLL</h3><p>Unity使用DLL就相当简单了，只需要将DLL拖入Unity工程随便什么目录都可以，一般是放置到Plugin目录下。然后，C#就可以正常使用DLL中的代码。</p>"},{"title":"SWIFT编程","date":"2017-05-07T12:18:41.000Z","_content":"    \n\n> Swift学习与编程笔记\n\n<!--More-->    \n\n# 一、基础知识\n\n## 1.1 Swift单例\n\n原理都是通过类属性实现，访问时通过类直接获取。\n\n\t\t//MARK: 单例2\n\t\tlet instance = Singleton()\n\t\tclass Singleton {\n\t\t\t//MARK: 单例1\n\t\t\tstatic let sharedInstance = Singleton()\n\t\t\n\t\t\t//MARK: 单例2 \n\t\t\tclass var sharedInstance2: Singleton {\n\t\t\t\treturn instance\n\t\t\t}\n\t\t\n\t\t\t//MARK: 单例3\n\t\t\tstatic var shareInstance3:Single{\n\t\t        struct MyStatic{\n\t\t            static var instance :Single = Single()\n\t\t        }\n\t\t        return MyStatic.instance;\n\t\t    }\n\t\t}\n\n**Caution:跨模块（framework）使用时Xcode不会提示相应类属性，手动写上即可；另外，`let`是线程安全的**     \n\n## 1.2、构造函数\n### 1.2.1 在构造函数里可以对常量进行修改，一旦修改后这个值就不会变了\n\n\t\tclass test {\n\t\t    let text: String\n\t\t    init(text: String) {\n\t\t        self.text = text\n\t\t    }\n\t\t}\n\n\n### 1.2.2 系统合成构造函数主要包括两种：默认构造函数（不用多说），逐一赋值构造函数（结构体，类类型是没有的）\n\t\t\t\t\n\t\tstruct Size {\n\t\t    var width = 0.0, height = 0.0\n\t\t}\n\t\tlet zhuyi = Size(width: 2.0, height: 2.0)\n\n### 1.2.2 两段式构造\n+ 第一个阶段，每个存储型属性被引入它们的类指定一个初始值。当每个存储型属性的初始值被确定后;  \n+ 第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。\n\n### 1.2.3 指定构造器，便利构造器\n+ **指定构造器**是类必须有的至少一个。可以通过继承了父类中的指定构造器而满足了这个条件\n\n\t\tclass test {\n\t\t\tinit(parametes)\n\t\t}\n\n+ **便利构造器**是类中比较次要的、辅助型的构造器。  \n\n\t\t class test {\n\t\t\tconvenience  init(parametes)\n\t\t\t}   \n两者的关系如下图：   \n![img](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation01_2x.png)     \n**1.指定构造器必须向上也就是父类继续**   \n**2.便利构造器必须横向向指定构造器依赖，也就是便利构造器必须导致一个指定构造器被调用**  \n\n\n+ 便利构造器不能直接调用父类的便利构造器\n+ 构造器的自动继承    \n子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。\n \t+ 子类中引入的所有新属性都提供了默认值\n \t+ 如果子类没有定义任何**指定构造器**，它将自动继承所有父类的**指定构造器**。（OC继承；C++不继承）\n \t+ 如果子类提供了所有父类**指定构造器**的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承所有父类的**便利构造器**。\n \t+ 子类可以将父类的**指定构造器**重写为**便利构造器**\n \t\n\n+ demo:\n \n\t\tclass Food {\n\t\t    var name: String\n\t\t    init(name: String) {//指定构造器\n\t\t        self.name = name\n\t\t    }\n\t\t    convenience init() {//便利构造器， 符合横向代理原则：调用指定构造器\n\t\t        self.init(name: \"[Unnamed]\")\n\t\t    }\n\t\t}\n\t\t\n\t\t//继承\n\t\tclass RecipeIngredient: Food {\n\t\t    var quantity: Int//新增属性\n\t\t    init(name: String, quantity: Int) {\n\t\t\t\t//符合两段式构造第一阶段，给属性一个初始化值\n\t\t        self.quantity = quantity//应该不可以访问self\n\t\t        super.init(name: name)//还是处于第一阶段，初始化父类部分属性\n\t\t\t\t\n\t\t    }\n\t\t\t//子类的便利构造器与父类的指定构造器匹配，因些也算重写所以加上 override\n\t\t    override convenience init(name: String) {\n\t\t        self.init(name: name, quantity: 1)//调用指定构造器\n\t\t    }\n\t\t\t\n\t\t\t//由于子类实现了父类的所有指定构造器，所以子类便继承了父类的便利构造器\n\t\t\t//convenience init() {\n\t\t\t//\t\t self.init(name: \"[Unnamed]\")\n\t\t\t// }\n\t\t}\n\t\t\n\t\t//子类没有构造器，所以继承所有的父类构造器\n\t\tclass ShoppingListItem: RecipeIngredient {\n\t\t    var purchased = false\n\t\t    var description: String {\n\t\t        var output = \"\\(quantity) x \\(name)\"\n\t\t        output += purchased ? \" ✔\" : \" ✘\"\n\t\t        return output\n\t\t    }\n\t\t}\n\n\n## 1.3 函数 & 闭包\n### 1.3.1 函数\n+ 引用形参`inout`,作用与C中的引用是一样的作用，然后在调用时使用`&`传值\n+ 函数类型（闭包），swift中函数也是一种类型，就是通过参数列表及返回值来定义一个函数类型的，例如：\n\t\n\t\tvar myFunc: (Int, Int)-> Int\n+ 函数形参与标签，如果函数定义时没有标签时形参名就是标签   \n\n\t\tfunc test(number:Int, number1:Int)->Void\n\n### 1.3.2 闭包其实就是代码块，与OC中的block类似。闭包表达式语法：\n\n\t{ (parametees) -> returnType in\n\t\t//statements\n\t\t\n\t}\n\n闭包的函数体由关键字`in`引入\n\n### 1.3.3 闭包“逃逸”\n所设置的闭包逃逸是指这个闭包是要函数执行完成后再去执行的，也就是异步执行的回调。在函数声明是需要在闭包入参之前添加关键字`@escaping`\n，因为逃逸了所以如果访问成员时需要添加`self`。\n## 1.4 类型转换，检查\n### 1.4.1 swift类型转主要通过两个操作符：`as?`与`as!`。`as?`表示转换时可能失败返回nil,`as!`类型转换表示一定会转换成功并强解引用\n### 1.4.2 swift类型检查操作符：`is`。\n\n# 二、Swift混编\n## 2.1 Swift 与 OC 混编\n### 2.1.1 OC调用Swift\nOC要调用Swift需要借助于`yourtargetname-swift.h`   \n \n+ 当我们在一个OC的工程中添加Swift语言Xcode会提示是否添加桥接文件；\n+ 创建Swift类，为了让OC能调用还需要在类前添加`@objc`表示Swift代码暴露给OC用；***注意：`@objc`是不可以将非继承`NSObject`转换成OC可调用的对象***\n+ 但OC怎么使用Swift呢？这就需要`yourtargetname-swift.h`，这个头文件名可以要`target->Build Setting->Objective-C Generated Interface Header Name`。**需要注意的是这个头文件target中只有一个，而且是看不到的，它是会在编译时生成，如果模块是一个framework可能在生成的framework头文件里可以看到此文件**，代码如下：\n\n\t\t#import \"yourtargetname-swift.h\"\n\t\t\n\t\t...\t\t\n\t\tswiftclass *instance = [[swiftclass alloc]init];\n\t\n### 2.1.2 Swift调用OC\n\n+ Swift要调用OC需要借助于`yourproject-Bridging-Header.h`,在这个头文件里通过`import`相关OC库头文件，如：\n\n\t\t#import <GoogleMaps/GoogleMaps.h>\n\n\n**注意：**   \n\n+ **这个头文件Xcode会帮你生成，只要你在Swift工程添加OC类Xcode就会提示你是否需要生成这个文件。**\n+ **如果一个是在工程中创建了一个framework的target，此时系统会生成一个`yourtargetname.h`的文件，在这个头文件里通过`import`相关OC库头文件即可。**","source":"_posts/SWIFT编程.md","raw":"---\ntitle: SWIFT编程\ndate: 2017-05-07 20:18:41\ntags: [iOS, swift]\ncategories: iOS\n---\n    \n\n> Swift学习与编程笔记\n\n<!--More-->    \n\n# 一、基础知识\n\n## 1.1 Swift单例\n\n原理都是通过类属性实现，访问时通过类直接获取。\n\n\t\t//MARK: 单例2\n\t\tlet instance = Singleton()\n\t\tclass Singleton {\n\t\t\t//MARK: 单例1\n\t\t\tstatic let sharedInstance = Singleton()\n\t\t\n\t\t\t//MARK: 单例2 \n\t\t\tclass var sharedInstance2: Singleton {\n\t\t\t\treturn instance\n\t\t\t}\n\t\t\n\t\t\t//MARK: 单例3\n\t\t\tstatic var shareInstance3:Single{\n\t\t        struct MyStatic{\n\t\t            static var instance :Single = Single()\n\t\t        }\n\t\t        return MyStatic.instance;\n\t\t    }\n\t\t}\n\n**Caution:跨模块（framework）使用时Xcode不会提示相应类属性，手动写上即可；另外，`let`是线程安全的**     \n\n## 1.2、构造函数\n### 1.2.1 在构造函数里可以对常量进行修改，一旦修改后这个值就不会变了\n\n\t\tclass test {\n\t\t    let text: String\n\t\t    init(text: String) {\n\t\t        self.text = text\n\t\t    }\n\t\t}\n\n\n### 1.2.2 系统合成构造函数主要包括两种：默认构造函数（不用多说），逐一赋值构造函数（结构体，类类型是没有的）\n\t\t\t\t\n\t\tstruct Size {\n\t\t    var width = 0.0, height = 0.0\n\t\t}\n\t\tlet zhuyi = Size(width: 2.0, height: 2.0)\n\n### 1.2.2 两段式构造\n+ 第一个阶段，每个存储型属性被引入它们的类指定一个初始值。当每个存储型属性的初始值被确定后;  \n+ 第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。\n\n### 1.2.3 指定构造器，便利构造器\n+ **指定构造器**是类必须有的至少一个。可以通过继承了父类中的指定构造器而满足了这个条件\n\n\t\tclass test {\n\t\t\tinit(parametes)\n\t\t}\n\n+ **便利构造器**是类中比较次要的、辅助型的构造器。  \n\n\t\t class test {\n\t\t\tconvenience  init(parametes)\n\t\t\t}   \n两者的关系如下图：   \n![img](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation01_2x.png)     \n**1.指定构造器必须向上也就是父类继续**   \n**2.便利构造器必须横向向指定构造器依赖，也就是便利构造器必须导致一个指定构造器被调用**  \n\n\n+ 便利构造器不能直接调用父类的便利构造器\n+ 构造器的自动继承    \n子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。\n \t+ 子类中引入的所有新属性都提供了默认值\n \t+ 如果子类没有定义任何**指定构造器**，它将自动继承所有父类的**指定构造器**。（OC继承；C++不继承）\n \t+ 如果子类提供了所有父类**指定构造器**的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承所有父类的**便利构造器**。\n \t+ 子类可以将父类的**指定构造器**重写为**便利构造器**\n \t\n\n+ demo:\n \n\t\tclass Food {\n\t\t    var name: String\n\t\t    init(name: String) {//指定构造器\n\t\t        self.name = name\n\t\t    }\n\t\t    convenience init() {//便利构造器， 符合横向代理原则：调用指定构造器\n\t\t        self.init(name: \"[Unnamed]\")\n\t\t    }\n\t\t}\n\t\t\n\t\t//继承\n\t\tclass RecipeIngredient: Food {\n\t\t    var quantity: Int//新增属性\n\t\t    init(name: String, quantity: Int) {\n\t\t\t\t//符合两段式构造第一阶段，给属性一个初始化值\n\t\t        self.quantity = quantity//应该不可以访问self\n\t\t        super.init(name: name)//还是处于第一阶段，初始化父类部分属性\n\t\t\t\t\n\t\t    }\n\t\t\t//子类的便利构造器与父类的指定构造器匹配，因些也算重写所以加上 override\n\t\t    override convenience init(name: String) {\n\t\t        self.init(name: name, quantity: 1)//调用指定构造器\n\t\t    }\n\t\t\t\n\t\t\t//由于子类实现了父类的所有指定构造器，所以子类便继承了父类的便利构造器\n\t\t\t//convenience init() {\n\t\t\t//\t\t self.init(name: \"[Unnamed]\")\n\t\t\t// }\n\t\t}\n\t\t\n\t\t//子类没有构造器，所以继承所有的父类构造器\n\t\tclass ShoppingListItem: RecipeIngredient {\n\t\t    var purchased = false\n\t\t    var description: String {\n\t\t        var output = \"\\(quantity) x \\(name)\"\n\t\t        output += purchased ? \" ✔\" : \" ✘\"\n\t\t        return output\n\t\t    }\n\t\t}\n\n\n## 1.3 函数 & 闭包\n### 1.3.1 函数\n+ 引用形参`inout`,作用与C中的引用是一样的作用，然后在调用时使用`&`传值\n+ 函数类型（闭包），swift中函数也是一种类型，就是通过参数列表及返回值来定义一个函数类型的，例如：\n\t\n\t\tvar myFunc: (Int, Int)-> Int\n+ 函数形参与标签，如果函数定义时没有标签时形参名就是标签   \n\n\t\tfunc test(number:Int, number1:Int)->Void\n\n### 1.3.2 闭包其实就是代码块，与OC中的block类似。闭包表达式语法：\n\n\t{ (parametees) -> returnType in\n\t\t//statements\n\t\t\n\t}\n\n闭包的函数体由关键字`in`引入\n\n### 1.3.3 闭包“逃逸”\n所设置的闭包逃逸是指这个闭包是要函数执行完成后再去执行的，也就是异步执行的回调。在函数声明是需要在闭包入参之前添加关键字`@escaping`\n，因为逃逸了所以如果访问成员时需要添加`self`。\n## 1.4 类型转换，检查\n### 1.4.1 swift类型转主要通过两个操作符：`as?`与`as!`。`as?`表示转换时可能失败返回nil,`as!`类型转换表示一定会转换成功并强解引用\n### 1.4.2 swift类型检查操作符：`is`。\n\n# 二、Swift混编\n## 2.1 Swift 与 OC 混编\n### 2.1.1 OC调用Swift\nOC要调用Swift需要借助于`yourtargetname-swift.h`   \n \n+ 当我们在一个OC的工程中添加Swift语言Xcode会提示是否添加桥接文件；\n+ 创建Swift类，为了让OC能调用还需要在类前添加`@objc`表示Swift代码暴露给OC用；***注意：`@objc`是不可以将非继承`NSObject`转换成OC可调用的对象***\n+ 但OC怎么使用Swift呢？这就需要`yourtargetname-swift.h`，这个头文件名可以要`target->Build Setting->Objective-C Generated Interface Header Name`。**需要注意的是这个头文件target中只有一个，而且是看不到的，它是会在编译时生成，如果模块是一个framework可能在生成的framework头文件里可以看到此文件**，代码如下：\n\n\t\t#import \"yourtargetname-swift.h\"\n\t\t\n\t\t...\t\t\n\t\tswiftclass *instance = [[swiftclass alloc]init];\n\t\n### 2.1.2 Swift调用OC\n\n+ Swift要调用OC需要借助于`yourproject-Bridging-Header.h`,在这个头文件里通过`import`相关OC库头文件，如：\n\n\t\t#import <GoogleMaps/GoogleMaps.h>\n\n\n**注意：**   \n\n+ **这个头文件Xcode会帮你生成，只要你在Swift工程添加OC类Xcode就会提示你是否需要生成这个文件。**\n+ **如果一个是在工程中创建了一个framework的target，此时系统会生成一个`yourtargetname.h`的文件，在这个头文件里通过`import`相关OC库头文件即可。**","slug":"SWIFT编程","published":1,"updated":"2022-06-15T07:23:15.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4fa2s9y0009daconl71c7rh","content":"<blockquote>\n<p>Swift学习与编程笔记</p>\n</blockquote>\n<a id=\"more\"></a>    \n<h1 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h1><h2 id=\"1-1-Swift单例\"><a href=\"#1-1-Swift单例\" class=\"headerlink\" title=\"1.1 Swift单例\"></a>1.1 Swift单例</h2><p>原理都是通过类属性实现，访问时通过类直接获取。</p>\n<pre><code>//MARK: 单例2\nlet instance = Singleton()\nclass Singleton {\n    //MARK: 单例1\n    static let sharedInstance = Singleton()\n\n    //MARK: 单例2 \n    class var sharedInstance2: Singleton {\n        return instance\n    }\n\n    //MARK: 单例3\n    static var shareInstance3:Single{\n        struct MyStatic{\n            static var instance :Single = Single()\n        }\n        return MyStatic.instance;\n    }\n}\n</code></pre><p><strong>Caution:跨模块（framework）使用时Xcode不会提示相应类属性，手动写上即可；另外，<code>let</code>是线程安全的</strong>     </p>\n<h2 id=\"1-2、构造函数\"><a href=\"#1-2、构造函数\" class=\"headerlink\" title=\"1.2、构造函数\"></a>1.2、构造函数</h2><h3 id=\"1-2-1-在构造函数里可以对常量进行修改，一旦修改后这个值就不会变了\"><a href=\"#1-2-1-在构造函数里可以对常量进行修改，一旦修改后这个值就不会变了\" class=\"headerlink\" title=\"1.2.1 在构造函数里可以对常量进行修改，一旦修改后这个值就不会变了\"></a>1.2.1 在构造函数里可以对常量进行修改，一旦修改后这个值就不会变了</h3><pre><code>class test {\n    let text: String\n    init(text: String) {\n        self.text = text\n    }\n}\n</code></pre><h3 id=\"1-2-2-系统合成构造函数主要包括两种：默认构造函数（不用多说），逐一赋值构造函数（结构体，类类型是没有的）\"><a href=\"#1-2-2-系统合成构造函数主要包括两种：默认构造函数（不用多说），逐一赋值构造函数（结构体，类类型是没有的）\" class=\"headerlink\" title=\"1.2.2 系统合成构造函数主要包括两种：默认构造函数（不用多说），逐一赋值构造函数（结构体，类类型是没有的）\"></a>1.2.2 系统合成构造函数主要包括两种：默认构造函数（不用多说），逐一赋值构造函数（结构体，类类型是没有的）</h3><pre><code>struct Size {\n    var width = 0.0, height = 0.0\n}\nlet zhuyi = Size(width: 2.0, height: 2.0)\n</code></pre><h3 id=\"1-2-2-两段式构造\"><a href=\"#1-2-2-两段式构造\" class=\"headerlink\" title=\"1.2.2 两段式构造\"></a>1.2.2 两段式构造</h3><ul>\n<li>第一个阶段，每个存储型属性被引入它们的类指定一个初始值。当每个存储型属性的初始值被确定后;  </li>\n<li>第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。</li>\n</ul>\n<h3 id=\"1-2-3-指定构造器，便利构造器\"><a href=\"#1-2-3-指定构造器，便利构造器\" class=\"headerlink\" title=\"1.2.3 指定构造器，便利构造器\"></a>1.2.3 指定构造器，便利构造器</h3><ul>\n<li><p><strong>指定构造器</strong>是类必须有的至少一个。可以通过继承了父类中的指定构造器而满足了这个条件</p>\n<pre><code>class test {\n    init(parametes)\n}\n</code></pre></li>\n<li><p><strong>便利构造器</strong>是类中比较次要的、辅助型的构造器。  </p>\n<pre><code>class test {\n   convenience  init(parametes)\n   }   \n</code></pre><p>两者的关系如下图：<br><img src=\"https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation01_2x.png\" alt=\"img\"><br><strong>1.指定构造器必须向上也就是父类继续</strong><br><strong>2.便利构造器必须横向向指定构造器依赖，也就是便利构造器必须导致一个指定构造器被调用</strong>  </p>\n</li>\n</ul>\n<ul>\n<li>便利构造器不能直接调用父类的便利构造器</li>\n<li>构造器的自动继承<br>子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。<ul>\n<li>子类中引入的所有新属性都提供了默认值</li>\n<li>如果子类没有定义任何<strong>指定构造器</strong>，它将自动继承所有父类的<strong>指定构造器</strong>。（OC继承；C++不继承）</li>\n<li>如果子类提供了所有父类<strong>指定构造器</strong>的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承所有父类的<strong>便利构造器</strong>。</li>\n<li>子类可以将父类的<strong>指定构造器</strong>重写为<strong>便利构造器</strong></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>demo:</p>\n<pre><code>class Food {\n    var name: String\n    init(name: String) {//指定构造器\n        self.name = name\n    }\n    convenience init() {//便利构造器， 符合横向代理原则：调用指定构造器\n        self.init(name: &quot;[Unnamed]&quot;)\n    }\n}\n\n//继承\nclass RecipeIngredient: Food {\n    var quantity: Int//新增属性\n    init(name: String, quantity: Int) {\n        //符合两段式构造第一阶段，给属性一个初始化值\n        self.quantity = quantity//应该不可以访问self\n        super.init(name: name)//还是处于第一阶段，初始化父类部分属性\n\n    }\n    //子类的便利构造器与父类的指定构造器匹配，因些也算重写所以加上 override\n    override convenience init(name: String) {\n        self.init(name: name, quantity: 1)//调用指定构造器\n    }\n\n    //由于子类实现了父类的所有指定构造器，所以子类便继承了父类的便利构造器\n    //convenience init() {\n    //         self.init(name: &quot;[Unnamed]&quot;)\n    // }\n}\n\n//子类没有构造器，所以继承所有的父类构造器\nclass ShoppingListItem: RecipeIngredient {\n    var purchased = false\n    var description: String {\n        var output = &quot;\\(quantity) x \\(name)&quot;\n        output += purchased ? &quot; ✔&quot; : &quot; ✘&quot;\n        return output\n    }\n}\n</code></pre></li>\n</ul>\n<h2 id=\"1-3-函数-amp-闭包\"><a href=\"#1-3-函数-amp-闭包\" class=\"headerlink\" title=\"1.3 函数 &amp; 闭包\"></a>1.3 函数 &amp; 闭包</h2><h3 id=\"1-3-1-函数\"><a href=\"#1-3-1-函数\" class=\"headerlink\" title=\"1.3.1 函数\"></a>1.3.1 函数</h3><ul>\n<li>引用形参<code>inout</code>,作用与C中的引用是一样的作用，然后在调用时使用<code>&amp;</code>传值</li>\n<li><p>函数类型（闭包），swift中函数也是一种类型，就是通过参数列表及返回值来定义一个函数类型的，例如：</p>\n<pre><code>var myFunc: (Int, Int)-&gt; Int\n</code></pre></li>\n<li><p>函数形参与标签，如果函数定义时没有标签时形参名就是标签   </p>\n<pre><code>func test(number:Int, number1:Int)-&gt;Void\n</code></pre></li>\n</ul>\n<h3 id=\"1-3-2-闭包其实就是代码块，与OC中的block类似。闭包表达式语法：\"><a href=\"#1-3-2-闭包其实就是代码块，与OC中的block类似。闭包表达式语法：\" class=\"headerlink\" title=\"1.3.2 闭包其实就是代码块，与OC中的block类似。闭包表达式语法：\"></a>1.3.2 闭包其实就是代码块，与OC中的block类似。闭包表达式语法：</h3><pre><code>{ (parametees) -&gt; returnType in\n    //statements\n\n}\n</code></pre><p>闭包的函数体由关键字<code>in</code>引入</p>\n<h3 id=\"1-3-3-闭包“逃逸”\"><a href=\"#1-3-3-闭包“逃逸”\" class=\"headerlink\" title=\"1.3.3 闭包“逃逸”\"></a>1.3.3 闭包“逃逸”</h3><p>所设置的闭包逃逸是指这个闭包是要函数执行完成后再去执行的，也就是异步执行的回调。在函数声明是需要在闭包入参之前添加关键字<code>@escaping</code><br>，因为逃逸了所以如果访问成员时需要添加<code>self</code>。</p>\n<h2 id=\"1-4-类型转换，检查\"><a href=\"#1-4-类型转换，检查\" class=\"headerlink\" title=\"1.4 类型转换，检查\"></a>1.4 类型转换，检查</h2><h3 id=\"1-4-1-swift类型转主要通过两个操作符：as-与as-。as-表示转换时可能失败返回nil-as-类型转换表示一定会转换成功并强解引用\"><a href=\"#1-4-1-swift类型转主要通过两个操作符：as-与as-。as-表示转换时可能失败返回nil-as-类型转换表示一定会转换成功并强解引用\" class=\"headerlink\" title=\"1.4.1 swift类型转主要通过两个操作符：as?与as!。as?表示转换时可能失败返回nil,as!类型转换表示一定会转换成功并强解引用\"></a>1.4.1 swift类型转主要通过两个操作符：<code>as?</code>与<code>as!</code>。<code>as?</code>表示转换时可能失败返回nil,<code>as!</code>类型转换表示一定会转换成功并强解引用</h3><h3 id=\"1-4-2-swift类型检查操作符：is。\"><a href=\"#1-4-2-swift类型检查操作符：is。\" class=\"headerlink\" title=\"1.4.2 swift类型检查操作符：is。\"></a>1.4.2 swift类型检查操作符：<code>is</code>。</h3><h1 id=\"二、Swift混编\"><a href=\"#二、Swift混编\" class=\"headerlink\" title=\"二、Swift混编\"></a>二、Swift混编</h1><h2 id=\"2-1-Swift-与-OC-混编\"><a href=\"#2-1-Swift-与-OC-混编\" class=\"headerlink\" title=\"2.1 Swift 与 OC 混编\"></a>2.1 Swift 与 OC 混编</h2><h3 id=\"2-1-1-OC调用Swift\"><a href=\"#2-1-1-OC调用Swift\" class=\"headerlink\" title=\"2.1.1 OC调用Swift\"></a>2.1.1 OC调用Swift</h3><p>OC要调用Swift需要借助于<code>yourtargetname-swift.h</code>   </p>\n<ul>\n<li>当我们在一个OC的工程中添加Swift语言Xcode会提示是否添加桥接文件；</li>\n<li>创建Swift类，为了让OC能调用还需要在类前添加<code>@objc</code>表示Swift代码暴露给OC用；<strong><em>注意：<code>@objc</code>是不可以将非继承<code>NSObject</code>转换成OC可调用的对象</em></strong></li>\n<li><p>但OC怎么使用Swift呢？这就需要<code>yourtargetname-swift.h</code>，这个头文件名可以要<code>target-&gt;Build Setting-&gt;Objective-C Generated Interface Header Name</code>。<strong>需要注意的是这个头文件target中只有一个，而且是看不到的，它是会在编译时生成，如果模块是一个framework可能在生成的framework头文件里可以看到此文件</strong>，代码如下：</p>\n<pre><code>#import &quot;yourtargetname-swift.h&quot;\n\n...        \nswiftclass *instance = [[swiftclass alloc]init];\n</code></pre></li>\n</ul>\n<h3 id=\"2-1-2-Swift调用OC\"><a href=\"#2-1-2-Swift调用OC\" class=\"headerlink\" title=\"2.1.2 Swift调用OC\"></a>2.1.2 Swift调用OC</h3><ul>\n<li><p>Swift要调用OC需要借助于<code>yourproject-Bridging-Header.h</code>,在这个头文件里通过<code>import</code>相关OC库头文件，如：</p>\n<pre><code>#import &lt;GoogleMaps/GoogleMaps.h&gt;\n</code></pre></li>\n</ul>\n<p><strong>注意：</strong>   </p>\n<ul>\n<li><strong>这个头文件Xcode会帮你生成，只要你在Swift工程添加OC类Xcode就会提示你是否需要生成这个文件。</strong></li>\n<li><strong>如果一个是在工程中创建了一个framework的target，此时系统会生成一个<code>yourtargetname.h</code>的文件，在这个头文件里通过<code>import</code>相关OC库头文件即可。</strong></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Swift学习与编程笔记</p>\n</blockquote>","more":"<h1 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h1><h2 id=\"1-1-Swift单例\"><a href=\"#1-1-Swift单例\" class=\"headerlink\" title=\"1.1 Swift单例\"></a>1.1 Swift单例</h2><p>原理都是通过类属性实现，访问时通过类直接获取。</p>\n<pre><code>//MARK: 单例2\nlet instance = Singleton()\nclass Singleton {\n    //MARK: 单例1\n    static let sharedInstance = Singleton()\n\n    //MARK: 单例2 \n    class var sharedInstance2: Singleton {\n        return instance\n    }\n\n    //MARK: 单例3\n    static var shareInstance3:Single{\n        struct MyStatic{\n            static var instance :Single = Single()\n        }\n        return MyStatic.instance;\n    }\n}\n</code></pre><p><strong>Caution:跨模块（framework）使用时Xcode不会提示相应类属性，手动写上即可；另外，<code>let</code>是线程安全的</strong>     </p>\n<h2 id=\"1-2、构造函数\"><a href=\"#1-2、构造函数\" class=\"headerlink\" title=\"1.2、构造函数\"></a>1.2、构造函数</h2><h3 id=\"1-2-1-在构造函数里可以对常量进行修改，一旦修改后这个值就不会变了\"><a href=\"#1-2-1-在构造函数里可以对常量进行修改，一旦修改后这个值就不会变了\" class=\"headerlink\" title=\"1.2.1 在构造函数里可以对常量进行修改，一旦修改后这个值就不会变了\"></a>1.2.1 在构造函数里可以对常量进行修改，一旦修改后这个值就不会变了</h3><pre><code>class test {\n    let text: String\n    init(text: String) {\n        self.text = text\n    }\n}\n</code></pre><h3 id=\"1-2-2-系统合成构造函数主要包括两种：默认构造函数（不用多说），逐一赋值构造函数（结构体，类类型是没有的）\"><a href=\"#1-2-2-系统合成构造函数主要包括两种：默认构造函数（不用多说），逐一赋值构造函数（结构体，类类型是没有的）\" class=\"headerlink\" title=\"1.2.2 系统合成构造函数主要包括两种：默认构造函数（不用多说），逐一赋值构造函数（结构体，类类型是没有的）\"></a>1.2.2 系统合成构造函数主要包括两种：默认构造函数（不用多说），逐一赋值构造函数（结构体，类类型是没有的）</h3><pre><code>struct Size {\n    var width = 0.0, height = 0.0\n}\nlet zhuyi = Size(width: 2.0, height: 2.0)\n</code></pre><h3 id=\"1-2-2-两段式构造\"><a href=\"#1-2-2-两段式构造\" class=\"headerlink\" title=\"1.2.2 两段式构造\"></a>1.2.2 两段式构造</h3><ul>\n<li>第一个阶段，每个存储型属性被引入它们的类指定一个初始值。当每个存储型属性的初始值被确定后;  </li>\n<li>第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。</li>\n</ul>\n<h3 id=\"1-2-3-指定构造器，便利构造器\"><a href=\"#1-2-3-指定构造器，便利构造器\" class=\"headerlink\" title=\"1.2.3 指定构造器，便利构造器\"></a>1.2.3 指定构造器，便利构造器</h3><ul>\n<li><p><strong>指定构造器</strong>是类必须有的至少一个。可以通过继承了父类中的指定构造器而满足了这个条件</p>\n<pre><code>class test {\n    init(parametes)\n}\n</code></pre></li>\n<li><p><strong>便利构造器</strong>是类中比较次要的、辅助型的构造器。  </p>\n<pre><code>class test {\n   convenience  init(parametes)\n   }   \n</code></pre><p>两者的关系如下图：<br><img src=\"https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation01_2x.png\" alt=\"img\"><br><strong>1.指定构造器必须向上也就是父类继续</strong><br><strong>2.便利构造器必须横向向指定构造器依赖，也就是便利构造器必须导致一个指定构造器被调用</strong>  </p>\n</li>\n</ul>\n<ul>\n<li>便利构造器不能直接调用父类的便利构造器</li>\n<li>构造器的自动继承<br>子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。<ul>\n<li>子类中引入的所有新属性都提供了默认值</li>\n<li>如果子类没有定义任何<strong>指定构造器</strong>，它将自动继承所有父类的<strong>指定构造器</strong>。（OC继承；C++不继承）</li>\n<li>如果子类提供了所有父类<strong>指定构造器</strong>的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承所有父类的<strong>便利构造器</strong>。</li>\n<li>子类可以将父类的<strong>指定构造器</strong>重写为<strong>便利构造器</strong></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>demo:</p>\n<pre><code>class Food {\n    var name: String\n    init(name: String) {//指定构造器\n        self.name = name\n    }\n    convenience init() {//便利构造器， 符合横向代理原则：调用指定构造器\n        self.init(name: &quot;[Unnamed]&quot;)\n    }\n}\n\n//继承\nclass RecipeIngredient: Food {\n    var quantity: Int//新增属性\n    init(name: String, quantity: Int) {\n        //符合两段式构造第一阶段，给属性一个初始化值\n        self.quantity = quantity//应该不可以访问self\n        super.init(name: name)//还是处于第一阶段，初始化父类部分属性\n\n    }\n    //子类的便利构造器与父类的指定构造器匹配，因些也算重写所以加上 override\n    override convenience init(name: String) {\n        self.init(name: name, quantity: 1)//调用指定构造器\n    }\n\n    //由于子类实现了父类的所有指定构造器，所以子类便继承了父类的便利构造器\n    //convenience init() {\n    //         self.init(name: &quot;[Unnamed]&quot;)\n    // }\n}\n\n//子类没有构造器，所以继承所有的父类构造器\nclass ShoppingListItem: RecipeIngredient {\n    var purchased = false\n    var description: String {\n        var output = &quot;\\(quantity) x \\(name)&quot;\n        output += purchased ? &quot; ✔&quot; : &quot; ✘&quot;\n        return output\n    }\n}\n</code></pre></li>\n</ul>\n<h2 id=\"1-3-函数-amp-闭包\"><a href=\"#1-3-函数-amp-闭包\" class=\"headerlink\" title=\"1.3 函数 &amp; 闭包\"></a>1.3 函数 &amp; 闭包</h2><h3 id=\"1-3-1-函数\"><a href=\"#1-3-1-函数\" class=\"headerlink\" title=\"1.3.1 函数\"></a>1.3.1 函数</h3><ul>\n<li>引用形参<code>inout</code>,作用与C中的引用是一样的作用，然后在调用时使用<code>&amp;</code>传值</li>\n<li><p>函数类型（闭包），swift中函数也是一种类型，就是通过参数列表及返回值来定义一个函数类型的，例如：</p>\n<pre><code>var myFunc: (Int, Int)-&gt; Int\n</code></pre></li>\n<li><p>函数形参与标签，如果函数定义时没有标签时形参名就是标签   </p>\n<pre><code>func test(number:Int, number1:Int)-&gt;Void\n</code></pre></li>\n</ul>\n<h3 id=\"1-3-2-闭包其实就是代码块，与OC中的block类似。闭包表达式语法：\"><a href=\"#1-3-2-闭包其实就是代码块，与OC中的block类似。闭包表达式语法：\" class=\"headerlink\" title=\"1.3.2 闭包其实就是代码块，与OC中的block类似。闭包表达式语法：\"></a>1.3.2 闭包其实就是代码块，与OC中的block类似。闭包表达式语法：</h3><pre><code>{ (parametees) -&gt; returnType in\n    //statements\n\n}\n</code></pre><p>闭包的函数体由关键字<code>in</code>引入</p>\n<h3 id=\"1-3-3-闭包“逃逸”\"><a href=\"#1-3-3-闭包“逃逸”\" class=\"headerlink\" title=\"1.3.3 闭包“逃逸”\"></a>1.3.3 闭包“逃逸”</h3><p>所设置的闭包逃逸是指这个闭包是要函数执行完成后再去执行的，也就是异步执行的回调。在函数声明是需要在闭包入参之前添加关键字<code>@escaping</code><br>，因为逃逸了所以如果访问成员时需要添加<code>self</code>。</p>\n<h2 id=\"1-4-类型转换，检查\"><a href=\"#1-4-类型转换，检查\" class=\"headerlink\" title=\"1.4 类型转换，检查\"></a>1.4 类型转换，检查</h2><h3 id=\"1-4-1-swift类型转主要通过两个操作符：as-与as-。as-表示转换时可能失败返回nil-as-类型转换表示一定会转换成功并强解引用\"><a href=\"#1-4-1-swift类型转主要通过两个操作符：as-与as-。as-表示转换时可能失败返回nil-as-类型转换表示一定会转换成功并强解引用\" class=\"headerlink\" title=\"1.4.1 swift类型转主要通过两个操作符：as?与as!。as?表示转换时可能失败返回nil,as!类型转换表示一定会转换成功并强解引用\"></a>1.4.1 swift类型转主要通过两个操作符：<code>as?</code>与<code>as!</code>。<code>as?</code>表示转换时可能失败返回nil,<code>as!</code>类型转换表示一定会转换成功并强解引用</h3><h3 id=\"1-4-2-swift类型检查操作符：is。\"><a href=\"#1-4-2-swift类型检查操作符：is。\" class=\"headerlink\" title=\"1.4.2 swift类型检查操作符：is。\"></a>1.4.2 swift类型检查操作符：<code>is</code>。</h3><h1 id=\"二、Swift混编\"><a href=\"#二、Swift混编\" class=\"headerlink\" title=\"二、Swift混编\"></a>二、Swift混编</h1><h2 id=\"2-1-Swift-与-OC-混编\"><a href=\"#2-1-Swift-与-OC-混编\" class=\"headerlink\" title=\"2.1 Swift 与 OC 混编\"></a>2.1 Swift 与 OC 混编</h2><h3 id=\"2-1-1-OC调用Swift\"><a href=\"#2-1-1-OC调用Swift\" class=\"headerlink\" title=\"2.1.1 OC调用Swift\"></a>2.1.1 OC调用Swift</h3><p>OC要调用Swift需要借助于<code>yourtargetname-swift.h</code>   </p>\n<ul>\n<li>当我们在一个OC的工程中添加Swift语言Xcode会提示是否添加桥接文件；</li>\n<li>创建Swift类，为了让OC能调用还需要在类前添加<code>@objc</code>表示Swift代码暴露给OC用；<strong><em>注意：<code>@objc</code>是不可以将非继承<code>NSObject</code>转换成OC可调用的对象</em></strong></li>\n<li><p>但OC怎么使用Swift呢？这就需要<code>yourtargetname-swift.h</code>，这个头文件名可以要<code>target-&gt;Build Setting-&gt;Objective-C Generated Interface Header Name</code>。<strong>需要注意的是这个头文件target中只有一个，而且是看不到的，它是会在编译时生成，如果模块是一个framework可能在生成的framework头文件里可以看到此文件</strong>，代码如下：</p>\n<pre><code>#import &quot;yourtargetname-swift.h&quot;\n\n...        \nswiftclass *instance = [[swiftclass alloc]init];\n</code></pre></li>\n</ul>\n<h3 id=\"2-1-2-Swift调用OC\"><a href=\"#2-1-2-Swift调用OC\" class=\"headerlink\" title=\"2.1.2 Swift调用OC\"></a>2.1.2 Swift调用OC</h3><ul>\n<li><p>Swift要调用OC需要借助于<code>yourproject-Bridging-Header.h</code>,在这个头文件里通过<code>import</code>相关OC库头文件，如：</p>\n<pre><code>#import &lt;GoogleMaps/GoogleMaps.h&gt;\n</code></pre></li>\n</ul>\n<p><strong>注意：</strong>   </p>\n<ul>\n<li><strong>这个头文件Xcode会帮你生成，只要你在Swift工程添加OC类Xcode就会提示你是否需要生成这个文件。</strong></li>\n<li><strong>如果一个是在工程中创建了一个framework的target，此时系统会生成一个<code>yourtargetname.h</code>的文件，在这个头文件里通过<code>import</code>相关OC库头文件即可。</strong></li>\n</ul>"},{"title":"git 使用手册","date":"2017-04-27T01:33:15.000Z","_content":"\n> git 使用手册\n\n<!-- More-->\n\n## 0、 示意图\n![image](http://image.beekka.com/blog/2014/bg2014061202.jpg)\n\n## 一、常用命令\n### 1、 删除版本库中的一个commit: `git reset --hard HEAD~1`\n### 2、 删除远程库中的一个commit: `git reset --hard HEAD~1`, `git push --force`\n### 3、 将本地分支推送到远程分支：`git push origin local_ branch:remote_ branch` ：这个操作，local_ branch必须为你本地存在的分支，remote_ branch为远程分支，如果remote_ branch不存在则会自动创建分支。\n### 4、将本地分支与远程分支建立对应关系：`git branch --set-upstream-to=origin/<branch> <remote>`  \n### 5、将本地分支删除：`git branch -d <branchName>`\n\n\n+ 注意如果处在当前分支是无法删除的需要切换到其它分支再删除。另外，不管它有没有merge使用`git branch -D <branchName>` \n\n\n### 6、如果对应outlook密码修改，则可以在目录`/Users/username/.ssh`下删除`id_rsa`和`id_rsa.pub`\n### 7、切换分支:`git checkout <branchname>`\n### 8、切换分支并创建本地分支:`git checkout -b <branchname>`   \n### 9、`git checkout origin/remoteName -b localName` 获取远程分支remoteName 到本地新分支localName，并跳到localName分支   \n### 10、`git checkoutremoteName` 获取远程分支remoteName 到本地并生成新分支remoteName，并跳到localName分支","source":"_posts/git-使用手册.md","raw":"---\ntitle: git 使用手册\ndate: 2017-04-27 09:33:15\ntags: [git,使用手册]\ncategories: git\n---\n\n> git 使用手册\n\n<!-- More-->\n\n## 0、 示意图\n![image](http://image.beekka.com/blog/2014/bg2014061202.jpg)\n\n## 一、常用命令\n### 1、 删除版本库中的一个commit: `git reset --hard HEAD~1`\n### 2、 删除远程库中的一个commit: `git reset --hard HEAD~1`, `git push --force`\n### 3、 将本地分支推送到远程分支：`git push origin local_ branch:remote_ branch` ：这个操作，local_ branch必须为你本地存在的分支，remote_ branch为远程分支，如果remote_ branch不存在则会自动创建分支。\n### 4、将本地分支与远程分支建立对应关系：`git branch --set-upstream-to=origin/<branch> <remote>`  \n### 5、将本地分支删除：`git branch -d <branchName>`\n\n\n+ 注意如果处在当前分支是无法删除的需要切换到其它分支再删除。另外，不管它有没有merge使用`git branch -D <branchName>` \n\n\n### 6、如果对应outlook密码修改，则可以在目录`/Users/username/.ssh`下删除`id_rsa`和`id_rsa.pub`\n### 7、切换分支:`git checkout <branchname>`\n### 8、切换分支并创建本地分支:`git checkout -b <branchname>`   \n### 9、`git checkout origin/remoteName -b localName` 获取远程分支remoteName 到本地新分支localName，并跳到localName分支   \n### 10、`git checkoutremoteName` 获取远程分支remoteName 到本地并生成新分支remoteName，并跳到localName分支","slug":"git-使用手册","published":1,"updated":"2022-06-15T07:23:15.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4fa2s9z000cdacok6qfj4rt","content":"<blockquote>\n<p>git 使用手册</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"0、-示意图\"><a href=\"#0、-示意图\" class=\"headerlink\" title=\"0、 示意图\"></a>0、 示意图</h2><p><img src=\"http://image.beekka.com/blog/2014/bg2014061202.jpg\" alt=\"image\"></p>\n<h2 id=\"一、常用命令\"><a href=\"#一、常用命令\" class=\"headerlink\" title=\"一、常用命令\"></a>一、常用命令</h2><h3 id=\"1、-删除版本库中的一个commit-git-reset-hard-HEAD-1\"><a href=\"#1、-删除版本库中的一个commit-git-reset-hard-HEAD-1\" class=\"headerlink\" title=\"1、 删除版本库中的一个commit: git reset --hard HEAD~1\"></a>1、 删除版本库中的一个commit: <code>git reset --hard HEAD~1</code></h3><h3 id=\"2、-删除远程库中的一个commit-git-reset-hard-HEAD-1-git-push-force\"><a href=\"#2、-删除远程库中的一个commit-git-reset-hard-HEAD-1-git-push-force\" class=\"headerlink\" title=\"2、 删除远程库中的一个commit: git reset --hard HEAD~1, git push --force\"></a>2、 删除远程库中的一个commit: <code>git reset --hard HEAD~1</code>, <code>git push --force</code></h3><h3 id=\"3、-将本地分支推送到远程分支：git-push-origin-local-branch-remote-branch-：这个操作，local-branch必须为你本地存在的分支，remote-branch为远程分支，如果remote-branch不存在则会自动创建分支。\"><a href=\"#3、-将本地分支推送到远程分支：git-push-origin-local-branch-remote-branch-：这个操作，local-branch必须为你本地存在的分支，remote-branch为远程分支，如果remote-branch不存在则会自动创建分支。\" class=\"headerlink\" title=\"3、 将本地分支推送到远程分支：git push origin local_ branch:remote_ branch ：这个操作，local branch必须为你本地存在的分支，remote branch为远程分支，如果remote_ branch不存在则会自动创建分支。\"></a>3、 将本地分支推送到远程分支：<code>git push origin local_ branch:remote_ branch</code> ：这个操作，local<em> branch必须为你本地存在的分支，remote</em> branch为远程分支，如果remote_ branch不存在则会自动创建分支。</h3><h3 id=\"4、将本地分支与远程分支建立对应关系：git-branch-set-upstream-to-origin-lt-branch-gt-lt-remote-gt\"><a href=\"#4、将本地分支与远程分支建立对应关系：git-branch-set-upstream-to-origin-lt-branch-gt-lt-remote-gt\" class=\"headerlink\" title=\"4、将本地分支与远程分支建立对应关系：git branch --set-upstream-to=origin/&lt;branch&gt; &lt;remote&gt;\"></a>4、将本地分支与远程分支建立对应关系：<code>git branch --set-upstream-to=origin/&lt;branch&gt; &lt;remote&gt;</code></h3><h3 id=\"5、将本地分支删除：git-branch-d-lt-branchName-gt\"><a href=\"#5、将本地分支删除：git-branch-d-lt-branchName-gt\" class=\"headerlink\" title=\"5、将本地分支删除：git branch -d &lt;branchName&gt;\"></a>5、将本地分支删除：<code>git branch -d &lt;branchName&gt;</code></h3><ul>\n<li>注意如果处在当前分支是无法删除的需要切换到其它分支再删除。另外，不管它有没有merge使用<code>git branch -D &lt;branchName&gt;</code> </li>\n</ul>\n<h3 id=\"6、如果对应outlook密码修改，则可以在目录-Users-username-ssh下删除id-rsa和id-rsa-pub\"><a href=\"#6、如果对应outlook密码修改，则可以在目录-Users-username-ssh下删除id-rsa和id-rsa-pub\" class=\"headerlink\" title=\"6、如果对应outlook密码修改，则可以在目录/Users/username/.ssh下删除id_rsa和id_rsa.pub\"></a>6、如果对应outlook密码修改，则可以在目录<code>/Users/username/.ssh</code>下删除<code>id_rsa</code>和<code>id_rsa.pub</code></h3><h3 id=\"7、切换分支-git-checkout-lt-branchname-gt\"><a href=\"#7、切换分支-git-checkout-lt-branchname-gt\" class=\"headerlink\" title=\"7、切换分支:git checkout &lt;branchname&gt;\"></a>7、切换分支:<code>git checkout &lt;branchname&gt;</code></h3><h3 id=\"8、切换分支并创建本地分支-git-checkout-b-lt-branchname-gt\"><a href=\"#8、切换分支并创建本地分支-git-checkout-b-lt-branchname-gt\" class=\"headerlink\" title=\"8、切换分支并创建本地分支:git checkout -b &lt;branchname&gt;\"></a>8、切换分支并创建本地分支:<code>git checkout -b &lt;branchname&gt;</code></h3><h3 id=\"9、git-checkout-origin-remoteName-b-localName-获取远程分支remoteName-到本地新分支localName，并跳到localName分支\"><a href=\"#9、git-checkout-origin-remoteName-b-localName-获取远程分支remoteName-到本地新分支localName，并跳到localName分支\" class=\"headerlink\" title=\"9、git checkout origin/remoteName -b localName 获取远程分支remoteName 到本地新分支localName，并跳到localName分支\"></a>9、<code>git checkout origin/remoteName -b localName</code> 获取远程分支remoteName 到本地新分支localName，并跳到localName分支</h3><h3 id=\"10、git-checkoutremoteName-获取远程分支remoteName-到本地并生成新分支remoteName，并跳到localName分支\"><a href=\"#10、git-checkoutremoteName-获取远程分支remoteName-到本地并生成新分支remoteName，并跳到localName分支\" class=\"headerlink\" title=\"10、git checkoutremoteName 获取远程分支remoteName 到本地并生成新分支remoteName，并跳到localName分支\"></a>10、<code>git checkoutremoteName</code> 获取远程分支remoteName 到本地并生成新分支remoteName，并跳到localName分支</h3>","site":{"data":{}},"excerpt":"<blockquote>\n<p>git 使用手册</p>\n</blockquote>","more":"<h2 id=\"0、-示意图\"><a href=\"#0、-示意图\" class=\"headerlink\" title=\"0、 示意图\"></a>0、 示意图</h2><p><img src=\"http://image.beekka.com/blog/2014/bg2014061202.jpg\" alt=\"image\"></p>\n<h2 id=\"一、常用命令\"><a href=\"#一、常用命令\" class=\"headerlink\" title=\"一、常用命令\"></a>一、常用命令</h2><h3 id=\"1、-删除版本库中的一个commit-git-reset-hard-HEAD-1\"><a href=\"#1、-删除版本库中的一个commit-git-reset-hard-HEAD-1\" class=\"headerlink\" title=\"1、 删除版本库中的一个commit: git reset --hard HEAD~1\"></a>1、 删除版本库中的一个commit: <code>git reset --hard HEAD~1</code></h3><h3 id=\"2、-删除远程库中的一个commit-git-reset-hard-HEAD-1-git-push-force\"><a href=\"#2、-删除远程库中的一个commit-git-reset-hard-HEAD-1-git-push-force\" class=\"headerlink\" title=\"2、 删除远程库中的一个commit: git reset --hard HEAD~1, git push --force\"></a>2、 删除远程库中的一个commit: <code>git reset --hard HEAD~1</code>, <code>git push --force</code></h3><h3 id=\"3、-将本地分支推送到远程分支：git-push-origin-local-branch-remote-branch-：这个操作，local-branch必须为你本地存在的分支，remote-branch为远程分支，如果remote-branch不存在则会自动创建分支。\"><a href=\"#3、-将本地分支推送到远程分支：git-push-origin-local-branch-remote-branch-：这个操作，local-branch必须为你本地存在的分支，remote-branch为远程分支，如果remote-branch不存在则会自动创建分支。\" class=\"headerlink\" title=\"3、 将本地分支推送到远程分支：git push origin local_ branch:remote_ branch ：这个操作，local branch必须为你本地存在的分支，remote branch为远程分支，如果remote_ branch不存在则会自动创建分支。\"></a>3、 将本地分支推送到远程分支：<code>git push origin local_ branch:remote_ branch</code> ：这个操作，local<em> branch必须为你本地存在的分支，remote</em> branch为远程分支，如果remote_ branch不存在则会自动创建分支。</h3><h3 id=\"4、将本地分支与远程分支建立对应关系：git-branch-set-upstream-to-origin-lt-branch-gt-lt-remote-gt\"><a href=\"#4、将本地分支与远程分支建立对应关系：git-branch-set-upstream-to-origin-lt-branch-gt-lt-remote-gt\" class=\"headerlink\" title=\"4、将本地分支与远程分支建立对应关系：git branch --set-upstream-to=origin/&lt;branch&gt; &lt;remote&gt;\"></a>4、将本地分支与远程分支建立对应关系：<code>git branch --set-upstream-to=origin/&lt;branch&gt; &lt;remote&gt;</code></h3><h3 id=\"5、将本地分支删除：git-branch-d-lt-branchName-gt\"><a href=\"#5、将本地分支删除：git-branch-d-lt-branchName-gt\" class=\"headerlink\" title=\"5、将本地分支删除：git branch -d &lt;branchName&gt;\"></a>5、将本地分支删除：<code>git branch -d &lt;branchName&gt;</code></h3><ul>\n<li>注意如果处在当前分支是无法删除的需要切换到其它分支再删除。另外，不管它有没有merge使用<code>git branch -D &lt;branchName&gt;</code> </li>\n</ul>\n<h3 id=\"6、如果对应outlook密码修改，则可以在目录-Users-username-ssh下删除id-rsa和id-rsa-pub\"><a href=\"#6、如果对应outlook密码修改，则可以在目录-Users-username-ssh下删除id-rsa和id-rsa-pub\" class=\"headerlink\" title=\"6、如果对应outlook密码修改，则可以在目录/Users/username/.ssh下删除id_rsa和id_rsa.pub\"></a>6、如果对应outlook密码修改，则可以在目录<code>/Users/username/.ssh</code>下删除<code>id_rsa</code>和<code>id_rsa.pub</code></h3><h3 id=\"7、切换分支-git-checkout-lt-branchname-gt\"><a href=\"#7、切换分支-git-checkout-lt-branchname-gt\" class=\"headerlink\" title=\"7、切换分支:git checkout &lt;branchname&gt;\"></a>7、切换分支:<code>git checkout &lt;branchname&gt;</code></h3><h3 id=\"8、切换分支并创建本地分支-git-checkout-b-lt-branchname-gt\"><a href=\"#8、切换分支并创建本地分支-git-checkout-b-lt-branchname-gt\" class=\"headerlink\" title=\"8、切换分支并创建本地分支:git checkout -b &lt;branchname&gt;\"></a>8、切换分支并创建本地分支:<code>git checkout -b &lt;branchname&gt;</code></h3><h3 id=\"9、git-checkout-origin-remoteName-b-localName-获取远程分支remoteName-到本地新分支localName，并跳到localName分支\"><a href=\"#9、git-checkout-origin-remoteName-b-localName-获取远程分支remoteName-到本地新分支localName，并跳到localName分支\" class=\"headerlink\" title=\"9、git checkout origin/remoteName -b localName 获取远程分支remoteName 到本地新分支localName，并跳到localName分支\"></a>9、<code>git checkout origin/remoteName -b localName</code> 获取远程分支remoteName 到本地新分支localName，并跳到localName分支</h3><h3 id=\"10、git-checkoutremoteName-获取远程分支remoteName-到本地并生成新分支remoteName，并跳到localName分支\"><a href=\"#10、git-checkoutremoteName-获取远程分支remoteName-到本地并生成新分支remoteName，并跳到localName分支\" class=\"headerlink\" title=\"10、git checkoutremoteName 获取远程分支remoteName 到本地并生成新分支remoteName，并跳到localName分支\"></a>10、<code>git checkoutremoteName</code> 获取远程分支remoteName 到本地并生成新分支remoteName，并跳到localName分支</h3>"},{"title":"Python Dev","date":"2017-03-21T08:57:02.000Z","_content":"# Python 学习\n\n<!--More-->\n\n## 一、基础知识   \n\n### 1.0、逻辑运算（补充）\n \n|逻辑运算|python 表示|  \n| -- | --|  \n|与|and |  \n|或|or|  \n|非| not|  \n|异或|^|\n\n### 1.1、 关于list与tuple(元组),<font color = red> *数组*</font>\n\n1、`list` 是可变，`tuple`是不可变，可以用`tuple`的地方尽量用`tuple`；  \n\n2、`list`利用“[]”表示，`tuple`利用\"()\"表示  \n3、数组python用numpy来做的：  \n\n\n\timport numpy\n\tmatrix = numpy.zeros(shape=(5,2))#创建数组\n\tprint matrix[i,j]#获取元素\n\n\n### 1.2、关于dict,set\n\n参考c++map,set\n\n**CAUTION:** Python的集合(set)和其他语言类似, 是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算.由于集合是无序的,所以，sets 不支持 索引, 分片, 或其它类序列（sequence-like）的操作。Dict的key必须是不可变的\n\n### 1.3、关于python的可变参数与关键字参数\n\n1、可变参数就是传入的参数的个数是可变定义方式为`def func(*args)`。可变参数在函数调用时自动组装为一tuple。\n\n2、关键字参数可以传入零个或多个含参数名的参数也就是键值对，定义方式为`def func(**kv)`。关键字参数在函数调用时组装成一个dict。\n\n3、list,tuple可以在变量前面添加`*`来传入到参数为可变参数的函数，dict同样也可传入到参数为关键字参数的函数。\n\n4、由于3，对于任意函数我们都可以通过`def func(*args,**kv)`来调用它，不管他是怎么样定义的。\n\n5、python函数的参数顺序问题：必须函数，默认参数，可变参数，关键字参数  \n\n### 1.4、Python所谓的高级我切片与matlab的取第几行几列类似\n\n\n### 1.5、迭代使用`for ... in `或者`for value in d.iteatervalues()`同时也可以用`for k,v in d.iteritems()`\n例如：   \n\n\n\td  = { a :1, b :2}\t\n\tfor key in d:\t\n\tprint key\n\n1、但是要使用迭代一个对象，那么这个对象要是**可迭代的**，<font color = red>方法：可以通过collections 模块的iterable进行判断</font>      \n\n### 1.6、生成器(Generator)\n\n由于通过列表生成器生成一个列表时，受到内存的限制，列表的容量是有限的。所以如果可以按照一种算法进行推算出来，那就不必创建完整的list从而可以节省大量空间。创建generator的方法有多种：  \n\n第一种： \n\n\n\tl = [ x*x for x in range(1,11) ]\t\n\tg = (x*x for x in range(1,11))   # g就是一个generator，与列表生成器不同的是[ ]与（ ）的问题  \n\tg.next()  # generator保存的是算法每次调用next()实际是在计算下一个元素，直到计算到最后的元素，当没有元素时就会抛出StopIteration的错误\n\tfor n in g: # 由于不断调用next（）函数并不是很方便，由于generator是可迭代对象，因此正确的使用方法是使用迭代\n\tprint n\n\n\n第二种：\n在函数定义中如果包含yield关键字，那么这个函数就是一个generator      \n\n\n\tdef fib(max):\t\n\t\t    n,a,b = 0,0,1\t\n\t\t    while n<max:\t\n\t\t        yield b      # yield关键字\n\t\t        a,b =b ,a+b\t\n\t\t        n = n+1\n\n### 1.7、python高函数\n\n所谓的高阶函数就是一个函数接收函数作为参数\n\n### 1.8、map/reduce/filter\n\n[关于MapReduce文章]( http://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf)    \n\n+ map/reduce demo  \n\n\t\tdef str2int(s):\t\n\t\t\tdef fn(x,y):\t\n\t\t\t   return x*10+y\t\n\t\t\t  def char2num (s) :\t\n\t\t\t    return {  0  : 0 ,  1  : 1 ,  2  : 2 ,  3  : 3 ,  4  : 4 ,  5  : 5 ,  6  : 6 ,  7  : 7 ,  8  : 8 ,  9  : 9 }[s]\n\t\t\t    return reduce(fn,map(char2num,s))\n\n\n<font color=red>**注意map,reduce都接收一个函数与一个list，因此第5行代码就好理解了**   </font>    \n\n+ filter 与map/reduce一样都 是高阶函数都是接收一个函数与list变量,filter是根据传入函数作用于每一个元素返回true/false来决定这个元素是否保留\n\n\n\t\tdef is_odd(n):\t\n\t\t    return n%2 ==1\n\t\t   \tfilter(is_odd,[1,2,3,4,5])\n \n\n\n\n\n### 1.9、**funciton.partial偏函数**，把一个函数的某些参数给固定住，返回一个新函数，那么调用 这个函数就会简单一些。当一个函数的参数个数太多需要简化的时候可以使用functools.partial创建一个偏函数。\n\n\n\t\timport functools\t\n\t\tint2 = functools.partial(int,base = 2) #int2就是一个新函数只有一个参数\n   \n\n### 1.9.1 装饰器及 `@`语法\n\n\n开门见山，直上代码\n\n\n\t\tdef log(func):\t\n\t\t        def wrapper(*args,**kw):\t\n\t\t            print  call %s %func.__name__\n\t\t            return func(*args,**kw)\t\n\t\treturn wrapper\n  \n\n`log`函数接收一个函数作为参数，然后返回一个函数，这就叫做decorator。那么怎么用这个decorator呢？代码直上：  \n\n\n\t\t@log\t\n\t\tdef now():\t\n\t\t    print  sdfdsfds \n  \n\n`@`语法相当于：`now = log(now)`     \n  \n### 1.10、python用模块（module）来组织工程\n\n1、使用模块可以避免函数与变量名的冲突。一个.py文件 就是一个模块。\n\n2、为了避免模块名的冲突python引入package，本质就是按目录来组织模块\n\n3、package目录下一定要有一__init__.py模块，否则认为普通目录  \n\n4、注释也可采用  \n\n\n\t\t\t‘’‘\n\t\t\n\t\t\t注释\n\t\t\t\n\t\t\t’‘’\n\n\n### 1.11、关于`if __name__== main:`\n\n当我们用命令行运行模块的时候，Python解释器就会将一个特殊变量`__name__`置为`__main__`，而在其它地方导入该模块这个判断就会失败，也就是说这条语句主要是便于我们使用命令行。  \n\n### 1.12、作用域\n\nprivate访问控制在python里通过`_`或者`__`前缀来实现。这里所说的private只是一种编程习惯，因为python并没有private的控制访问。\n\n### 1.13、python面向对象编程(Object Oriented Programming,OOP)\n\n话不多说直接上demo\n\n\n\t\tclass Student(object):                                 #表示Student从object继承 \n\t\t        def __init__(self,name,score):            #__init__类于构造函数，且第一个参数永远是self，表示创建实例本身。而且实例化对象时一定要传入与__init__参数对应的参数\n\t\t\n\t\t                self.name = name\t\n\t\t                self.score = score\t\n\t\t                super(Student,self).__init__()    #表示调用父类方法\n\t\t\t        def print_score(self):\t\n\t\t                print  %s,%s %(self.name,self.score)\n  \n\n1、`__init__`类于构造函数，且第一个参数永远是self，表示创建实例本身。而且实例化对象时一定要传入与__init__参数对应的参数。    \n2、成员函数与普通函数不一样的地方就是第一个参数永远是self     \n3、private访问控制权限就是在变量前面添加`__`前缀。`_`在类中视为private但是其实是可以访问的，只是按约定视为private.    \n4、private变量其实也是可以访问的，可以通过`_类名_private变量`如`_Student_name`     \n5、  super(className,self).function()      父类方法调用<font color = red> 如果是多继承且多个父类有同样的方法则按顺序调用</font>\n\n### 1.14、关于python的多态\n\n由于python里不需要事先声明变量的类型，因此多态实现起来就简单得多：  \n\n\n\t\tdef run(animal):\t\n\t\t    animal.run()\n \n\n代码中只要传入的参数有run这个方法就可以，<font color = red>**不管是不是animal还是子类或者不是子类**</font>，这样子就与c++里的多态一样。其实本质上是由于python本来就是动态语言。  \n\n### 1.15、获取对象信息\n\n1、type可以判断基本类型的所属类型\n\n\n\timport types\t\n\ttype( ssdfdf )\n\n\n2、isinstance可以判断基本数据类型还可以判断class类\n\n3、dir可以获取对象的所有属性和方法\n\n4、getattr(),setattr(),hasattr()可以操作一个对象的属性，顾名思义  \n\n### 1.16、python动态绑定方法\n\n\n\tdef set_age(self,age):\t\n\t        self.age = age\t\t\n\tfrom types import MethodType\t\n\ts.set_age = MethodType(set_age,s,Student)          #给实例新增方法\n\tStudent.set_age = MethodType(set_age,None,Student)    #给类新增方法\n   \n\n1、<font color = red>**`__slot__`**</font>关键字\n\n如果想对class限制只允许给类的实例添加属性时，我们可以使用`__slot__`，但是不遗传\n\n\n\tclass Student(object):\t\n\t__slot__ = ( name , age )  #用tuple定义允许修改的属性名称\n\n\n### 1.17、`@property`关键字\n\n`@property`负责将一个方法变成属性调用，而与一个属性不同的是属性并没有检查是否合法，而方法是可以进行检查的。\n\n\n\n\tclass Student(object):\t\n\t        @property\t\n\t        def score(self):\t\n\t                return self._score\t\n\t        @score.setter\t\n\t        def score(self,value):\t\n\t                if():\n\t                        .....#参数检查\n\t                self._score = value\n\t\n\t>>>s = Student()\t\n\t>>>s.score = 10 #实际上是调用的s.set_score()\n\t>>>s.score #实际上调用 的是s.get_score()\n\n\n`@property`把一个方法变成属性，`@xxx.setter`把一个方法变成属性赋值，与OC的property有一点相似\n\n### 1.18、多重继承\n\n### 1.19、定制类\n\n### 1.20、元类\n\n1、type动态创建一个对象\n\n\n\thello = type( Hello ,(object,),dict(hello = fn))\n\n\ntype接收三个参数：\n\n+ class名字\n\n+ 参数2 为父类，是一个tuple（object,）\n\n+ dict(hello = fn),绑定函数到类的方法\n\n   \n\n2、metaclass元类，（OC中也有这个概念）   \n\n### 1.21、异常捕获`try:....except...finally...`\n\n\n\ttry:\t\n\t    print  try.... \t\n\t    r = 10/0\t\n\t    print  reuslt: ,r\t\n\texcept ZeroDivisionError ,e:        #还可以多级捕获\n\t    print  error: ,e\t\n\tfinally:\t\n\t    print  finally... \n  \n\n1、可以通过`raise`抛出异常，`raise`后面不带参数则将错误原样抛出，同样`raise`也可以修改抛出错误的类型  \n\n### 1.22、调试\n\n1、print打印信息\n\n2、asser断言\n\n3、logging推荐，可以定义log级别：debug,info,waning,error ,可以指定输出文件`logging.config.fileConfig(filename)`,[filename规则](https://docs.python.org/2/library/logging.config.html#logging-config-fileformat)  ，给一个log.conf\n\n\n\t[loggers]\n\tkeys=root\n\t\n\t[handlers]\n\tkeys=consoleHandler,fileHandler\n\t\n\t[formatters]\n\tkeys=simpleFormatter\n\t\n\t[logger_root]\n\tlevel=DEBUG\n\thandlers=consoleHandler,fileHandler\n\t\n\t[handler_consoleHandler]\n\tclass=StreamHandler\n\tlevel=DEBUG\n\tformatter=simpleFormatter\n\targs=(sys.stdout,)\n\t\n\t[handler_fileHandler]\n\tclass=logging.handlers.TimedRotatingFileHandler\n\tlevel=DEBUG\n\tformatter=simpleFormatter\n\targs=('./log/sample.log','D',1,14)\n\t#args=('/data/iTOP_ROOT/dev/log/admin/pack/sample.log','D',1,14)\n\t\n\t[formatter_simpleFormatter]\n\tformat=[%(asctime)s][pid %(process)d][%(levelname)s][%(filename)s:%(lineno)d]%(message)s\n\tdatefmt=\n\n\n使用方式：  \n\n\n\tlogging.config.fileConfig('./log.conf')\n\tlogger = logging.getLogger('root')\n\n还可以直接使用代码： \n\n\timport logging\n\t\n\tlogger = logging.getLogger()\n\thandler = logging.StreamHandler()\n\tformatter = logging.Formatter(\n\t        '%(asctime)s %(name)-12s %(levelname)-8s %(message)s')\n\thandler.setFormatter(formatter)\n\tlogger.addHandler(handler)\n\tlogger.setLevel(logging.DEBUG)\n\n\n\n4、[pdb]( http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138683229901532c40b749184441dbd428d2e0f8aa50e000)   \n\n### 1.23、单元测试  \n\n### 1.24、文档测试（测试注释了的代码--python交互式代码）\n\n### 1.25、IO编程\n\n1、文件读写   \n\n\n    f = open(filename,r)\n    f.read()\n    f.close\n\n\n为了保证会调用`close()`同时也是为了简单化，Python引入了`with`语法来帮助我们调用`close()`\n\n\n\n\twith open( filename ,r ) as f:\n   \t\t print f.read()\n   \n\n2、[操作文件和目录]( http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868321590543ff305fb9f9949f08d760883cc243812000)    \n\n3、序列化   \n\n+ python中序列化提供了两个模块来实现：`cPickle`和`pickle`(有`c`开头的就是用c语言实现的)[pickle参考]( http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138683221577998e407bb309542d9b6a68d9276bc3dbe000)   \n\n+ json，`pickle`的问题在于序列化只能用在python中不能进行传递或者其它语言来解释，json刚好可以解决这个问题。\n\n| json | python |  \n| ---- | ---- |     \n| { } | dict |  \n| [ ] | list |  \n| \"string\" |  str 或者u unicode  |\n| 123.4 | int 或者 float |  \n| true/false | Ture /False |\n| null | None |   \n\n\n\timport josn\t\n\td = dict(name = 'Bob',age = 10,score = 88)\tjson.dumps(d)  #dump意为转储\t\n\tjson.loads(str)#转成dict python对象\n\n\n<font color = red>**CAUTION:**</font>json反序列化得到字符串对象都是unicode不是str。  \n\n+ class 序列化（json的进阶）   \n\n\n\tjson.dumps(s, \n\tdefault\n\t=lambda obj: obj.__dict__)#当class有__slot__属性时不能用 \n     \n\n\n\n\n\n### 1.26、[进程与线程]( http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868323401155ceb3db1e2044f80b974b469eb06cb43000)     \n\n1、进程\n\n+ Unix/Linux下可以调用`fork()`实现多进程\n\n+ 跨平台的多进程，可以使用multiprocessing  \n\n+ 进程间的通信可以使用Queue,Pipes  \n\n2、线程，python中有两个模块（thread,threading，后者是高级，我们一般使用高级）\n\n+ 线程与进程最大的不同是，同一个变量在进程中是各自有一份copy互不影响，而多线程中所有的线程共享进程的变量，是相互影响的。因此在多线程中我们使用Lock来保证变量的不相互影响   \n\n\t\timport time, threading \t\n\t\tbalance = 0\n\t\tlock = threading.Lock()\n\t\tdef change_it(n):    \t\n\t\t        global balance   \t\n\t\t         balance = balance + n\t\n\t\t         balance = balance - n \n\t\t def run_thread(n):    \t\n\t\t        for i in range(100000):\n\t\t               lock.acquire()     #先获取锁\t               try:                #try...finally保证不管什么情况下都会释放locK\n\t\t                   change_it(n)\n\t\t               finally:\n\t\t                   lock.release()  #释放锁\n\t\tif __name__ ==  __main__ :\n\t\t      t1 = threading.Thread(target=run_thread, args=(5,)) \n\t\t      t2 = threading.Thread(target=run_thread, args=(8,))   \n\t\t      t1.start()   \t\n\t\t      t2.start()   \t\n\t\t     t1.join()    \t\n\t\t    t2.join()  \t\n\t\t    print balance\n\t   \n\n+ 在多线程下每一个线程要保持自己的数据时，我们可使用ThreadLocal, **ThreadLocal最常用的地方就是为每一个线程绑定一个数据库链接，http请求，用户身份信息等**\n\n\n\n\t\n\t\timport threading\t\n\t\tlocal_shcool = threading.local()  #每一个线程都可以写，且相互不影响，可以理解为一个以thread为key的dict\n\t\tdef pro_std():\t\n\t\t    print hello,%s (in %s) %(loca_school.student,threading.current_thread().name)\n\t\tdef pro_thread(name):\t\n\t\t    local_shcool.student = name\t\n\t\t    \t    pro_std()\t\n\t\tt1 = threading.Thread(target = pro_thread,args = ( Alice ),name =  a )\n\t\tt2 = threading.Thread(target = pro_thread,args = ( Bob ),name =  B )\n\t\tt1.start()\t\n\t\tt2.start()\t\n\t\tt1.join()\t\n\t\tt2.join()\t\n\n\n### 1.27、分布式编程   \n\n[参考]( http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386832973658c780d8bfa4c6406f83b2b3097aed5df6000)   \n\n### 1.28、正则表达式\n\n### 1.29常用内嵌模块  \n\n1、collections\n\n2、base64:base64是一种任意二进制到文本字符串的编码方法。**关于base64的理解：将3个字符串转成4个字符串，3 \\* 8 = 4\\*6，因此叫base64**  \n\n3、hashlib摘要算法库，md5,SHA1。md5结果是128bit,SHA1结果是160bit\n\n\n\timport hashlib\t\n\tmd5 = hashlib.md5()\t\n\tmd5.update(  hello world )\t\n\tmd5.update( hdhhd )\t\n\tprint md5.hexdigest()\n   \n\nSHA1与md5的调用 一样将上述代码改成SHA1即可  \n## 2、python进阶  \n### 2.1、Range与XRange的区别\n在 Range的方法中，它会生成一个**list**的对象，但是在XRange中，它生成的却是一个**xrange的对象**，当返回的东西不是很大的时候，或者在一个 循环里，基本上都是从头查到底的情况下，这两个方法的效率差不多。但是，当返回的东西很大，或者循环中常常会被Break出来的话，还是建议使用 XRange，这样既省空间，又会提高效率。\n\n### 2.2、ArgumentParser处理数组传入\n\n+ nargs说明\n\n||说明|   \n|:--|:--|\n|nargs ='+'|输入至少一个参数|\n|nargs = '*'|输入零个或多个参数|\n\n例如：\n\n\tap = argparse.ArgumentParser()\n    ap.add_argument('-p','--plugins',required = True, nargs = '+', help = 'the channel which you will test')\n\n### 2.3、ConfigParser\n在python开发中经常会遇到配置化问题，也就是将配置写在一个xxxx.conf文件，然后程序根据配置文件做相应的事情。那配置化文件长什么样？又需要怎么样解析？本节`ConfigParser`就是来做这样的事情的。首先，给出一个配置文件示例：   \n\n\t\t[IMSDKLoginFacebook]\n\t\tbundleid = com.tencent.imsdk2\n\t\tsystemlibs = [\"CoreTelephony.framework\",\"CoreLocation.framework\"]\n\t\tbuildsettings = {\"OTHER_LDFLAGS\":\"-ObjC\", \"ENABLE_BITCODE\":\"NO\"}\n\t\txctestfiles = [\"DemoFacebookLoginTests.mm\"]\n\t\tthirdsdks = [\"/IMSDK/Demo/IMSDK/Third/Facebook\"]\n\t\tresources = []\n\t\tinfoplist = {}\n\t\tcapabilites = {}\n接下来就是要解析配置文件\n\n\t\t cf = ConfigParser.ConfigParser()\n       \tcf.read('sample.conf')  #先读取文件\n       \n配置文件内容解析：section, option。`[IMSDKLoginFacebook]`称为section, `resources = []`称为option\n\n\t\tcf.has_section('section') # 判断是否有对应section\n\t\tcf.add_section('section') # 添加section\n\t\tcf.set('section','option','[]') #设置section/option\n\t\tcf.get('section'，‘option’) #获取section/option\n\t\t\n**注意，配置文件都是处理结果都字符串，要想处理其它类型数据可以考虑通过json转换**\n## 3、python实战\n### 3.1、[python制作gif]( http://python.jobbole.com/81185/)，然后可以在ppt导入    \n### 3.2、Tkinter UI  \n1、动态更新UI，使用`config`   \n\n\troot = Tk()\n\tbtn = Button(root,text ='test')\n\tbtn.pack()\n\tbtn.config(state = 'disabled'）\n   \n关于布局有三种，pack,grid,place[参考]( http://www.tutorialspoint.com/python/tk_pack.htm)   \n\n\n## 4、opencv python   \n### 4.1、反转黑白图片\n\n\tthresh = cv2.thrsehold(image,122,255,cv2.THRESH_BINARY_INV)[1]\n  \n\n### 4.2、[python进行条形码检测]( http://python.jobbole.com/81130/)    \n### 4.3、cv2  crop图片  \n\n\timg = image[y:y+h,x:x+w]\n  \n### 4.4、由文本生成图片，[参考](http://python.jobbole.com/81983/)     \n### 4.5、图片生成汉字库，关于怎么样将汉字切片可以[参考](http://python.jobbole.com/81985/)  ","source":"_posts/Python-Dev.md","raw":"---\ntitle: Python Dev\ndate: 2017-03-21 16:57:02\ntags: [Python, Dev]\ncategories: Python\n---\n# Python 学习\n\n<!--More-->\n\n## 一、基础知识   \n\n### 1.0、逻辑运算（补充）\n \n|逻辑运算|python 表示|  \n| -- | --|  \n|与|and |  \n|或|or|  \n|非| not|  \n|异或|^|\n\n### 1.1、 关于list与tuple(元组),<font color = red> *数组*</font>\n\n1、`list` 是可变，`tuple`是不可变，可以用`tuple`的地方尽量用`tuple`；  \n\n2、`list`利用“[]”表示，`tuple`利用\"()\"表示  \n3、数组python用numpy来做的：  \n\n\n\timport numpy\n\tmatrix = numpy.zeros(shape=(5,2))#创建数组\n\tprint matrix[i,j]#获取元素\n\n\n### 1.2、关于dict,set\n\n参考c++map,set\n\n**CAUTION:** Python的集合(set)和其他语言类似, 是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算.由于集合是无序的,所以，sets 不支持 索引, 分片, 或其它类序列（sequence-like）的操作。Dict的key必须是不可变的\n\n### 1.3、关于python的可变参数与关键字参数\n\n1、可变参数就是传入的参数的个数是可变定义方式为`def func(*args)`。可变参数在函数调用时自动组装为一tuple。\n\n2、关键字参数可以传入零个或多个含参数名的参数也就是键值对，定义方式为`def func(**kv)`。关键字参数在函数调用时组装成一个dict。\n\n3、list,tuple可以在变量前面添加`*`来传入到参数为可变参数的函数，dict同样也可传入到参数为关键字参数的函数。\n\n4、由于3，对于任意函数我们都可以通过`def func(*args,**kv)`来调用它，不管他是怎么样定义的。\n\n5、python函数的参数顺序问题：必须函数，默认参数，可变参数，关键字参数  \n\n### 1.4、Python所谓的高级我切片与matlab的取第几行几列类似\n\n\n### 1.5、迭代使用`for ... in `或者`for value in d.iteatervalues()`同时也可以用`for k,v in d.iteritems()`\n例如：   \n\n\n\td  = { a :1, b :2}\t\n\tfor key in d:\t\n\tprint key\n\n1、但是要使用迭代一个对象，那么这个对象要是**可迭代的**，<font color = red>方法：可以通过collections 模块的iterable进行判断</font>      \n\n### 1.6、生成器(Generator)\n\n由于通过列表生成器生成一个列表时，受到内存的限制，列表的容量是有限的。所以如果可以按照一种算法进行推算出来，那就不必创建完整的list从而可以节省大量空间。创建generator的方法有多种：  \n\n第一种： \n\n\n\tl = [ x*x for x in range(1,11) ]\t\n\tg = (x*x for x in range(1,11))   # g就是一个generator，与列表生成器不同的是[ ]与（ ）的问题  \n\tg.next()  # generator保存的是算法每次调用next()实际是在计算下一个元素，直到计算到最后的元素，当没有元素时就会抛出StopIteration的错误\n\tfor n in g: # 由于不断调用next（）函数并不是很方便，由于generator是可迭代对象，因此正确的使用方法是使用迭代\n\tprint n\n\n\n第二种：\n在函数定义中如果包含yield关键字，那么这个函数就是一个generator      \n\n\n\tdef fib(max):\t\n\t\t    n,a,b = 0,0,1\t\n\t\t    while n<max:\t\n\t\t        yield b      # yield关键字\n\t\t        a,b =b ,a+b\t\n\t\t        n = n+1\n\n### 1.7、python高函数\n\n所谓的高阶函数就是一个函数接收函数作为参数\n\n### 1.8、map/reduce/filter\n\n[关于MapReduce文章]( http://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf)    \n\n+ map/reduce demo  \n\n\t\tdef str2int(s):\t\n\t\t\tdef fn(x,y):\t\n\t\t\t   return x*10+y\t\n\t\t\t  def char2num (s) :\t\n\t\t\t    return {  0  : 0 ,  1  : 1 ,  2  : 2 ,  3  : 3 ,  4  : 4 ,  5  : 5 ,  6  : 6 ,  7  : 7 ,  8  : 8 ,  9  : 9 }[s]\n\t\t\t    return reduce(fn,map(char2num,s))\n\n\n<font color=red>**注意map,reduce都接收一个函数与一个list，因此第5行代码就好理解了**   </font>    \n\n+ filter 与map/reduce一样都 是高阶函数都是接收一个函数与list变量,filter是根据传入函数作用于每一个元素返回true/false来决定这个元素是否保留\n\n\n\t\tdef is_odd(n):\t\n\t\t    return n%2 ==1\n\t\t   \tfilter(is_odd,[1,2,3,4,5])\n \n\n\n\n\n### 1.9、**funciton.partial偏函数**，把一个函数的某些参数给固定住，返回一个新函数，那么调用 这个函数就会简单一些。当一个函数的参数个数太多需要简化的时候可以使用functools.partial创建一个偏函数。\n\n\n\t\timport functools\t\n\t\tint2 = functools.partial(int,base = 2) #int2就是一个新函数只有一个参数\n   \n\n### 1.9.1 装饰器及 `@`语法\n\n\n开门见山，直上代码\n\n\n\t\tdef log(func):\t\n\t\t        def wrapper(*args,**kw):\t\n\t\t            print  call %s %func.__name__\n\t\t            return func(*args,**kw)\t\n\t\treturn wrapper\n  \n\n`log`函数接收一个函数作为参数，然后返回一个函数，这就叫做decorator。那么怎么用这个decorator呢？代码直上：  \n\n\n\t\t@log\t\n\t\tdef now():\t\n\t\t    print  sdfdsfds \n  \n\n`@`语法相当于：`now = log(now)`     \n  \n### 1.10、python用模块（module）来组织工程\n\n1、使用模块可以避免函数与变量名的冲突。一个.py文件 就是一个模块。\n\n2、为了避免模块名的冲突python引入package，本质就是按目录来组织模块\n\n3、package目录下一定要有一__init__.py模块，否则认为普通目录  \n\n4、注释也可采用  \n\n\n\t\t\t‘’‘\n\t\t\n\t\t\t注释\n\t\t\t\n\t\t\t’‘’\n\n\n### 1.11、关于`if __name__== main:`\n\n当我们用命令行运行模块的时候，Python解释器就会将一个特殊变量`__name__`置为`__main__`，而在其它地方导入该模块这个判断就会失败，也就是说这条语句主要是便于我们使用命令行。  \n\n### 1.12、作用域\n\nprivate访问控制在python里通过`_`或者`__`前缀来实现。这里所说的private只是一种编程习惯，因为python并没有private的控制访问。\n\n### 1.13、python面向对象编程(Object Oriented Programming,OOP)\n\n话不多说直接上demo\n\n\n\t\tclass Student(object):                                 #表示Student从object继承 \n\t\t        def __init__(self,name,score):            #__init__类于构造函数，且第一个参数永远是self，表示创建实例本身。而且实例化对象时一定要传入与__init__参数对应的参数\n\t\t\n\t\t                self.name = name\t\n\t\t                self.score = score\t\n\t\t                super(Student,self).__init__()    #表示调用父类方法\n\t\t\t        def print_score(self):\t\n\t\t                print  %s,%s %(self.name,self.score)\n  \n\n1、`__init__`类于构造函数，且第一个参数永远是self，表示创建实例本身。而且实例化对象时一定要传入与__init__参数对应的参数。    \n2、成员函数与普通函数不一样的地方就是第一个参数永远是self     \n3、private访问控制权限就是在变量前面添加`__`前缀。`_`在类中视为private但是其实是可以访问的，只是按约定视为private.    \n4、private变量其实也是可以访问的，可以通过`_类名_private变量`如`_Student_name`     \n5、  super(className,self).function()      父类方法调用<font color = red> 如果是多继承且多个父类有同样的方法则按顺序调用</font>\n\n### 1.14、关于python的多态\n\n由于python里不需要事先声明变量的类型，因此多态实现起来就简单得多：  \n\n\n\t\tdef run(animal):\t\n\t\t    animal.run()\n \n\n代码中只要传入的参数有run这个方法就可以，<font color = red>**不管是不是animal还是子类或者不是子类**</font>，这样子就与c++里的多态一样。其实本质上是由于python本来就是动态语言。  \n\n### 1.15、获取对象信息\n\n1、type可以判断基本类型的所属类型\n\n\n\timport types\t\n\ttype( ssdfdf )\n\n\n2、isinstance可以判断基本数据类型还可以判断class类\n\n3、dir可以获取对象的所有属性和方法\n\n4、getattr(),setattr(),hasattr()可以操作一个对象的属性，顾名思义  \n\n### 1.16、python动态绑定方法\n\n\n\tdef set_age(self,age):\t\n\t        self.age = age\t\t\n\tfrom types import MethodType\t\n\ts.set_age = MethodType(set_age,s,Student)          #给实例新增方法\n\tStudent.set_age = MethodType(set_age,None,Student)    #给类新增方法\n   \n\n1、<font color = red>**`__slot__`**</font>关键字\n\n如果想对class限制只允许给类的实例添加属性时，我们可以使用`__slot__`，但是不遗传\n\n\n\tclass Student(object):\t\n\t__slot__ = ( name , age )  #用tuple定义允许修改的属性名称\n\n\n### 1.17、`@property`关键字\n\n`@property`负责将一个方法变成属性调用，而与一个属性不同的是属性并没有检查是否合法，而方法是可以进行检查的。\n\n\n\n\tclass Student(object):\t\n\t        @property\t\n\t        def score(self):\t\n\t                return self._score\t\n\t        @score.setter\t\n\t        def score(self,value):\t\n\t                if():\n\t                        .....#参数检查\n\t                self._score = value\n\t\n\t>>>s = Student()\t\n\t>>>s.score = 10 #实际上是调用的s.set_score()\n\t>>>s.score #实际上调用 的是s.get_score()\n\n\n`@property`把一个方法变成属性，`@xxx.setter`把一个方法变成属性赋值，与OC的property有一点相似\n\n### 1.18、多重继承\n\n### 1.19、定制类\n\n### 1.20、元类\n\n1、type动态创建一个对象\n\n\n\thello = type( Hello ,(object,),dict(hello = fn))\n\n\ntype接收三个参数：\n\n+ class名字\n\n+ 参数2 为父类，是一个tuple（object,）\n\n+ dict(hello = fn),绑定函数到类的方法\n\n   \n\n2、metaclass元类，（OC中也有这个概念）   \n\n### 1.21、异常捕获`try:....except...finally...`\n\n\n\ttry:\t\n\t    print  try.... \t\n\t    r = 10/0\t\n\t    print  reuslt: ,r\t\n\texcept ZeroDivisionError ,e:        #还可以多级捕获\n\t    print  error: ,e\t\n\tfinally:\t\n\t    print  finally... \n  \n\n1、可以通过`raise`抛出异常，`raise`后面不带参数则将错误原样抛出，同样`raise`也可以修改抛出错误的类型  \n\n### 1.22、调试\n\n1、print打印信息\n\n2、asser断言\n\n3、logging推荐，可以定义log级别：debug,info,waning,error ,可以指定输出文件`logging.config.fileConfig(filename)`,[filename规则](https://docs.python.org/2/library/logging.config.html#logging-config-fileformat)  ，给一个log.conf\n\n\n\t[loggers]\n\tkeys=root\n\t\n\t[handlers]\n\tkeys=consoleHandler,fileHandler\n\t\n\t[formatters]\n\tkeys=simpleFormatter\n\t\n\t[logger_root]\n\tlevel=DEBUG\n\thandlers=consoleHandler,fileHandler\n\t\n\t[handler_consoleHandler]\n\tclass=StreamHandler\n\tlevel=DEBUG\n\tformatter=simpleFormatter\n\targs=(sys.stdout,)\n\t\n\t[handler_fileHandler]\n\tclass=logging.handlers.TimedRotatingFileHandler\n\tlevel=DEBUG\n\tformatter=simpleFormatter\n\targs=('./log/sample.log','D',1,14)\n\t#args=('/data/iTOP_ROOT/dev/log/admin/pack/sample.log','D',1,14)\n\t\n\t[formatter_simpleFormatter]\n\tformat=[%(asctime)s][pid %(process)d][%(levelname)s][%(filename)s:%(lineno)d]%(message)s\n\tdatefmt=\n\n\n使用方式：  \n\n\n\tlogging.config.fileConfig('./log.conf')\n\tlogger = logging.getLogger('root')\n\n还可以直接使用代码： \n\n\timport logging\n\t\n\tlogger = logging.getLogger()\n\thandler = logging.StreamHandler()\n\tformatter = logging.Formatter(\n\t        '%(asctime)s %(name)-12s %(levelname)-8s %(message)s')\n\thandler.setFormatter(formatter)\n\tlogger.addHandler(handler)\n\tlogger.setLevel(logging.DEBUG)\n\n\n\n4、[pdb]( http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138683229901532c40b749184441dbd428d2e0f8aa50e000)   \n\n### 1.23、单元测试  \n\n### 1.24、文档测试（测试注释了的代码--python交互式代码）\n\n### 1.25、IO编程\n\n1、文件读写   \n\n\n    f = open(filename,r)\n    f.read()\n    f.close\n\n\n为了保证会调用`close()`同时也是为了简单化，Python引入了`with`语法来帮助我们调用`close()`\n\n\n\n\twith open( filename ,r ) as f:\n   \t\t print f.read()\n   \n\n2、[操作文件和目录]( http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868321590543ff305fb9f9949f08d760883cc243812000)    \n\n3、序列化   \n\n+ python中序列化提供了两个模块来实现：`cPickle`和`pickle`(有`c`开头的就是用c语言实现的)[pickle参考]( http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138683221577998e407bb309542d9b6a68d9276bc3dbe000)   \n\n+ json，`pickle`的问题在于序列化只能用在python中不能进行传递或者其它语言来解释，json刚好可以解决这个问题。\n\n| json | python |  \n| ---- | ---- |     \n| { } | dict |  \n| [ ] | list |  \n| \"string\" |  str 或者u unicode  |\n| 123.4 | int 或者 float |  \n| true/false | Ture /False |\n| null | None |   \n\n\n\timport josn\t\n\td = dict(name = 'Bob',age = 10,score = 88)\tjson.dumps(d)  #dump意为转储\t\n\tjson.loads(str)#转成dict python对象\n\n\n<font color = red>**CAUTION:**</font>json反序列化得到字符串对象都是unicode不是str。  \n\n+ class 序列化（json的进阶）   \n\n\n\tjson.dumps(s, \n\tdefault\n\t=lambda obj: obj.__dict__)#当class有__slot__属性时不能用 \n     \n\n\n\n\n\n### 1.26、[进程与线程]( http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868323401155ceb3db1e2044f80b974b469eb06cb43000)     \n\n1、进程\n\n+ Unix/Linux下可以调用`fork()`实现多进程\n\n+ 跨平台的多进程，可以使用multiprocessing  \n\n+ 进程间的通信可以使用Queue,Pipes  \n\n2、线程，python中有两个模块（thread,threading，后者是高级，我们一般使用高级）\n\n+ 线程与进程最大的不同是，同一个变量在进程中是各自有一份copy互不影响，而多线程中所有的线程共享进程的变量，是相互影响的。因此在多线程中我们使用Lock来保证变量的不相互影响   \n\n\t\timport time, threading \t\n\t\tbalance = 0\n\t\tlock = threading.Lock()\n\t\tdef change_it(n):    \t\n\t\t        global balance   \t\n\t\t         balance = balance + n\t\n\t\t         balance = balance - n \n\t\t def run_thread(n):    \t\n\t\t        for i in range(100000):\n\t\t               lock.acquire()     #先获取锁\t               try:                #try...finally保证不管什么情况下都会释放locK\n\t\t                   change_it(n)\n\t\t               finally:\n\t\t                   lock.release()  #释放锁\n\t\tif __name__ ==  __main__ :\n\t\t      t1 = threading.Thread(target=run_thread, args=(5,)) \n\t\t      t2 = threading.Thread(target=run_thread, args=(8,))   \n\t\t      t1.start()   \t\n\t\t      t2.start()   \t\n\t\t     t1.join()    \t\n\t\t    t2.join()  \t\n\t\t    print balance\n\t   \n\n+ 在多线程下每一个线程要保持自己的数据时，我们可使用ThreadLocal, **ThreadLocal最常用的地方就是为每一个线程绑定一个数据库链接，http请求，用户身份信息等**\n\n\n\n\t\n\t\timport threading\t\n\t\tlocal_shcool = threading.local()  #每一个线程都可以写，且相互不影响，可以理解为一个以thread为key的dict\n\t\tdef pro_std():\t\n\t\t    print hello,%s (in %s) %(loca_school.student,threading.current_thread().name)\n\t\tdef pro_thread(name):\t\n\t\t    local_shcool.student = name\t\n\t\t    \t    pro_std()\t\n\t\tt1 = threading.Thread(target = pro_thread,args = ( Alice ),name =  a )\n\t\tt2 = threading.Thread(target = pro_thread,args = ( Bob ),name =  B )\n\t\tt1.start()\t\n\t\tt2.start()\t\n\t\tt1.join()\t\n\t\tt2.join()\t\n\n\n### 1.27、分布式编程   \n\n[参考]( http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386832973658c780d8bfa4c6406f83b2b3097aed5df6000)   \n\n### 1.28、正则表达式\n\n### 1.29常用内嵌模块  \n\n1、collections\n\n2、base64:base64是一种任意二进制到文本字符串的编码方法。**关于base64的理解：将3个字符串转成4个字符串，3 \\* 8 = 4\\*6，因此叫base64**  \n\n3、hashlib摘要算法库，md5,SHA1。md5结果是128bit,SHA1结果是160bit\n\n\n\timport hashlib\t\n\tmd5 = hashlib.md5()\t\n\tmd5.update(  hello world )\t\n\tmd5.update( hdhhd )\t\n\tprint md5.hexdigest()\n   \n\nSHA1与md5的调用 一样将上述代码改成SHA1即可  \n## 2、python进阶  \n### 2.1、Range与XRange的区别\n在 Range的方法中，它会生成一个**list**的对象，但是在XRange中，它生成的却是一个**xrange的对象**，当返回的东西不是很大的时候，或者在一个 循环里，基本上都是从头查到底的情况下，这两个方法的效率差不多。但是，当返回的东西很大，或者循环中常常会被Break出来的话，还是建议使用 XRange，这样既省空间，又会提高效率。\n\n### 2.2、ArgumentParser处理数组传入\n\n+ nargs说明\n\n||说明|   \n|:--|:--|\n|nargs ='+'|输入至少一个参数|\n|nargs = '*'|输入零个或多个参数|\n\n例如：\n\n\tap = argparse.ArgumentParser()\n    ap.add_argument('-p','--plugins',required = True, nargs = '+', help = 'the channel which you will test')\n\n### 2.3、ConfigParser\n在python开发中经常会遇到配置化问题，也就是将配置写在一个xxxx.conf文件，然后程序根据配置文件做相应的事情。那配置化文件长什么样？又需要怎么样解析？本节`ConfigParser`就是来做这样的事情的。首先，给出一个配置文件示例：   \n\n\t\t[IMSDKLoginFacebook]\n\t\tbundleid = com.tencent.imsdk2\n\t\tsystemlibs = [\"CoreTelephony.framework\",\"CoreLocation.framework\"]\n\t\tbuildsettings = {\"OTHER_LDFLAGS\":\"-ObjC\", \"ENABLE_BITCODE\":\"NO\"}\n\t\txctestfiles = [\"DemoFacebookLoginTests.mm\"]\n\t\tthirdsdks = [\"/IMSDK/Demo/IMSDK/Third/Facebook\"]\n\t\tresources = []\n\t\tinfoplist = {}\n\t\tcapabilites = {}\n接下来就是要解析配置文件\n\n\t\t cf = ConfigParser.ConfigParser()\n       \tcf.read('sample.conf')  #先读取文件\n       \n配置文件内容解析：section, option。`[IMSDKLoginFacebook]`称为section, `resources = []`称为option\n\n\t\tcf.has_section('section') # 判断是否有对应section\n\t\tcf.add_section('section') # 添加section\n\t\tcf.set('section','option','[]') #设置section/option\n\t\tcf.get('section'，‘option’) #获取section/option\n\t\t\n**注意，配置文件都是处理结果都字符串，要想处理其它类型数据可以考虑通过json转换**\n## 3、python实战\n### 3.1、[python制作gif]( http://python.jobbole.com/81185/)，然后可以在ppt导入    \n### 3.2、Tkinter UI  \n1、动态更新UI，使用`config`   \n\n\troot = Tk()\n\tbtn = Button(root,text ='test')\n\tbtn.pack()\n\tbtn.config(state = 'disabled'）\n   \n关于布局有三种，pack,grid,place[参考]( http://www.tutorialspoint.com/python/tk_pack.htm)   \n\n\n## 4、opencv python   \n### 4.1、反转黑白图片\n\n\tthresh = cv2.thrsehold(image,122,255,cv2.THRESH_BINARY_INV)[1]\n  \n\n### 4.2、[python进行条形码检测]( http://python.jobbole.com/81130/)    \n### 4.3、cv2  crop图片  \n\n\timg = image[y:y+h,x:x+w]\n  \n### 4.4、由文本生成图片，[参考](http://python.jobbole.com/81983/)     \n### 4.5、图片生成汉字库，关于怎么样将汉字切片可以[参考](http://python.jobbole.com/81985/)  ","slug":"Python-Dev","published":1,"updated":"2022-06-15T07:23:15.001Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4fa2s9z000ddacotn4cc1ca","content":"<h1 id=\"Python-学习\"><a href=\"#Python-学习\" class=\"headerlink\" title=\"Python 学习\"></a>Python 学习</h1><a id=\"more\"></a>\n<h2 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h2><h3 id=\"1-0、逻辑运算（补充）\"><a href=\"#1-0、逻辑运算（补充）\" class=\"headerlink\" title=\"1.0、逻辑运算（补充）\"></a>1.0、逻辑运算（补充）</h3><table>\n<thead>\n<tr>\n<th>逻辑运算</th>\n<th>python 表示</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>与</td>\n<td>and</td>\n</tr>\n<tr>\n<td>或</td>\n<td>or</td>\n</tr>\n<tr>\n<td>非</td>\n<td>not</td>\n</tr>\n<tr>\n<td>异或</td>\n<td>^</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"1-1、-关于list与tuple-元组-数组\"><a href=\"#1-1、-关于list与tuple-元组-数组\" class=\"headerlink\" title=\"1.1、 关于list与tuple(元组), 数组\"></a>1.1、 关于list与tuple(元组),<font color=\"red\"> <em>数组</em></font></h3><p>1、<code>list</code> 是可变，<code>tuple</code>是不可变，可以用<code>tuple</code>的地方尽量用<code>tuple</code>；  </p>\n<p>2、<code>list</code>利用“[]”表示，<code>tuple</code>利用”()”表示<br>3、数组python用numpy来做的：  </p>\n<pre><code>import numpy\nmatrix = numpy.zeros(shape=(5,2))#创建数组\nprint matrix[i,j]#获取元素\n</code></pre><h3 id=\"1-2、关于dict-set\"><a href=\"#1-2、关于dict-set\" class=\"headerlink\" title=\"1.2、关于dict,set\"></a>1.2、关于dict,set</h3><p>参考c++map,set</p>\n<p><strong>CAUTION:</strong> Python的集合(set)和其他语言类似, 是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算.由于集合是无序的,所以，sets 不支持 索引, 分片, 或其它类序列（sequence-like）的操作。Dict的key必须是不可变的</p>\n<h3 id=\"1-3、关于python的可变参数与关键字参数\"><a href=\"#1-3、关于python的可变参数与关键字参数\" class=\"headerlink\" title=\"1.3、关于python的可变参数与关键字参数\"></a>1.3、关于python的可变参数与关键字参数</h3><p>1、可变参数就是传入的参数的个数是可变定义方式为<code>def func(*args)</code>。可变参数在函数调用时自动组装为一tuple。</p>\n<p>2、关键字参数可以传入零个或多个含参数名的参数也就是键值对，定义方式为<code>def func(**kv)</code>。关键字参数在函数调用时组装成一个dict。</p>\n<p>3、list,tuple可以在变量前面添加<code>*</code>来传入到参数为可变参数的函数，dict同样也可传入到参数为关键字参数的函数。</p>\n<p>4、由于3，对于任意函数我们都可以通过<code>def func(*args,**kv)</code>来调用它，不管他是怎么样定义的。</p>\n<p>5、python函数的参数顺序问题：必须函数，默认参数，可变参数，关键字参数  </p>\n<h3 id=\"1-4、Python所谓的高级我切片与matlab的取第几行几列类似\"><a href=\"#1-4、Python所谓的高级我切片与matlab的取第几行几列类似\" class=\"headerlink\" title=\"1.4、Python所谓的高级我切片与matlab的取第几行几列类似\"></a>1.4、Python所谓的高级我切片与matlab的取第几行几列类似</h3><h3 id=\"1-5、迭代使用for-in或者for-value-in-d-iteatervalues-同时也可以用for-k-v-in-d-iteritems\"><a href=\"#1-5、迭代使用for-in或者for-value-in-d-iteatervalues-同时也可以用for-k-v-in-d-iteritems\" class=\"headerlink\" title=\"1.5、迭代使用for ... in或者for value in d.iteatervalues()同时也可以用for k,v in d.iteritems()\"></a>1.5、迭代使用<code>for ... in</code>或者<code>for value in d.iteatervalues()</code>同时也可以用<code>for k,v in d.iteritems()</code></h3><p>例如：   </p>\n<pre><code>d  = { a :1, b :2}    \nfor key in d:    \nprint key\n</code></pre><p>1、但是要使用迭代一个对象，那么这个对象要是<strong>可迭代的</strong>，<font color=\"red\">方法：可以通过collections 模块的iterable进行判断</font>      </p>\n<h3 id=\"1-6、生成器-Generator\"><a href=\"#1-6、生成器-Generator\" class=\"headerlink\" title=\"1.6、生成器(Generator)\"></a>1.6、生成器(Generator)</h3><p>由于通过列表生成器生成一个列表时，受到内存的限制，列表的容量是有限的。所以如果可以按照一种算法进行推算出来，那就不必创建完整的list从而可以节省大量空间。创建generator的方法有多种：  </p>\n<p>第一种： </p>\n<pre><code>l = [ x*x for x in range(1,11) ]    \ng = (x*x for x in range(1,11))   # g就是一个generator，与列表生成器不同的是[ ]与（ ）的问题  \ng.next()  # generator保存的是算法每次调用next()实际是在计算下一个元素，直到计算到最后的元素，当没有元素时就会抛出StopIteration的错误\nfor n in g: # 由于不断调用next（）函数并不是很方便，由于generator是可迭代对象，因此正确的使用方法是使用迭代\nprint n\n</code></pre><p>第二种：<br>在函数定义中如果包含yield关键字，那么这个函数就是一个generator      </p>\n<pre><code>def fib(max):    \n        n,a,b = 0,0,1    \n        while n&lt;max:    \n            yield b      # yield关键字\n            a,b =b ,a+b    \n            n = n+1\n</code></pre><h3 id=\"1-7、python高函数\"><a href=\"#1-7、python高函数\" class=\"headerlink\" title=\"1.7、python高函数\"></a>1.7、python高函数</h3><p>所谓的高阶函数就是一个函数接收函数作为参数</p>\n<h3 id=\"1-8、map-reduce-filter\"><a href=\"#1-8、map-reduce-filter\" class=\"headerlink\" title=\"1.8、map/reduce/filter\"></a>1.8、map/reduce/filter</h3><p><a href=\"http://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf\" target=\"_blank\" rel=\"noopener\">关于MapReduce文章</a>    </p>\n<ul>\n<li><p>map/reduce demo  </p>\n<pre><code>def str2int(s):    \n    def fn(x,y):    \n       return x*10+y    \n      def char2num (s) :    \n        return {  0  : 0 ,  1  : 1 ,  2  : 2 ,  3  : 3 ,  4  : 4 ,  5  : 5 ,  6  : 6 ,  7  : 7 ,  8  : 8 ,  9  : 9 }[s]\n        return reduce(fn,map(char2num,s))\n</code></pre></li>\n</ul>\n<font color=\"red\"><strong>注意map,reduce都接收一个函数与一个list，因此第5行代码就好理解了</strong>   </font>    \n\n<ul>\n<li>filter 与map/reduce一样都 是高阶函数都是接收一个函数与list变量,filter是根据传入函数作用于每一个元素返回true/false来决定这个元素是否保留</li>\n</ul>\n<pre><code>def is_odd(n):    \n    return n%2 ==1\n       filter(is_odd,[1,2,3,4,5])\n</code></pre><h3 id=\"1-9、funciton-partial偏函数，把一个函数的某些参数给固定住，返回一个新函数，那么调用-这个函数就会简单一些。当一个函数的参数个数太多需要简化的时候可以使用functools-partial创建一个偏函数。\"><a href=\"#1-9、funciton-partial偏函数，把一个函数的某些参数给固定住，返回一个新函数，那么调用-这个函数就会简单一些。当一个函数的参数个数太多需要简化的时候可以使用functools-partial创建一个偏函数。\" class=\"headerlink\" title=\"1.9、funciton.partial偏函数，把一个函数的某些参数给固定住，返回一个新函数，那么调用 这个函数就会简单一些。当一个函数的参数个数太多需要简化的时候可以使用functools.partial创建一个偏函数。\"></a>1.9、<strong>funciton.partial偏函数</strong>，把一个函数的某些参数给固定住，返回一个新函数，那么调用 这个函数就会简单一些。当一个函数的参数个数太多需要简化的时候可以使用functools.partial创建一个偏函数。</h3><pre><code>import functools    \nint2 = functools.partial(int,base = 2) #int2就是一个新函数只有一个参数\n</code></pre><h3 id=\"1-9-1-装饰器及-语法\"><a href=\"#1-9-1-装饰器及-语法\" class=\"headerlink\" title=\"1.9.1 装饰器及 @语法\"></a>1.9.1 装饰器及 <code>@</code>语法</h3><p>开门见山，直上代码</p>\n<pre><code>def log(func):    \n        def wrapper(*args,**kw):    \n            print  call %s %func.__name__\n            return func(*args,**kw)    \nreturn wrapper\n</code></pre><p><code>log</code>函数接收一个函数作为参数，然后返回一个函数，这就叫做decorator。那么怎么用这个decorator呢？代码直上：  </p>\n<pre><code>@log    \ndef now():    \n    print  sdfdsfds \n</code></pre><p><code>@</code>语法相当于：<code>now = log(now)</code>     </p>\n<h3 id=\"1-10、python用模块（module）来组织工程\"><a href=\"#1-10、python用模块（module）来组织工程\" class=\"headerlink\" title=\"1.10、python用模块（module）来组织工程\"></a>1.10、python用模块（module）来组织工程</h3><p>1、使用模块可以避免函数与变量名的冲突。一个.py文件 就是一个模块。</p>\n<p>2、为了避免模块名的冲突python引入package，本质就是按目录来组织模块</p>\n<p>3、package目录下一定要有一<strong>init</strong>.py模块，否则认为普通目录  </p>\n<p>4、注释也可采用  </p>\n<pre><code>‘’‘\n\n注释\n\n’‘’\n</code></pre><h3 id=\"1-11、关于if-name-main\"><a href=\"#1-11、关于if-name-main\" class=\"headerlink\" title=\"1.11、关于if __name__== main:\"></a>1.11、关于<code>if __name__== main:</code></h3><p>当我们用命令行运行模块的时候，Python解释器就会将一个特殊变量<code>__name__</code>置为<code>__main__</code>，而在其它地方导入该模块这个判断就会失败，也就是说这条语句主要是便于我们使用命令行。  </p>\n<h3 id=\"1-12、作用域\"><a href=\"#1-12、作用域\" class=\"headerlink\" title=\"1.12、作用域\"></a>1.12、作用域</h3><p>private访问控制在python里通过<code>_</code>或者<code>__</code>前缀来实现。这里所说的private只是一种编程习惯，因为python并没有private的控制访问。</p>\n<h3 id=\"1-13、python面向对象编程-Object-Oriented-Programming-OOP\"><a href=\"#1-13、python面向对象编程-Object-Oriented-Programming-OOP\" class=\"headerlink\" title=\"1.13、python面向对象编程(Object Oriented Programming,OOP)\"></a>1.13、python面向对象编程(Object Oriented Programming,OOP)</h3><p>话不多说直接上demo</p>\n<pre><code>class Student(object):                                 #表示Student从object继承 \n        def __init__(self,name,score):            #__init__类于构造函数，且第一个参数永远是self，表示创建实例本身。而且实例化对象时一定要传入与__init__参数对应的参数\n\n                self.name = name    \n                self.score = score    \n                super(Student,self).__init__()    #表示调用父类方法\n            def print_score(self):    \n                print  %s,%s %(self.name,self.score)\n</code></pre><p>1、<code>__init__</code>类于构造函数，且第一个参数永远是self，表示创建实例本身。而且实例化对象时一定要传入与<strong>init</strong>参数对应的参数。<br>2、成员函数与普通函数不一样的地方就是第一个参数永远是self<br>3、private访问控制权限就是在变量前面添加<code>__</code>前缀。<code>_</code>在类中视为private但是其实是可以访问的，只是按约定视为private.<br>4、private变量其实也是可以访问的，可以通过<code>_类名_private变量</code>如<code>_Student_name</code><br>5、  super(className,self).function()      父类方法调用<font color=\"red\"> 如果是多继承且多个父类有同样的方法则按顺序调用</font></p>\n<h3 id=\"1-14、关于python的多态\"><a href=\"#1-14、关于python的多态\" class=\"headerlink\" title=\"1.14、关于python的多态\"></a>1.14、关于python的多态</h3><p>由于python里不需要事先声明变量的类型，因此多态实现起来就简单得多：  </p>\n<pre><code>def run(animal):    \n    animal.run()\n</code></pre><p>代码中只要传入的参数有run这个方法就可以，<font color=\"red\"><strong>不管是不是animal还是子类或者不是子类</strong></font>，这样子就与c++里的多态一样。其实本质上是由于python本来就是动态语言。  </p>\n<h3 id=\"1-15、获取对象信息\"><a href=\"#1-15、获取对象信息\" class=\"headerlink\" title=\"1.15、获取对象信息\"></a>1.15、获取对象信息</h3><p>1、type可以判断基本类型的所属类型</p>\n<pre><code>import types    \ntype( ssdfdf )\n</code></pre><p>2、isinstance可以判断基本数据类型还可以判断class类</p>\n<p>3、dir可以获取对象的所有属性和方法</p>\n<p>4、getattr(),setattr(),hasattr()可以操作一个对象的属性，顾名思义  </p>\n<h3 id=\"1-16、python动态绑定方法\"><a href=\"#1-16、python动态绑定方法\" class=\"headerlink\" title=\"1.16、python动态绑定方法\"></a>1.16、python动态绑定方法</h3><pre><code>def set_age(self,age):    \n        self.age = age        \nfrom types import MethodType    \ns.set_age = MethodType(set_age,s,Student)          #给实例新增方法\nStudent.set_age = MethodType(set_age,None,Student)    #给类新增方法\n</code></pre><p>1、<font color=\"red\"><strong><code>__slot__</code></strong></font>关键字</p>\n<p>如果想对class限制只允许给类的实例添加属性时，我们可以使用<code>__slot__</code>，但是不遗传</p>\n<pre><code>class Student(object):    \n__slot__ = ( name , age )  #用tuple定义允许修改的属性名称\n</code></pre><h3 id=\"1-17、-property关键字\"><a href=\"#1-17、-property关键字\" class=\"headerlink\" title=\"1.17、@property关键字\"></a>1.17、<code>@property</code>关键字</h3><p><code>@property</code>负责将一个方法变成属性调用，而与一个属性不同的是属性并没有检查是否合法，而方法是可以进行检查的。</p>\n<pre><code>class Student(object):    \n        @property    \n        def score(self):    \n                return self._score    \n        @score.setter    \n        def score(self,value):    \n                if():\n                        .....#参数检查\n                self._score = value\n\n&gt;&gt;&gt;s = Student()    \n&gt;&gt;&gt;s.score = 10 #实际上是调用的s.set_score()\n&gt;&gt;&gt;s.score #实际上调用 的是s.get_score()\n</code></pre><p><code>@property</code>把一个方法变成属性，<code>@xxx.setter</code>把一个方法变成属性赋值，与OC的property有一点相似</p>\n<h3 id=\"1-18、多重继承\"><a href=\"#1-18、多重继承\" class=\"headerlink\" title=\"1.18、多重继承\"></a>1.18、多重继承</h3><h3 id=\"1-19、定制类\"><a href=\"#1-19、定制类\" class=\"headerlink\" title=\"1.19、定制类\"></a>1.19、定制类</h3><h3 id=\"1-20、元类\"><a href=\"#1-20、元类\" class=\"headerlink\" title=\"1.20、元类\"></a>1.20、元类</h3><p>1、type动态创建一个对象</p>\n<pre><code>hello = type( Hello ,(object,),dict(hello = fn))\n</code></pre><p>type接收三个参数：</p>\n<ul>\n<li><p>class名字</p>\n</li>\n<li><p>参数2 为父类，是一个tuple（object,）</p>\n</li>\n<li><p>dict(hello = fn),绑定函数到类的方法</p>\n</li>\n</ul>\n<p>2、metaclass元类，（OC中也有这个概念）   </p>\n<h3 id=\"1-21、异常捕获try-except-finally\"><a href=\"#1-21、异常捕获try-except-finally\" class=\"headerlink\" title=\"1.21、异常捕获try:....except...finally...\"></a>1.21、异常捕获<code>try:....except...finally...</code></h3><pre><code>try:    \n    print  try....     \n    r = 10/0    \n    print  reuslt: ,r    \nexcept ZeroDivisionError ,e:        #还可以多级捕获\n    print  error: ,e    \nfinally:    \n    print  finally... \n</code></pre><p>1、可以通过<code>raise</code>抛出异常，<code>raise</code>后面不带参数则将错误原样抛出，同样<code>raise</code>也可以修改抛出错误的类型  </p>\n<h3 id=\"1-22、调试\"><a href=\"#1-22、调试\" class=\"headerlink\" title=\"1.22、调试\"></a>1.22、调试</h3><p>1、print打印信息</p>\n<p>2、asser断言</p>\n<p>3、logging推荐，可以定义log级别：debug,info,waning,error ,可以指定输出文件<code>logging.config.fileConfig(filename)</code>,<a href=\"https://docs.python.org/2/library/logging.config.html#logging-config-fileformat\" target=\"_blank\" rel=\"noopener\">filename规则</a>  ，给一个log.conf</p>\n<pre><code>[loggers]\nkeys=root\n\n[handlers]\nkeys=consoleHandler,fileHandler\n\n[formatters]\nkeys=simpleFormatter\n\n[logger_root]\nlevel=DEBUG\nhandlers=consoleHandler,fileHandler\n\n[handler_consoleHandler]\nclass=StreamHandler\nlevel=DEBUG\nformatter=simpleFormatter\nargs=(sys.stdout,)\n\n[handler_fileHandler]\nclass=logging.handlers.TimedRotatingFileHandler\nlevel=DEBUG\nformatter=simpleFormatter\nargs=(&apos;./log/sample.log&apos;,&apos;D&apos;,1,14)\n#args=(&apos;/data/iTOP_ROOT/dev/log/admin/pack/sample.log&apos;,&apos;D&apos;,1,14)\n\n[formatter_simpleFormatter]\nformat=[%(asctime)s][pid %(process)d][%(levelname)s][%(filename)s:%(lineno)d]%(message)s\ndatefmt=\n</code></pre><p>使用方式：  </p>\n<pre><code>logging.config.fileConfig(&apos;./log.conf&apos;)\nlogger = logging.getLogger(&apos;root&apos;)\n</code></pre><p>还可以直接使用代码： </p>\n<pre><code>import logging\n\nlogger = logging.getLogger()\nhandler = logging.StreamHandler()\nformatter = logging.Formatter(\n        &apos;%(asctime)s %(name)-12s %(levelname)-8s %(message)s&apos;)\nhandler.setFormatter(formatter)\nlogger.addHandler(handler)\nlogger.setLevel(logging.DEBUG)\n</code></pre><p>4、<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138683229901532c40b749184441dbd428d2e0f8aa50e000\" target=\"_blank\" rel=\"noopener\">pdb</a>   </p>\n<h3 id=\"1-23、单元测试\"><a href=\"#1-23、单元测试\" class=\"headerlink\" title=\"1.23、单元测试\"></a>1.23、单元测试</h3><h3 id=\"1-24、文档测试（测试注释了的代码–python交互式代码）\"><a href=\"#1-24、文档测试（测试注释了的代码–python交互式代码）\" class=\"headerlink\" title=\"1.24、文档测试（测试注释了的代码–python交互式代码）\"></a>1.24、文档测试（测试注释了的代码–python交互式代码）</h3><h3 id=\"1-25、IO编程\"><a href=\"#1-25、IO编程\" class=\"headerlink\" title=\"1.25、IO编程\"></a>1.25、IO编程</h3><p>1、文件读写   </p>\n<pre><code>f = open(filename,r)\nf.read()\nf.close\n</code></pre><p>为了保证会调用<code>close()</code>同时也是为了简单化，Python引入了<code>with</code>语法来帮助我们调用<code>close()</code></p>\n<pre><code>with open( filename ,r ) as f:\n        print f.read()\n</code></pre><p>2、<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868321590543ff305fb9f9949f08d760883cc243812000\" target=\"_blank\" rel=\"noopener\">操作文件和目录</a>    </p>\n<p>3、序列化   </p>\n<ul>\n<li><p>python中序列化提供了两个模块来实现：<code>cPickle</code>和<code>pickle</code>(有<code>c</code>开头的就是用c语言实现的)<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138683221577998e407bb309542d9b6a68d9276bc3dbe000\" target=\"_blank\" rel=\"noopener\">pickle参考</a>   </p>\n</li>\n<li><p>json，<code>pickle</code>的问题在于序列化只能用在python中不能进行传递或者其它语言来解释，json刚好可以解决这个问题。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>json</th>\n<th>python</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>{ }</td>\n<td>dict</td>\n</tr>\n<tr>\n<td>[ ]</td>\n<td>list</td>\n</tr>\n<tr>\n<td>“string”</td>\n<td>str 或者u unicode</td>\n</tr>\n<tr>\n<td>123.4</td>\n<td>int 或者 float</td>\n</tr>\n<tr>\n<td>true/false</td>\n<td>Ture /False</td>\n</tr>\n<tr>\n<td>null</td>\n<td>None</td>\n</tr>\n</tbody>\n</table>\n<pre><code>import josn    \nd = dict(name = &apos;Bob&apos;,age = 10,score = 88)    json.dumps(d)  #dump意为转储    \njson.loads(str)#转成dict python对象\n</code></pre><p><font color=\"red\"><strong>CAUTION:</strong></font>json反序列化得到字符串对象都是unicode不是str。  </p>\n<ul>\n<li>class 序列化（json的进阶）   </li>\n</ul>\n<pre><code>json.dumps(s, \ndefault\n=lambda obj: obj.__dict__)#当class有__slot__属性时不能用 \n</code></pre><h3 id=\"1-26、进程与线程\"><a href=\"#1-26、进程与线程\" class=\"headerlink\" title=\"1.26、进程与线程\"></a>1.26、<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868323401155ceb3db1e2044f80b974b469eb06cb43000\" target=\"_blank\" rel=\"noopener\">进程与线程</a></h3><p>1、进程</p>\n<ul>\n<li><p>Unix/Linux下可以调用<code>fork()</code>实现多进程</p>\n</li>\n<li><p>跨平台的多进程，可以使用multiprocessing  </p>\n</li>\n<li><p>进程间的通信可以使用Queue,Pipes  </p>\n</li>\n</ul>\n<p>2、线程，python中有两个模块（thread,threading，后者是高级，我们一般使用高级）</p>\n<ul>\n<li><p>线程与进程最大的不同是，同一个变量在进程中是各自有一份copy互不影响，而多线程中所有的线程共享进程的变量，是相互影响的。因此在多线程中我们使用Lock来保证变量的不相互影响   </p>\n<pre><code>import time, threading     \nbalance = 0\nlock = threading.Lock()\ndef change_it(n):        \n        global balance       \n         balance = balance + n    \n         balance = balance - n \n def run_thread(n):        \n        for i in range(100000):\n               lock.acquire()     #先获取锁                   try:                #try...finally保证不管什么情况下都会释放locK\n                   change_it(n)\n               finally:\n                   lock.release()  #释放锁\nif __name__ ==  __main__ :\n      t1 = threading.Thread(target=run_thread, args=(5,)) \n      t2 = threading.Thread(target=run_thread, args=(8,))   \n      t1.start()       \n      t2.start()       \n     t1.join()        \n    t2.join()      \n    print balance\n</code></pre></li>\n</ul>\n<ul>\n<li>在多线程下每一个线程要保持自己的数据时，我们可使用ThreadLocal, <strong>ThreadLocal最常用的地方就是为每一个线程绑定一个数据库链接，http请求，用户身份信息等</strong></li>\n</ul>\n<pre><code>import threading    \nlocal_shcool = threading.local()  #每一个线程都可以写，且相互不影响，可以理解为一个以thread为key的dict\ndef pro_std():    \n    print hello,%s (in %s) %(loca_school.student,threading.current_thread().name)\ndef pro_thread(name):    \n    local_shcool.student = name    \n            pro_std()    \nt1 = threading.Thread(target = pro_thread,args = ( Alice ),name =  a )\nt2 = threading.Thread(target = pro_thread,args = ( Bob ),name =  B )\nt1.start()    \nt2.start()    \nt1.join()    \nt2.join()    \n</code></pre><h3 id=\"1-27、分布式编程\"><a href=\"#1-27、分布式编程\" class=\"headerlink\" title=\"1.27、分布式编程\"></a>1.27、分布式编程</h3><p><a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386832973658c780d8bfa4c6406f83b2b3097aed5df6000\" target=\"_blank\" rel=\"noopener\">参考</a>   </p>\n<h3 id=\"1-28、正则表达式\"><a href=\"#1-28、正则表达式\" class=\"headerlink\" title=\"1.28、正则表达式\"></a>1.28、正则表达式</h3><h3 id=\"1-29常用内嵌模块\"><a href=\"#1-29常用内嵌模块\" class=\"headerlink\" title=\"1.29常用内嵌模块\"></a>1.29常用内嵌模块</h3><p>1、collections</p>\n<p>2、base64:base64是一种任意二进制到文本字符串的编码方法。<strong>关于base64的理解：将3个字符串转成4个字符串，3 * 8 = 4*6，因此叫base64</strong>  </p>\n<p>3、hashlib摘要算法库，md5,SHA1。md5结果是128bit,SHA1结果是160bit</p>\n<pre><code>import hashlib    \nmd5 = hashlib.md5()    \nmd5.update(  hello world )    \nmd5.update( hdhhd )    \nprint md5.hexdigest()\n</code></pre><p>SHA1与md5的调用 一样将上述代码改成SHA1即可  </p>\n<h2 id=\"2、python进阶\"><a href=\"#2、python进阶\" class=\"headerlink\" title=\"2、python进阶\"></a>2、python进阶</h2><h3 id=\"2-1、Range与XRange的区别\"><a href=\"#2-1、Range与XRange的区别\" class=\"headerlink\" title=\"2.1、Range与XRange的区别\"></a>2.1、Range与XRange的区别</h3><p>在 Range的方法中，它会生成一个<strong>list</strong>的对象，但是在XRange中，它生成的却是一个<strong>xrange的对象</strong>，当返回的东西不是很大的时候，或者在一个 循环里，基本上都是从头查到底的情况下，这两个方法的效率差不多。但是，当返回的东西很大，或者循环中常常会被Break出来的话，还是建议使用 XRange，这样既省空间，又会提高效率。</p>\n<h3 id=\"2-2、ArgumentParser处理数组传入\"><a href=\"#2-2、ArgumentParser处理数组传入\" class=\"headerlink\" title=\"2.2、ArgumentParser处理数组传入\"></a>2.2、ArgumentParser处理数组传入</h3><ul>\n<li>nargs说明</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">nargs =’+’</td>\n<td style=\"text-align:left\">输入至少一个参数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">nargs = ‘*’</td>\n<td style=\"text-align:left\">输入零个或多个参数</td>\n</tr>\n</tbody>\n</table>\n<p>例如：</p>\n<pre><code>ap = argparse.ArgumentParser()\nap.add_argument(&apos;-p&apos;,&apos;--plugins&apos;,required = True, nargs = &apos;+&apos;, help = &apos;the channel which you will test&apos;)\n</code></pre><h3 id=\"2-3、ConfigParser\"><a href=\"#2-3、ConfigParser\" class=\"headerlink\" title=\"2.3、ConfigParser\"></a>2.3、ConfigParser</h3><p>在python开发中经常会遇到配置化问题，也就是将配置写在一个xxxx.conf文件，然后程序根据配置文件做相应的事情。那配置化文件长什么样？又需要怎么样解析？本节<code>ConfigParser</code>就是来做这样的事情的。首先，给出一个配置文件示例：   </p>\n<pre><code>[IMSDKLoginFacebook]\nbundleid = com.tencent.imsdk2\nsystemlibs = [&quot;CoreTelephony.framework&quot;,&quot;CoreLocation.framework&quot;]\nbuildsettings = {&quot;OTHER_LDFLAGS&quot;:&quot;-ObjC&quot;, &quot;ENABLE_BITCODE&quot;:&quot;NO&quot;}\nxctestfiles = [&quot;DemoFacebookLoginTests.mm&quot;]\nthirdsdks = [&quot;/IMSDK/Demo/IMSDK/Third/Facebook&quot;]\nresources = []\ninfoplist = {}\ncapabilites = {}\n</code></pre><p>接下来就是要解析配置文件</p>\n<pre><code>cf = ConfigParser.ConfigParser()\n  cf.read(&apos;sample.conf&apos;)  #先读取文件\n</code></pre><p>配置文件内容解析：section, option。<code>[IMSDKLoginFacebook]</code>称为section, <code>resources = []</code>称为option</p>\n<pre><code>cf.has_section(&apos;section&apos;) # 判断是否有对应section\ncf.add_section(&apos;section&apos;) # 添加section\ncf.set(&apos;section&apos;,&apos;option&apos;,&apos;[]&apos;) #设置section/option\ncf.get(&apos;section&apos;，‘option’) #获取section/option\n</code></pre><p><strong>注意，配置文件都是处理结果都字符串，要想处理其它类型数据可以考虑通过json转换</strong></p>\n<h2 id=\"3、python实战\"><a href=\"#3、python实战\" class=\"headerlink\" title=\"3、python实战\"></a>3、python实战</h2><h3 id=\"3-1、python制作gif，然后可以在ppt导入\"><a href=\"#3-1、python制作gif，然后可以在ppt导入\" class=\"headerlink\" title=\"3.1、python制作gif，然后可以在ppt导入\"></a>3.1、<a href=\"http://python.jobbole.com/81185/\" target=\"_blank\" rel=\"noopener\">python制作gif</a>，然后可以在ppt导入</h3><h3 id=\"3-2、Tkinter-UI\"><a href=\"#3-2、Tkinter-UI\" class=\"headerlink\" title=\"3.2、Tkinter UI\"></a>3.2、Tkinter UI</h3><p>1、动态更新UI，使用<code>config</code>   </p>\n<pre><code>root = Tk()\nbtn = Button(root,text =&apos;test&apos;)\nbtn.pack()\nbtn.config(state = &apos;disabled&apos;）\n</code></pre><p>关于布局有三种，pack,grid,place<a href=\"http://www.tutorialspoint.com/python/tk_pack.htm\" target=\"_blank\" rel=\"noopener\">参考</a>   </p>\n<h2 id=\"4、opencv-python\"><a href=\"#4、opencv-python\" class=\"headerlink\" title=\"4、opencv python\"></a>4、opencv python</h2><h3 id=\"4-1、反转黑白图片\"><a href=\"#4-1、反转黑白图片\" class=\"headerlink\" title=\"4.1、反转黑白图片\"></a>4.1、反转黑白图片</h3><pre><code>thresh = cv2.thrsehold(image,122,255,cv2.THRESH_BINARY_INV)[1]\n</code></pre><h3 id=\"4-2、python进行条形码检测\"><a href=\"#4-2、python进行条形码检测\" class=\"headerlink\" title=\"4.2、python进行条形码检测\"></a>4.2、<a href=\"http://python.jobbole.com/81130/\" target=\"_blank\" rel=\"noopener\">python进行条形码检测</a></h3><h3 id=\"4-3、cv2-crop图片\"><a href=\"#4-3、cv2-crop图片\" class=\"headerlink\" title=\"4.3、cv2  crop图片\"></a>4.3、cv2  crop图片</h3><pre><code>img = image[y:y+h,x:x+w]\n</code></pre><h3 id=\"4-4、由文本生成图片，参考\"><a href=\"#4-4、由文本生成图片，参考\" class=\"headerlink\" title=\"4.4、由文本生成图片，参考\"></a>4.4、由文本生成图片，<a href=\"http://python.jobbole.com/81983/\" target=\"_blank\" rel=\"noopener\">参考</a></h3><h3 id=\"4-5、图片生成汉字库，关于怎么样将汉字切片可以参考\"><a href=\"#4-5、图片生成汉字库，关于怎么样将汉字切片可以参考\" class=\"headerlink\" title=\"4.5、图片生成汉字库，关于怎么样将汉字切片可以参考\"></a>4.5、图片生成汉字库，关于怎么样将汉字切片可以<a href=\"http://python.jobbole.com/81985/\" target=\"_blank\" rel=\"noopener\">参考</a></h3>","site":{"data":{}},"excerpt":"<h1 id=\"Python-学习\"><a href=\"#Python-学习\" class=\"headerlink\" title=\"Python 学习\"></a>Python 学习</h1>","more":"<h2 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h2><h3 id=\"1-0、逻辑运算（补充）\"><a href=\"#1-0、逻辑运算（补充）\" class=\"headerlink\" title=\"1.0、逻辑运算（补充）\"></a>1.0、逻辑运算（补充）</h3><table>\n<thead>\n<tr>\n<th>逻辑运算</th>\n<th>python 表示</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>与</td>\n<td>and</td>\n</tr>\n<tr>\n<td>或</td>\n<td>or</td>\n</tr>\n<tr>\n<td>非</td>\n<td>not</td>\n</tr>\n<tr>\n<td>异或</td>\n<td>^</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"1-1、-关于list与tuple-元组-数组\"><a href=\"#1-1、-关于list与tuple-元组-数组\" class=\"headerlink\" title=\"1.1、 关于list与tuple(元组), 数组\"></a>1.1、 关于list与tuple(元组),<font color=\"red\"> <em>数组</em></font></h3><p>1、<code>list</code> 是可变，<code>tuple</code>是不可变，可以用<code>tuple</code>的地方尽量用<code>tuple</code>；  </p>\n<p>2、<code>list</code>利用“[]”表示，<code>tuple</code>利用”()”表示<br>3、数组python用numpy来做的：  </p>\n<pre><code>import numpy\nmatrix = numpy.zeros(shape=(5,2))#创建数组\nprint matrix[i,j]#获取元素\n</code></pre><h3 id=\"1-2、关于dict-set\"><a href=\"#1-2、关于dict-set\" class=\"headerlink\" title=\"1.2、关于dict,set\"></a>1.2、关于dict,set</h3><p>参考c++map,set</p>\n<p><strong>CAUTION:</strong> Python的集合(set)和其他语言类似, 是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算.由于集合是无序的,所以，sets 不支持 索引, 分片, 或其它类序列（sequence-like）的操作。Dict的key必须是不可变的</p>\n<h3 id=\"1-3、关于python的可变参数与关键字参数\"><a href=\"#1-3、关于python的可变参数与关键字参数\" class=\"headerlink\" title=\"1.3、关于python的可变参数与关键字参数\"></a>1.3、关于python的可变参数与关键字参数</h3><p>1、可变参数就是传入的参数的个数是可变定义方式为<code>def func(*args)</code>。可变参数在函数调用时自动组装为一tuple。</p>\n<p>2、关键字参数可以传入零个或多个含参数名的参数也就是键值对，定义方式为<code>def func(**kv)</code>。关键字参数在函数调用时组装成一个dict。</p>\n<p>3、list,tuple可以在变量前面添加<code>*</code>来传入到参数为可变参数的函数，dict同样也可传入到参数为关键字参数的函数。</p>\n<p>4、由于3，对于任意函数我们都可以通过<code>def func(*args,**kv)</code>来调用它，不管他是怎么样定义的。</p>\n<p>5、python函数的参数顺序问题：必须函数，默认参数，可变参数，关键字参数  </p>\n<h3 id=\"1-4、Python所谓的高级我切片与matlab的取第几行几列类似\"><a href=\"#1-4、Python所谓的高级我切片与matlab的取第几行几列类似\" class=\"headerlink\" title=\"1.4、Python所谓的高级我切片与matlab的取第几行几列类似\"></a>1.4、Python所谓的高级我切片与matlab的取第几行几列类似</h3><h3 id=\"1-5、迭代使用for-in或者for-value-in-d-iteatervalues-同时也可以用for-k-v-in-d-iteritems\"><a href=\"#1-5、迭代使用for-in或者for-value-in-d-iteatervalues-同时也可以用for-k-v-in-d-iteritems\" class=\"headerlink\" title=\"1.5、迭代使用for ... in或者for value in d.iteatervalues()同时也可以用for k,v in d.iteritems()\"></a>1.5、迭代使用<code>for ... in</code>或者<code>for value in d.iteatervalues()</code>同时也可以用<code>for k,v in d.iteritems()</code></h3><p>例如：   </p>\n<pre><code>d  = { a :1, b :2}    \nfor key in d:    \nprint key\n</code></pre><p>1、但是要使用迭代一个对象，那么这个对象要是<strong>可迭代的</strong>，<font color=\"red\">方法：可以通过collections 模块的iterable进行判断</font>      </p>\n<h3 id=\"1-6、生成器-Generator\"><a href=\"#1-6、生成器-Generator\" class=\"headerlink\" title=\"1.6、生成器(Generator)\"></a>1.6、生成器(Generator)</h3><p>由于通过列表生成器生成一个列表时，受到内存的限制，列表的容量是有限的。所以如果可以按照一种算法进行推算出来，那就不必创建完整的list从而可以节省大量空间。创建generator的方法有多种：  </p>\n<p>第一种： </p>\n<pre><code>l = [ x*x for x in range(1,11) ]    \ng = (x*x for x in range(1,11))   # g就是一个generator，与列表生成器不同的是[ ]与（ ）的问题  \ng.next()  # generator保存的是算法每次调用next()实际是在计算下一个元素，直到计算到最后的元素，当没有元素时就会抛出StopIteration的错误\nfor n in g: # 由于不断调用next（）函数并不是很方便，由于generator是可迭代对象，因此正确的使用方法是使用迭代\nprint n\n</code></pre><p>第二种：<br>在函数定义中如果包含yield关键字，那么这个函数就是一个generator      </p>\n<pre><code>def fib(max):    \n        n,a,b = 0,0,1    \n        while n&lt;max:    \n            yield b      # yield关键字\n            a,b =b ,a+b    \n            n = n+1\n</code></pre><h3 id=\"1-7、python高函数\"><a href=\"#1-7、python高函数\" class=\"headerlink\" title=\"1.7、python高函数\"></a>1.7、python高函数</h3><p>所谓的高阶函数就是一个函数接收函数作为参数</p>\n<h3 id=\"1-8、map-reduce-filter\"><a href=\"#1-8、map-reduce-filter\" class=\"headerlink\" title=\"1.8、map/reduce/filter\"></a>1.8、map/reduce/filter</h3><p><a href=\"http://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf\" target=\"_blank\" rel=\"noopener\">关于MapReduce文章</a>    </p>\n<ul>\n<li><p>map/reduce demo  </p>\n<pre><code>def str2int(s):    \n    def fn(x,y):    \n       return x*10+y    \n      def char2num (s) :    \n        return {  0  : 0 ,  1  : 1 ,  2  : 2 ,  3  : 3 ,  4  : 4 ,  5  : 5 ,  6  : 6 ,  7  : 7 ,  8  : 8 ,  9  : 9 }[s]\n        return reduce(fn,map(char2num,s))\n</code></pre></li>\n</ul>\n<font color=\"red\"><strong>注意map,reduce都接收一个函数与一个list，因此第5行代码就好理解了</strong>   </font>    \n\n<ul>\n<li>filter 与map/reduce一样都 是高阶函数都是接收一个函数与list变量,filter是根据传入函数作用于每一个元素返回true/false来决定这个元素是否保留</li>\n</ul>\n<pre><code>def is_odd(n):    \n    return n%2 ==1\n       filter(is_odd,[1,2,3,4,5])\n</code></pre><h3 id=\"1-9、funciton-partial偏函数，把一个函数的某些参数给固定住，返回一个新函数，那么调用-这个函数就会简单一些。当一个函数的参数个数太多需要简化的时候可以使用functools-partial创建一个偏函数。\"><a href=\"#1-9、funciton-partial偏函数，把一个函数的某些参数给固定住，返回一个新函数，那么调用-这个函数就会简单一些。当一个函数的参数个数太多需要简化的时候可以使用functools-partial创建一个偏函数。\" class=\"headerlink\" title=\"1.9、funciton.partial偏函数，把一个函数的某些参数给固定住，返回一个新函数，那么调用 这个函数就会简单一些。当一个函数的参数个数太多需要简化的时候可以使用functools.partial创建一个偏函数。\"></a>1.9、<strong>funciton.partial偏函数</strong>，把一个函数的某些参数给固定住，返回一个新函数，那么调用 这个函数就会简单一些。当一个函数的参数个数太多需要简化的时候可以使用functools.partial创建一个偏函数。</h3><pre><code>import functools    \nint2 = functools.partial(int,base = 2) #int2就是一个新函数只有一个参数\n</code></pre><h3 id=\"1-9-1-装饰器及-语法\"><a href=\"#1-9-1-装饰器及-语法\" class=\"headerlink\" title=\"1.9.1 装饰器及 @语法\"></a>1.9.1 装饰器及 <code>@</code>语法</h3><p>开门见山，直上代码</p>\n<pre><code>def log(func):    \n        def wrapper(*args,**kw):    \n            print  call %s %func.__name__\n            return func(*args,**kw)    \nreturn wrapper\n</code></pre><p><code>log</code>函数接收一个函数作为参数，然后返回一个函数，这就叫做decorator。那么怎么用这个decorator呢？代码直上：  </p>\n<pre><code>@log    \ndef now():    \n    print  sdfdsfds \n</code></pre><p><code>@</code>语法相当于：<code>now = log(now)</code>     </p>\n<h3 id=\"1-10、python用模块（module）来组织工程\"><a href=\"#1-10、python用模块（module）来组织工程\" class=\"headerlink\" title=\"1.10、python用模块（module）来组织工程\"></a>1.10、python用模块（module）来组织工程</h3><p>1、使用模块可以避免函数与变量名的冲突。一个.py文件 就是一个模块。</p>\n<p>2、为了避免模块名的冲突python引入package，本质就是按目录来组织模块</p>\n<p>3、package目录下一定要有一<strong>init</strong>.py模块，否则认为普通目录  </p>\n<p>4、注释也可采用  </p>\n<pre><code>‘’‘\n\n注释\n\n’‘’\n</code></pre><h3 id=\"1-11、关于if-name-main\"><a href=\"#1-11、关于if-name-main\" class=\"headerlink\" title=\"1.11、关于if __name__== main:\"></a>1.11、关于<code>if __name__== main:</code></h3><p>当我们用命令行运行模块的时候，Python解释器就会将一个特殊变量<code>__name__</code>置为<code>__main__</code>，而在其它地方导入该模块这个判断就会失败，也就是说这条语句主要是便于我们使用命令行。  </p>\n<h3 id=\"1-12、作用域\"><a href=\"#1-12、作用域\" class=\"headerlink\" title=\"1.12、作用域\"></a>1.12、作用域</h3><p>private访问控制在python里通过<code>_</code>或者<code>__</code>前缀来实现。这里所说的private只是一种编程习惯，因为python并没有private的控制访问。</p>\n<h3 id=\"1-13、python面向对象编程-Object-Oriented-Programming-OOP\"><a href=\"#1-13、python面向对象编程-Object-Oriented-Programming-OOP\" class=\"headerlink\" title=\"1.13、python面向对象编程(Object Oriented Programming,OOP)\"></a>1.13、python面向对象编程(Object Oriented Programming,OOP)</h3><p>话不多说直接上demo</p>\n<pre><code>class Student(object):                                 #表示Student从object继承 \n        def __init__(self,name,score):            #__init__类于构造函数，且第一个参数永远是self，表示创建实例本身。而且实例化对象时一定要传入与__init__参数对应的参数\n\n                self.name = name    \n                self.score = score    \n                super(Student,self).__init__()    #表示调用父类方法\n            def print_score(self):    \n                print  %s,%s %(self.name,self.score)\n</code></pre><p>1、<code>__init__</code>类于构造函数，且第一个参数永远是self，表示创建实例本身。而且实例化对象时一定要传入与<strong>init</strong>参数对应的参数。<br>2、成员函数与普通函数不一样的地方就是第一个参数永远是self<br>3、private访问控制权限就是在变量前面添加<code>__</code>前缀。<code>_</code>在类中视为private但是其实是可以访问的，只是按约定视为private.<br>4、private变量其实也是可以访问的，可以通过<code>_类名_private变量</code>如<code>_Student_name</code><br>5、  super(className,self).function()      父类方法调用<font color=\"red\"> 如果是多继承且多个父类有同样的方法则按顺序调用</font></p>\n<h3 id=\"1-14、关于python的多态\"><a href=\"#1-14、关于python的多态\" class=\"headerlink\" title=\"1.14、关于python的多态\"></a>1.14、关于python的多态</h3><p>由于python里不需要事先声明变量的类型，因此多态实现起来就简单得多：  </p>\n<pre><code>def run(animal):    \n    animal.run()\n</code></pre><p>代码中只要传入的参数有run这个方法就可以，<font color=\"red\"><strong>不管是不是animal还是子类或者不是子类</strong></font>，这样子就与c++里的多态一样。其实本质上是由于python本来就是动态语言。  </p>\n<h3 id=\"1-15、获取对象信息\"><a href=\"#1-15、获取对象信息\" class=\"headerlink\" title=\"1.15、获取对象信息\"></a>1.15、获取对象信息</h3><p>1、type可以判断基本类型的所属类型</p>\n<pre><code>import types    \ntype( ssdfdf )\n</code></pre><p>2、isinstance可以判断基本数据类型还可以判断class类</p>\n<p>3、dir可以获取对象的所有属性和方法</p>\n<p>4、getattr(),setattr(),hasattr()可以操作一个对象的属性，顾名思义  </p>\n<h3 id=\"1-16、python动态绑定方法\"><a href=\"#1-16、python动态绑定方法\" class=\"headerlink\" title=\"1.16、python动态绑定方法\"></a>1.16、python动态绑定方法</h3><pre><code>def set_age(self,age):    \n        self.age = age        \nfrom types import MethodType    \ns.set_age = MethodType(set_age,s,Student)          #给实例新增方法\nStudent.set_age = MethodType(set_age,None,Student)    #给类新增方法\n</code></pre><p>1、<font color=\"red\"><strong><code>__slot__</code></strong></font>关键字</p>\n<p>如果想对class限制只允许给类的实例添加属性时，我们可以使用<code>__slot__</code>，但是不遗传</p>\n<pre><code>class Student(object):    \n__slot__ = ( name , age )  #用tuple定义允许修改的属性名称\n</code></pre><h3 id=\"1-17、-property关键字\"><a href=\"#1-17、-property关键字\" class=\"headerlink\" title=\"1.17、@property关键字\"></a>1.17、<code>@property</code>关键字</h3><p><code>@property</code>负责将一个方法变成属性调用，而与一个属性不同的是属性并没有检查是否合法，而方法是可以进行检查的。</p>\n<pre><code>class Student(object):    \n        @property    \n        def score(self):    \n                return self._score    \n        @score.setter    \n        def score(self,value):    \n                if():\n                        .....#参数检查\n                self._score = value\n\n&gt;&gt;&gt;s = Student()    \n&gt;&gt;&gt;s.score = 10 #实际上是调用的s.set_score()\n&gt;&gt;&gt;s.score #实际上调用 的是s.get_score()\n</code></pre><p><code>@property</code>把一个方法变成属性，<code>@xxx.setter</code>把一个方法变成属性赋值，与OC的property有一点相似</p>\n<h3 id=\"1-18、多重继承\"><a href=\"#1-18、多重继承\" class=\"headerlink\" title=\"1.18、多重继承\"></a>1.18、多重继承</h3><h3 id=\"1-19、定制类\"><a href=\"#1-19、定制类\" class=\"headerlink\" title=\"1.19、定制类\"></a>1.19、定制类</h3><h3 id=\"1-20、元类\"><a href=\"#1-20、元类\" class=\"headerlink\" title=\"1.20、元类\"></a>1.20、元类</h3><p>1、type动态创建一个对象</p>\n<pre><code>hello = type( Hello ,(object,),dict(hello = fn))\n</code></pre><p>type接收三个参数：</p>\n<ul>\n<li><p>class名字</p>\n</li>\n<li><p>参数2 为父类，是一个tuple（object,）</p>\n</li>\n<li><p>dict(hello = fn),绑定函数到类的方法</p>\n</li>\n</ul>\n<p>2、metaclass元类，（OC中也有这个概念）   </p>\n<h3 id=\"1-21、异常捕获try-except-finally\"><a href=\"#1-21、异常捕获try-except-finally\" class=\"headerlink\" title=\"1.21、异常捕获try:....except...finally...\"></a>1.21、异常捕获<code>try:....except...finally...</code></h3><pre><code>try:    \n    print  try....     \n    r = 10/0    \n    print  reuslt: ,r    \nexcept ZeroDivisionError ,e:        #还可以多级捕获\n    print  error: ,e    \nfinally:    \n    print  finally... \n</code></pre><p>1、可以通过<code>raise</code>抛出异常，<code>raise</code>后面不带参数则将错误原样抛出，同样<code>raise</code>也可以修改抛出错误的类型  </p>\n<h3 id=\"1-22、调试\"><a href=\"#1-22、调试\" class=\"headerlink\" title=\"1.22、调试\"></a>1.22、调试</h3><p>1、print打印信息</p>\n<p>2、asser断言</p>\n<p>3、logging推荐，可以定义log级别：debug,info,waning,error ,可以指定输出文件<code>logging.config.fileConfig(filename)</code>,<a href=\"https://docs.python.org/2/library/logging.config.html#logging-config-fileformat\" target=\"_blank\" rel=\"noopener\">filename规则</a>  ，给一个log.conf</p>\n<pre><code>[loggers]\nkeys=root\n\n[handlers]\nkeys=consoleHandler,fileHandler\n\n[formatters]\nkeys=simpleFormatter\n\n[logger_root]\nlevel=DEBUG\nhandlers=consoleHandler,fileHandler\n\n[handler_consoleHandler]\nclass=StreamHandler\nlevel=DEBUG\nformatter=simpleFormatter\nargs=(sys.stdout,)\n\n[handler_fileHandler]\nclass=logging.handlers.TimedRotatingFileHandler\nlevel=DEBUG\nformatter=simpleFormatter\nargs=(&apos;./log/sample.log&apos;,&apos;D&apos;,1,14)\n#args=(&apos;/data/iTOP_ROOT/dev/log/admin/pack/sample.log&apos;,&apos;D&apos;,1,14)\n\n[formatter_simpleFormatter]\nformat=[%(asctime)s][pid %(process)d][%(levelname)s][%(filename)s:%(lineno)d]%(message)s\ndatefmt=\n</code></pre><p>使用方式：  </p>\n<pre><code>logging.config.fileConfig(&apos;./log.conf&apos;)\nlogger = logging.getLogger(&apos;root&apos;)\n</code></pre><p>还可以直接使用代码： </p>\n<pre><code>import logging\n\nlogger = logging.getLogger()\nhandler = logging.StreamHandler()\nformatter = logging.Formatter(\n        &apos;%(asctime)s %(name)-12s %(levelname)-8s %(message)s&apos;)\nhandler.setFormatter(formatter)\nlogger.addHandler(handler)\nlogger.setLevel(logging.DEBUG)\n</code></pre><p>4、<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138683229901532c40b749184441dbd428d2e0f8aa50e000\" target=\"_blank\" rel=\"noopener\">pdb</a>   </p>\n<h3 id=\"1-23、单元测试\"><a href=\"#1-23、单元测试\" class=\"headerlink\" title=\"1.23、单元测试\"></a>1.23、单元测试</h3><h3 id=\"1-24、文档测试（测试注释了的代码–python交互式代码）\"><a href=\"#1-24、文档测试（测试注释了的代码–python交互式代码）\" class=\"headerlink\" title=\"1.24、文档测试（测试注释了的代码–python交互式代码）\"></a>1.24、文档测试（测试注释了的代码–python交互式代码）</h3><h3 id=\"1-25、IO编程\"><a href=\"#1-25、IO编程\" class=\"headerlink\" title=\"1.25、IO编程\"></a>1.25、IO编程</h3><p>1、文件读写   </p>\n<pre><code>f = open(filename,r)\nf.read()\nf.close\n</code></pre><p>为了保证会调用<code>close()</code>同时也是为了简单化，Python引入了<code>with</code>语法来帮助我们调用<code>close()</code></p>\n<pre><code>with open( filename ,r ) as f:\n        print f.read()\n</code></pre><p>2、<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868321590543ff305fb9f9949f08d760883cc243812000\" target=\"_blank\" rel=\"noopener\">操作文件和目录</a>    </p>\n<p>3、序列化   </p>\n<ul>\n<li><p>python中序列化提供了两个模块来实现：<code>cPickle</code>和<code>pickle</code>(有<code>c</code>开头的就是用c语言实现的)<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138683221577998e407bb309542d9b6a68d9276bc3dbe000\" target=\"_blank\" rel=\"noopener\">pickle参考</a>   </p>\n</li>\n<li><p>json，<code>pickle</code>的问题在于序列化只能用在python中不能进行传递或者其它语言来解释，json刚好可以解决这个问题。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>json</th>\n<th>python</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>{ }</td>\n<td>dict</td>\n</tr>\n<tr>\n<td>[ ]</td>\n<td>list</td>\n</tr>\n<tr>\n<td>“string”</td>\n<td>str 或者u unicode</td>\n</tr>\n<tr>\n<td>123.4</td>\n<td>int 或者 float</td>\n</tr>\n<tr>\n<td>true/false</td>\n<td>Ture /False</td>\n</tr>\n<tr>\n<td>null</td>\n<td>None</td>\n</tr>\n</tbody>\n</table>\n<pre><code>import josn    \nd = dict(name = &apos;Bob&apos;,age = 10,score = 88)    json.dumps(d)  #dump意为转储    \njson.loads(str)#转成dict python对象\n</code></pre><p><font color=\"red\"><strong>CAUTION:</strong></font>json反序列化得到字符串对象都是unicode不是str。  </p>\n<ul>\n<li>class 序列化（json的进阶）   </li>\n</ul>\n<pre><code>json.dumps(s, \ndefault\n=lambda obj: obj.__dict__)#当class有__slot__属性时不能用 \n</code></pre><h3 id=\"1-26、进程与线程\"><a href=\"#1-26、进程与线程\" class=\"headerlink\" title=\"1.26、进程与线程\"></a>1.26、<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868323401155ceb3db1e2044f80b974b469eb06cb43000\" target=\"_blank\" rel=\"noopener\">进程与线程</a></h3><p>1、进程</p>\n<ul>\n<li><p>Unix/Linux下可以调用<code>fork()</code>实现多进程</p>\n</li>\n<li><p>跨平台的多进程，可以使用multiprocessing  </p>\n</li>\n<li><p>进程间的通信可以使用Queue,Pipes  </p>\n</li>\n</ul>\n<p>2、线程，python中有两个模块（thread,threading，后者是高级，我们一般使用高级）</p>\n<ul>\n<li><p>线程与进程最大的不同是，同一个变量在进程中是各自有一份copy互不影响，而多线程中所有的线程共享进程的变量，是相互影响的。因此在多线程中我们使用Lock来保证变量的不相互影响   </p>\n<pre><code>import time, threading     \nbalance = 0\nlock = threading.Lock()\ndef change_it(n):        \n        global balance       \n         balance = balance + n    \n         balance = balance - n \n def run_thread(n):        \n        for i in range(100000):\n               lock.acquire()     #先获取锁                   try:                #try...finally保证不管什么情况下都会释放locK\n                   change_it(n)\n               finally:\n                   lock.release()  #释放锁\nif __name__ ==  __main__ :\n      t1 = threading.Thread(target=run_thread, args=(5,)) \n      t2 = threading.Thread(target=run_thread, args=(8,))   \n      t1.start()       \n      t2.start()       \n     t1.join()        \n    t2.join()      \n    print balance\n</code></pre></li>\n</ul>\n<ul>\n<li>在多线程下每一个线程要保持自己的数据时，我们可使用ThreadLocal, <strong>ThreadLocal最常用的地方就是为每一个线程绑定一个数据库链接，http请求，用户身份信息等</strong></li>\n</ul>\n<pre><code>import threading    \nlocal_shcool = threading.local()  #每一个线程都可以写，且相互不影响，可以理解为一个以thread为key的dict\ndef pro_std():    \n    print hello,%s (in %s) %(loca_school.student,threading.current_thread().name)\ndef pro_thread(name):    \n    local_shcool.student = name    \n            pro_std()    \nt1 = threading.Thread(target = pro_thread,args = ( Alice ),name =  a )\nt2 = threading.Thread(target = pro_thread,args = ( Bob ),name =  B )\nt1.start()    \nt2.start()    \nt1.join()    \nt2.join()    \n</code></pre><h3 id=\"1-27、分布式编程\"><a href=\"#1-27、分布式编程\" class=\"headerlink\" title=\"1.27、分布式编程\"></a>1.27、分布式编程</h3><p><a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386832973658c780d8bfa4c6406f83b2b3097aed5df6000\" target=\"_blank\" rel=\"noopener\">参考</a>   </p>\n<h3 id=\"1-28、正则表达式\"><a href=\"#1-28、正则表达式\" class=\"headerlink\" title=\"1.28、正则表达式\"></a>1.28、正则表达式</h3><h3 id=\"1-29常用内嵌模块\"><a href=\"#1-29常用内嵌模块\" class=\"headerlink\" title=\"1.29常用内嵌模块\"></a>1.29常用内嵌模块</h3><p>1、collections</p>\n<p>2、base64:base64是一种任意二进制到文本字符串的编码方法。<strong>关于base64的理解：将3个字符串转成4个字符串，3 * 8 = 4*6，因此叫base64</strong>  </p>\n<p>3、hashlib摘要算法库，md5,SHA1。md5结果是128bit,SHA1结果是160bit</p>\n<pre><code>import hashlib    \nmd5 = hashlib.md5()    \nmd5.update(  hello world )    \nmd5.update( hdhhd )    \nprint md5.hexdigest()\n</code></pre><p>SHA1与md5的调用 一样将上述代码改成SHA1即可  </p>\n<h2 id=\"2、python进阶\"><a href=\"#2、python进阶\" class=\"headerlink\" title=\"2、python进阶\"></a>2、python进阶</h2><h3 id=\"2-1、Range与XRange的区别\"><a href=\"#2-1、Range与XRange的区别\" class=\"headerlink\" title=\"2.1、Range与XRange的区别\"></a>2.1、Range与XRange的区别</h3><p>在 Range的方法中，它会生成一个<strong>list</strong>的对象，但是在XRange中，它生成的却是一个<strong>xrange的对象</strong>，当返回的东西不是很大的时候，或者在一个 循环里，基本上都是从头查到底的情况下，这两个方法的效率差不多。但是，当返回的东西很大，或者循环中常常会被Break出来的话，还是建议使用 XRange，这样既省空间，又会提高效率。</p>\n<h3 id=\"2-2、ArgumentParser处理数组传入\"><a href=\"#2-2、ArgumentParser处理数组传入\" class=\"headerlink\" title=\"2.2、ArgumentParser处理数组传入\"></a>2.2、ArgumentParser处理数组传入</h3><ul>\n<li>nargs说明</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">nargs =’+’</td>\n<td style=\"text-align:left\">输入至少一个参数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">nargs = ‘*’</td>\n<td style=\"text-align:left\">输入零个或多个参数</td>\n</tr>\n</tbody>\n</table>\n<p>例如：</p>\n<pre><code>ap = argparse.ArgumentParser()\nap.add_argument(&apos;-p&apos;,&apos;--plugins&apos;,required = True, nargs = &apos;+&apos;, help = &apos;the channel which you will test&apos;)\n</code></pre><h3 id=\"2-3、ConfigParser\"><a href=\"#2-3、ConfigParser\" class=\"headerlink\" title=\"2.3、ConfigParser\"></a>2.3、ConfigParser</h3><p>在python开发中经常会遇到配置化问题，也就是将配置写在一个xxxx.conf文件，然后程序根据配置文件做相应的事情。那配置化文件长什么样？又需要怎么样解析？本节<code>ConfigParser</code>就是来做这样的事情的。首先，给出一个配置文件示例：   </p>\n<pre><code>[IMSDKLoginFacebook]\nbundleid = com.tencent.imsdk2\nsystemlibs = [&quot;CoreTelephony.framework&quot;,&quot;CoreLocation.framework&quot;]\nbuildsettings = {&quot;OTHER_LDFLAGS&quot;:&quot;-ObjC&quot;, &quot;ENABLE_BITCODE&quot;:&quot;NO&quot;}\nxctestfiles = [&quot;DemoFacebookLoginTests.mm&quot;]\nthirdsdks = [&quot;/IMSDK/Demo/IMSDK/Third/Facebook&quot;]\nresources = []\ninfoplist = {}\ncapabilites = {}\n</code></pre><p>接下来就是要解析配置文件</p>\n<pre><code>cf = ConfigParser.ConfigParser()\n  cf.read(&apos;sample.conf&apos;)  #先读取文件\n</code></pre><p>配置文件内容解析：section, option。<code>[IMSDKLoginFacebook]</code>称为section, <code>resources = []</code>称为option</p>\n<pre><code>cf.has_section(&apos;section&apos;) # 判断是否有对应section\ncf.add_section(&apos;section&apos;) # 添加section\ncf.set(&apos;section&apos;,&apos;option&apos;,&apos;[]&apos;) #设置section/option\ncf.get(&apos;section&apos;，‘option’) #获取section/option\n</code></pre><p><strong>注意，配置文件都是处理结果都字符串，要想处理其它类型数据可以考虑通过json转换</strong></p>\n<h2 id=\"3、python实战\"><a href=\"#3、python实战\" class=\"headerlink\" title=\"3、python实战\"></a>3、python实战</h2><h3 id=\"3-1、python制作gif，然后可以在ppt导入\"><a href=\"#3-1、python制作gif，然后可以在ppt导入\" class=\"headerlink\" title=\"3.1、python制作gif，然后可以在ppt导入\"></a>3.1、<a href=\"http://python.jobbole.com/81185/\" target=\"_blank\" rel=\"noopener\">python制作gif</a>，然后可以在ppt导入</h3><h3 id=\"3-2、Tkinter-UI\"><a href=\"#3-2、Tkinter-UI\" class=\"headerlink\" title=\"3.2、Tkinter UI\"></a>3.2、Tkinter UI</h3><p>1、动态更新UI，使用<code>config</code>   </p>\n<pre><code>root = Tk()\nbtn = Button(root,text =&apos;test&apos;)\nbtn.pack()\nbtn.config(state = &apos;disabled&apos;）\n</code></pre><p>关于布局有三种，pack,grid,place<a href=\"http://www.tutorialspoint.com/python/tk_pack.htm\" target=\"_blank\" rel=\"noopener\">参考</a>   </p>\n<h2 id=\"4、opencv-python\"><a href=\"#4、opencv-python\" class=\"headerlink\" title=\"4、opencv python\"></a>4、opencv python</h2><h3 id=\"4-1、反转黑白图片\"><a href=\"#4-1、反转黑白图片\" class=\"headerlink\" title=\"4.1、反转黑白图片\"></a>4.1、反转黑白图片</h3><pre><code>thresh = cv2.thrsehold(image,122,255,cv2.THRESH_BINARY_INV)[1]\n</code></pre><h3 id=\"4-2、python进行条形码检测\"><a href=\"#4-2、python进行条形码检测\" class=\"headerlink\" title=\"4.2、python进行条形码检测\"></a>4.2、<a href=\"http://python.jobbole.com/81130/\" target=\"_blank\" rel=\"noopener\">python进行条形码检测</a></h3><h3 id=\"4-3、cv2-crop图片\"><a href=\"#4-3、cv2-crop图片\" class=\"headerlink\" title=\"4.3、cv2  crop图片\"></a>4.3、cv2  crop图片</h3><pre><code>img = image[y:y+h,x:x+w]\n</code></pre><h3 id=\"4-4、由文本生成图片，参考\"><a href=\"#4-4、由文本生成图片，参考\" class=\"headerlink\" title=\"4.4、由文本生成图片，参考\"></a>4.4、由文本生成图片，<a href=\"http://python.jobbole.com/81983/\" target=\"_blank\" rel=\"noopener\">参考</a></h3><h3 id=\"4-5、图片生成汉字库，关于怎么样将汉字切片可以参考\"><a href=\"#4-5、图片生成汉字库，关于怎么样将汉字切片可以参考\" class=\"headerlink\" title=\"4.5、图片生成汉字库，关于怎么样将汉字切片可以参考\"></a>4.5、图片生成汉字库，关于怎么样将汉字切片可以<a href=\"http://python.jobbole.com/81985/\" target=\"_blank\" rel=\"noopener\">参考</a></h3>"},{"title":"Hello World","_content":"Welcome to my blog, this is the begining.","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to my blog, this is the begining.","slug":"hello-world","published":1,"date":"2022-06-15T07:23:15.002Z","updated":"2022-06-15T07:23:15.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4fa2sa0000hdacojxtakfnu","content":"<p>Welcome to my blog, this is the begining.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to my blog, this is the begining.</p>\n"},{"title":"iOS Dev","date":"2017-03-18T03:08:00.000Z","_content":"\n> iOS 学习笔记\n\n<!--More-->\n## 一、iOS基础知识\n### 1、语法\n\n1、类方法里是不可以调用普通方法的。\n\n2、`extension`与`catogry`的区别就是括号中有没有名字。另外`catogry`只可以增加方法不能增加属性，`extension`是可以增加属性的   \n\n3、`self`的赋值一定要在`initxxx`系列函数里调用，不能在别的函数里调用，`initialxxx`都不行\n\n\n### 2、关于在一个工程中添加自定义framework\n\n1、添加方式：File->New->Target->Cocoa Touch Framework\n2、真机测试时可会出现dyld:Library no loaded:....   \n**解决方法**：在app对应的Target->General->Embedded Binaries 添加自定义framwork\n\n### 3、Framework 命令行编译\n\n利用xcode tools[参考](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html),命令如下：\n\n> xcodebuild clean build -project /Users/yuanchengsu/Desktop/iMSDK/iMSDK/iOS/IMSDK/IMSDK.xcodeproj \n-target IMSDKCoreKit -configuration Release  -xcconfig /Users/yuanchengsu/Desktop/iMSDK/iMSDK/iOS/IMSDK/Demo/Configurations/IMSDKGNU++98.xcconfig -sdk iphoneos9.1\n\n\n### 4.[KVO]( https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html)     \n### 5.[ios https](http://io.diveinedu.com/2016/01/09/iOS%E5%BA%94%E7%94%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8BHTTPS.html)\n### 6.runloop     \nrunloop只有在开启第二个线程的时候才考虑使用runloop，而且也并非所有的线程需要runloop\n+ 使用runloop的情况    \n  + use ports or custom input sources to communicate with other threads\n  + use timers on the thread\n  + use any of the `performSelector...`\n  + keep the thread around of perform periodic tasks     \n  \n+ performselector在后台执行时，必须开启一个runloop，否则调用不了     \n+ runLoop有两套API，NSRunloop,CFRunLoopRef     \n+ runLoop在获取时，就是创建\n+ 一个runloop有两个CFRunloopSource,source0:处理UIEvent，CFSocket,source1:mach port,CFMachPort,CFMessagePort;一种mode:default,tracking,common     \n\n### 7.copy与retain    \n+ copy是指拷贝内容    \n+ retain是指拷贝指针     \n+ copy需要对象遵守NSCopying协议的    \n+     \n\n### 8.关于xcode查看汇编的方法   \n+ xcode 7.x: Debug ==> Debug Workflow ==> Show Disassembly when Debugging     \n+ xocde 7.x之前： Product ==> Debug Workflow ==> Show Disassembly when Debugging    \n\n### 9.oc严格单例\n\n创建对象的步骤分为申请内存(alloc)、初始化(init)这两个步骤，我们要确保对象的唯一性，因此在第一步这个阶段我们就要拦截它。当我们调用alloc方法时，oc内部会调用allocWithZone这个方法来申请内存，我们覆写这个方法，然后在这个方法中调用shareInstance方法返回单例对象，这样就可以达到我们的目的。拷贝对象也是同样的原理，覆写copyWithZone方法，然后在这个方法中调用shareInstance方法返回单例对象。看代码吧：\n\n```\n\n\t+(instancetype) sharedInstance\n\t{\n\t    static IMSDKLocalLog *_instance = nil;\n\t    static dispatch_once_t onceToken ;\n\t    dispatch_once(&onceToken, ^{\n\t        _instance = [[super allocWithZone:NULL] initSingleton];// 继承可能有问题\n\t    }) ;\n\t    \n\t    return _instance ;\n\t}\n\t\n\t+(id) allocWithZone:(struct _NSZone *)zone\n\t{\n\t    return [IMSDKLocalLog sharedInstance];\n\t}\n\t\n\t- (id) copyWithZone:(NSZone *)zone\n\t{\n\t    return [IMSDKLocalLog sharedInstance];\n\t}\n\t\n\t- (id) mutablecopyWithZone:(NSZone *)zone\n\t{\n\t    return [IMSDKLocalLog sharedInstance];\n\t}\n\t\n\t\n\t- (instancetype)initSingleton {\n\t    self = [super init];\n\t    if (self) {        //TODO\n\t        _logfile = @\"\";\n\t        _maxLogSize = 20*1024*1024;\n\t        _maxFileSize = 512*1024;\n\t        _retry = 3;\n\t    }\n\t    return self;\n\t} \n```    \n### 10、xcode 切换/build\n1. xcodebuild -verison   (查看你的xcode版本)   \n2. sudo xcode-select -switch xcode path , 例如：</Applications/Xcode8.0.app/Contents/Developer  > (如果需要切换)    \n3. xcodebuild -target {你的工程名字}    \n\n### 11、关于`[NSString UTF8String]`返回null的问题\n+ 首先，在使用UTF8String时要做好保护，因为其返回是可能为空的只是概率不高；\n+ 返回null的一种可能情况：    \n\n```\n\nNSString *ns = @\"sdfhsdjf % C dsfsd\";\nconst char *s = [ns UTF8String];   \n```\n\n**原因：在字符串中出现了`% C`占位符。占位符的意义是会将指定内存格式化，但是这里没有指定内存，另外`%C`会将指定内存转为UTF-16，这样ns字符串中概率性的会出现非UTF8字符，所以转UTF8String时是会出现null的**\n## 二、关于certificates 和provisioning proflies\n\n1、certificates：key(private key)\n\n2、provisioning profiles:(public key)\n\n + appid(bundle identifier) \n\n\n + devices(uuid)\n\n\n + certificates(private key)  \n\n3、.p12是证书导出保存的形式     \n4、wwdr证书失效会导致自己证书无效\n\n\n## 三、关于Clang 与LLVM  \n\n\nClang 是一个 C++ 编写、基于 LLVM、发布于 LLVM BSD 许可证下的/C++/Objective C/Objective C++ 编译器。LLVM 是 Low Level Virtual Machine。具体介绍参考[clang and llvm]( http://objccn.io/issue-6-2/)\n\n+ 命令clang -E 是用于宏定义展开  \n\n   \n\n## 四、反馈系统UI设计问题：\n\n\n\n\n\n1、toolbar的设计问题，当用storyboard进行布局的时候要做到适配效果子在UIbarbuttonItem之间加入flexispace才能做到适配。\n\n2、关于storyboard initialViewcontrollerwithIdentiy的问题，当view还没出现的时生成的对象的成员都会是空的，只有到显示的时候才会出现。解决要对其进行参数传递的时候要采用property方法或者利用dispatch_after方式来做\n\n3、关于ipad版本浮动窗口形式的问题。当在ipad版本下设置Modalpresentationstyle就可以达到这种效果\n4、关于storyboard的问题。一个app中可以有多个storyboard，通过instantiateviewcontrollerwithidentiter方式 来进行实例化。要注意的是storyboard要放到 mainbundle目录下\n5、消除返回按钮上的文字，利用self.naviagtionitem.backbuttonitem = [[uibarbuttom alloc ]initwithtitle:@\"\"] style:\n\ntarget:action];[参见]( http://www.cnblogs.com/ygm900/p/3659619.html )  \n\n## 五、关于isKindOfClass与isMemberOfClass的区别：\n\n1、isKindOfClass，是判断一个对象是属于哪个类~~ 型，一直追溯到父类~~ 。或者子类的实例\n\n2、isMemberClass，是判断一个对象属于哪个类~~ 型，不追溯到父类!~~ 。   \n## 六、Core Data编程\n1、core data 与sql的一些对应关系：\n\n| 功能 | sql |core data| \n| -- | -- |--|  \n|表头|表结构,实体，entity|NSEntityDescription|   \n|表中的一行数据|记录|NSManagedObject| \n|查询|查询,select ...|NSFetchRequest|   \n|持久化|表存储,。。。|NSPersistentStoreCoordinator|   \n|数据库的设计，也就是.xcodemodel文件|数据库模型,。。。|NSManagedObjectModel|   \n|操作上下文|数据库操作|NSManagedObjectContext|  \n[更详细的底层操作](http://objccn.io/issue-4-1/)       \n2、`NSManagedObjectContext`\n`NSManagedObjectContext`是程序员主要接触的一个类，也就是所有的操作基本上都通过它来操作的，底层是怎么实现的我们不需要去关心  \n3、`NSPersistentStoreCoordinator`\n`NSPersistentStoreCoordinator`才是最终的操作实现都是才是核心,[参考](http://objccn.io/issue-4-1)   \n4、[编程参考](http://iiiyu.com/2013/03/29/learning-ios-notes-eighteen/)\n## 七、关于异步加载问题\n1、`nsdata datawithcontentsofurl`是一个同步加载方法，因此要使用此方法要采用异步加载方法。可以适用于加载图片等；\n2、注意`AFNertworking success/failure block` invoked in main thread。如果 没有进行队列设置默认会返回到主线程去。 \n \n\n\n\tif(sucess)\n\t{\n\tdispatch_group_async(self.completionGroup?:http_request_operation_completion_group(),self.completionQueue?:dispatch_get_main_queue(),^{});\n\t}   \n     \n\n\n## 八、关于 strong,weak引用修饰符  \n\n1、strong相当于手动引用计数（manual reference count）中的retain，拥有对象直到对象释放。\n2、weak与strong刚好相反，weak并不持有对象，而且当对象释放时weak我修饰的对象会自动赋值为nil。例如：   \n\n\n\n\tid _weak obj = [[NSObject alloc]init];//错误，weak不能持有对象\t\n\tid _weak oo = nil;\n\t{\n\t   id strong object = [[NSObject alloc]init];\n\t   oo= object\n\t   NSLog(@\"%@\",oo)//此处对象是存在的\n\t}\n     \n\n\n## 九、[关于draweRect消耗内存](http://bihongbo.com/2016/01/03/memoryGhostdrawRect/)  \n要想搞明白这个问题，我们需要撸一撸在`iOS`程序上图形显示的原理。在`iOS`系统中所有显示的视图都是从基类`UIView`继承而来的，同时`UIView`负责接收用户交互。**但是实际上你所看到的视图内容，包括图形等，都是由`UIView`的一个实例图层属性来绘制和渲染的，那就是`CALayer`。**\n**最终我们的图形渲染落点落在`contents`身上**![如图](http://7xkdhe.com1.z0.glb.clouddn.com/drawRect3.001.png)。\n`contents`也被称为寄宿图，除了给它赋值`CGImage`之外，我们也可以直接对它进行绘制，绘制的方法正是这次问题的关键，通过继承`UIView`并实现`-drawRect:`方法即可自定义绘制。`-drawRect:` 方法没有默认的实现，因为对`UIView`来说，寄宿图并不是必须的，`UIView`不关心绘制的内容。如果`UIView`检测到`-drawRect:`方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以`contentsScale`(这个属性与屏幕分辨率有关，我们的画板程序在不同模拟器下呈现的内存用量不同也是因为它)的值。这也就是`-drawRect:`消耗内存的原因。\n\n**解决方案：**使用CAShapeLayer,另外与屏幕大小的画板可以算出消耗内存几M左右，可以接受   \n## 十、[关于设置圆角问题](http://www.cocoachina.com/ios/20160301/15486.html)  \n\n\n由于设置圆角发生离屏渲染，所以对    \n\n## 十一、[数据持久化]( http://casatwy.com/iosying-yong-jia-gou-tan-ben-di-chi-jiu-hua-fang-an-ji-dong-tai-bu-shu.html)\n\n1.使用 archive的对象需要实现<NSCoding>里的方法，关于NSCoder怎么使用参考如下 ：   \n\n\n\n\t- (\tvoid)encodeWithCoder:(NSCoder *\t)aCoder {\n\t    [aCoder encodeObject:self.firstName forKey:PERSON_KEY_FIRSTNAME];\n\t    [aCoder encodeObject:self.lastName forKey:PERSON_KEY_LASTNAME];\n\t    [aCoder encodeFloat:self.height forKey:PERSON_KEY_HEIGHT];\n\t}\n\t- (\n\tid\n\t)initWithCoder:(NSCoder *\n\t)aDecoder {\n\t    self \n\t=\n\t [super init];\t    \n\tif\n\t (self !=\n\t nil) {\n\t        self.firstName \n\t=\n\t [aDecoder decodeObjectForKey:PERSON_KEY_FIRSTNAME];\n\t        self.lastName \n\t=\n\t [aDecoder decodeObjectForKey:PERSON_KEY_LASTNAME];\n\t        self.height \n\t=\n\t [aDecoder decodeFloatForKey:PERSON_KEY_HEIGHT];\n\t    }\t    \n\treturn\n\t self;\n\t}\n   \n\n## 十二、离屏渲染  \n\n\n\n设置了以下属性时，都会触发离屏绘制：    \n\n+ shouldRasterize（光栅化）  \n+ masks（遮罩）    \n+ shadows（阴影）   \n+ edge antialiasing（抗锯齿）  \n\n\n+ group opacity（不透明）   \n\n\n+ 还有一种特殊的离屏渲染，`cpu`渲染，当我们使用drawRect时会触发\n\n\n\n\n\n\n\n","source":"_posts/iOS-Dev.md","raw":"---\ntitle: iOS Dev\ndate: 2017-03-18 11:08:00\ntags: [iOS, Dev]\ncategories: iOS\n---\n\n> iOS 学习笔记\n\n<!--More-->\n## 一、iOS基础知识\n### 1、语法\n\n1、类方法里是不可以调用普通方法的。\n\n2、`extension`与`catogry`的区别就是括号中有没有名字。另外`catogry`只可以增加方法不能增加属性，`extension`是可以增加属性的   \n\n3、`self`的赋值一定要在`initxxx`系列函数里调用，不能在别的函数里调用，`initialxxx`都不行\n\n\n### 2、关于在一个工程中添加自定义framework\n\n1、添加方式：File->New->Target->Cocoa Touch Framework\n2、真机测试时可会出现dyld:Library no loaded:....   \n**解决方法**：在app对应的Target->General->Embedded Binaries 添加自定义framwork\n\n### 3、Framework 命令行编译\n\n利用xcode tools[参考](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html),命令如下：\n\n> xcodebuild clean build -project /Users/yuanchengsu/Desktop/iMSDK/iMSDK/iOS/IMSDK/IMSDK.xcodeproj \n-target IMSDKCoreKit -configuration Release  -xcconfig /Users/yuanchengsu/Desktop/iMSDK/iMSDK/iOS/IMSDK/Demo/Configurations/IMSDKGNU++98.xcconfig -sdk iphoneos9.1\n\n\n### 4.[KVO]( https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html)     \n### 5.[ios https](http://io.diveinedu.com/2016/01/09/iOS%E5%BA%94%E7%94%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8BHTTPS.html)\n### 6.runloop     \nrunloop只有在开启第二个线程的时候才考虑使用runloop，而且也并非所有的线程需要runloop\n+ 使用runloop的情况    \n  + use ports or custom input sources to communicate with other threads\n  + use timers on the thread\n  + use any of the `performSelector...`\n  + keep the thread around of perform periodic tasks     \n  \n+ performselector在后台执行时，必须开启一个runloop，否则调用不了     \n+ runLoop有两套API，NSRunloop,CFRunLoopRef     \n+ runLoop在获取时，就是创建\n+ 一个runloop有两个CFRunloopSource,source0:处理UIEvent，CFSocket,source1:mach port,CFMachPort,CFMessagePort;一种mode:default,tracking,common     \n\n### 7.copy与retain    \n+ copy是指拷贝内容    \n+ retain是指拷贝指针     \n+ copy需要对象遵守NSCopying协议的    \n+     \n\n### 8.关于xcode查看汇编的方法   \n+ xcode 7.x: Debug ==> Debug Workflow ==> Show Disassembly when Debugging     \n+ xocde 7.x之前： Product ==> Debug Workflow ==> Show Disassembly when Debugging    \n\n### 9.oc严格单例\n\n创建对象的步骤分为申请内存(alloc)、初始化(init)这两个步骤，我们要确保对象的唯一性，因此在第一步这个阶段我们就要拦截它。当我们调用alloc方法时，oc内部会调用allocWithZone这个方法来申请内存，我们覆写这个方法，然后在这个方法中调用shareInstance方法返回单例对象，这样就可以达到我们的目的。拷贝对象也是同样的原理，覆写copyWithZone方法，然后在这个方法中调用shareInstance方法返回单例对象。看代码吧：\n\n```\n\n\t+(instancetype) sharedInstance\n\t{\n\t    static IMSDKLocalLog *_instance = nil;\n\t    static dispatch_once_t onceToken ;\n\t    dispatch_once(&onceToken, ^{\n\t        _instance = [[super allocWithZone:NULL] initSingleton];// 继承可能有问题\n\t    }) ;\n\t    \n\t    return _instance ;\n\t}\n\t\n\t+(id) allocWithZone:(struct _NSZone *)zone\n\t{\n\t    return [IMSDKLocalLog sharedInstance];\n\t}\n\t\n\t- (id) copyWithZone:(NSZone *)zone\n\t{\n\t    return [IMSDKLocalLog sharedInstance];\n\t}\n\t\n\t- (id) mutablecopyWithZone:(NSZone *)zone\n\t{\n\t    return [IMSDKLocalLog sharedInstance];\n\t}\n\t\n\t\n\t- (instancetype)initSingleton {\n\t    self = [super init];\n\t    if (self) {        //TODO\n\t        _logfile = @\"\";\n\t        _maxLogSize = 20*1024*1024;\n\t        _maxFileSize = 512*1024;\n\t        _retry = 3;\n\t    }\n\t    return self;\n\t} \n```    \n### 10、xcode 切换/build\n1. xcodebuild -verison   (查看你的xcode版本)   \n2. sudo xcode-select -switch xcode path , 例如：</Applications/Xcode8.0.app/Contents/Developer  > (如果需要切换)    \n3. xcodebuild -target {你的工程名字}    \n\n### 11、关于`[NSString UTF8String]`返回null的问题\n+ 首先，在使用UTF8String时要做好保护，因为其返回是可能为空的只是概率不高；\n+ 返回null的一种可能情况：    \n\n```\n\nNSString *ns = @\"sdfhsdjf % C dsfsd\";\nconst char *s = [ns UTF8String];   \n```\n\n**原因：在字符串中出现了`% C`占位符。占位符的意义是会将指定内存格式化，但是这里没有指定内存，另外`%C`会将指定内存转为UTF-16，这样ns字符串中概率性的会出现非UTF8字符，所以转UTF8String时是会出现null的**\n## 二、关于certificates 和provisioning proflies\n\n1、certificates：key(private key)\n\n2、provisioning profiles:(public key)\n\n + appid(bundle identifier) \n\n\n + devices(uuid)\n\n\n + certificates(private key)  \n\n3、.p12是证书导出保存的形式     \n4、wwdr证书失效会导致自己证书无效\n\n\n## 三、关于Clang 与LLVM  \n\n\nClang 是一个 C++ 编写、基于 LLVM、发布于 LLVM BSD 许可证下的/C++/Objective C/Objective C++ 编译器。LLVM 是 Low Level Virtual Machine。具体介绍参考[clang and llvm]( http://objccn.io/issue-6-2/)\n\n+ 命令clang -E 是用于宏定义展开  \n\n   \n\n## 四、反馈系统UI设计问题：\n\n\n\n\n\n1、toolbar的设计问题，当用storyboard进行布局的时候要做到适配效果子在UIbarbuttonItem之间加入flexispace才能做到适配。\n\n2、关于storyboard initialViewcontrollerwithIdentiy的问题，当view还没出现的时生成的对象的成员都会是空的，只有到显示的时候才会出现。解决要对其进行参数传递的时候要采用property方法或者利用dispatch_after方式来做\n\n3、关于ipad版本浮动窗口形式的问题。当在ipad版本下设置Modalpresentationstyle就可以达到这种效果\n4、关于storyboard的问题。一个app中可以有多个storyboard，通过instantiateviewcontrollerwithidentiter方式 来进行实例化。要注意的是storyboard要放到 mainbundle目录下\n5、消除返回按钮上的文字，利用self.naviagtionitem.backbuttonitem = [[uibarbuttom alloc ]initwithtitle:@\"\"] style:\n\ntarget:action];[参见]( http://www.cnblogs.com/ygm900/p/3659619.html )  \n\n## 五、关于isKindOfClass与isMemberOfClass的区别：\n\n1、isKindOfClass，是判断一个对象是属于哪个类~~ 型，一直追溯到父类~~ 。或者子类的实例\n\n2、isMemberClass，是判断一个对象属于哪个类~~ 型，不追溯到父类!~~ 。   \n## 六、Core Data编程\n1、core data 与sql的一些对应关系：\n\n| 功能 | sql |core data| \n| -- | -- |--|  \n|表头|表结构,实体，entity|NSEntityDescription|   \n|表中的一行数据|记录|NSManagedObject| \n|查询|查询,select ...|NSFetchRequest|   \n|持久化|表存储,。。。|NSPersistentStoreCoordinator|   \n|数据库的设计，也就是.xcodemodel文件|数据库模型,。。。|NSManagedObjectModel|   \n|操作上下文|数据库操作|NSManagedObjectContext|  \n[更详细的底层操作](http://objccn.io/issue-4-1/)       \n2、`NSManagedObjectContext`\n`NSManagedObjectContext`是程序员主要接触的一个类，也就是所有的操作基本上都通过它来操作的，底层是怎么实现的我们不需要去关心  \n3、`NSPersistentStoreCoordinator`\n`NSPersistentStoreCoordinator`才是最终的操作实现都是才是核心,[参考](http://objccn.io/issue-4-1)   \n4、[编程参考](http://iiiyu.com/2013/03/29/learning-ios-notes-eighteen/)\n## 七、关于异步加载问题\n1、`nsdata datawithcontentsofurl`是一个同步加载方法，因此要使用此方法要采用异步加载方法。可以适用于加载图片等；\n2、注意`AFNertworking success/failure block` invoked in main thread。如果 没有进行队列设置默认会返回到主线程去。 \n \n\n\n\tif(sucess)\n\t{\n\tdispatch_group_async(self.completionGroup?:http_request_operation_completion_group(),self.completionQueue?:dispatch_get_main_queue(),^{});\n\t}   \n     \n\n\n## 八、关于 strong,weak引用修饰符  \n\n1、strong相当于手动引用计数（manual reference count）中的retain，拥有对象直到对象释放。\n2、weak与strong刚好相反，weak并不持有对象，而且当对象释放时weak我修饰的对象会自动赋值为nil。例如：   \n\n\n\n\tid _weak obj = [[NSObject alloc]init];//错误，weak不能持有对象\t\n\tid _weak oo = nil;\n\t{\n\t   id strong object = [[NSObject alloc]init];\n\t   oo= object\n\t   NSLog(@\"%@\",oo)//此处对象是存在的\n\t}\n     \n\n\n## 九、[关于draweRect消耗内存](http://bihongbo.com/2016/01/03/memoryGhostdrawRect/)  \n要想搞明白这个问题，我们需要撸一撸在`iOS`程序上图形显示的原理。在`iOS`系统中所有显示的视图都是从基类`UIView`继承而来的，同时`UIView`负责接收用户交互。**但是实际上你所看到的视图内容，包括图形等，都是由`UIView`的一个实例图层属性来绘制和渲染的，那就是`CALayer`。**\n**最终我们的图形渲染落点落在`contents`身上**![如图](http://7xkdhe.com1.z0.glb.clouddn.com/drawRect3.001.png)。\n`contents`也被称为寄宿图，除了给它赋值`CGImage`之外，我们也可以直接对它进行绘制，绘制的方法正是这次问题的关键，通过继承`UIView`并实现`-drawRect:`方法即可自定义绘制。`-drawRect:` 方法没有默认的实现，因为对`UIView`来说，寄宿图并不是必须的，`UIView`不关心绘制的内容。如果`UIView`检测到`-drawRect:`方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以`contentsScale`(这个属性与屏幕分辨率有关，我们的画板程序在不同模拟器下呈现的内存用量不同也是因为它)的值。这也就是`-drawRect:`消耗内存的原因。\n\n**解决方案：**使用CAShapeLayer,另外与屏幕大小的画板可以算出消耗内存几M左右，可以接受   \n## 十、[关于设置圆角问题](http://www.cocoachina.com/ios/20160301/15486.html)  \n\n\n由于设置圆角发生离屏渲染，所以对    \n\n## 十一、[数据持久化]( http://casatwy.com/iosying-yong-jia-gou-tan-ben-di-chi-jiu-hua-fang-an-ji-dong-tai-bu-shu.html)\n\n1.使用 archive的对象需要实现<NSCoding>里的方法，关于NSCoder怎么使用参考如下 ：   \n\n\n\n\t- (\tvoid)encodeWithCoder:(NSCoder *\t)aCoder {\n\t    [aCoder encodeObject:self.firstName forKey:PERSON_KEY_FIRSTNAME];\n\t    [aCoder encodeObject:self.lastName forKey:PERSON_KEY_LASTNAME];\n\t    [aCoder encodeFloat:self.height forKey:PERSON_KEY_HEIGHT];\n\t}\n\t- (\n\tid\n\t)initWithCoder:(NSCoder *\n\t)aDecoder {\n\t    self \n\t=\n\t [super init];\t    \n\tif\n\t (self !=\n\t nil) {\n\t        self.firstName \n\t=\n\t [aDecoder decodeObjectForKey:PERSON_KEY_FIRSTNAME];\n\t        self.lastName \n\t=\n\t [aDecoder decodeObjectForKey:PERSON_KEY_LASTNAME];\n\t        self.height \n\t=\n\t [aDecoder decodeFloatForKey:PERSON_KEY_HEIGHT];\n\t    }\t    \n\treturn\n\t self;\n\t}\n   \n\n## 十二、离屏渲染  \n\n\n\n设置了以下属性时，都会触发离屏绘制：    \n\n+ shouldRasterize（光栅化）  \n+ masks（遮罩）    \n+ shadows（阴影）   \n+ edge antialiasing（抗锯齿）  \n\n\n+ group opacity（不透明）   \n\n\n+ 还有一种特殊的离屏渲染，`cpu`渲染，当我们使用drawRect时会触发\n\n\n\n\n\n\n\n","slug":"iOS-Dev","published":1,"updated":"2022-06-15T07:23:15.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4fa2sa1000kdacoj44a5ar6","content":"<blockquote>\n<p>iOS 学习笔记</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"一、iOS基础知识\"><a href=\"#一、iOS基础知识\" class=\"headerlink\" title=\"一、iOS基础知识\"></a>一、iOS基础知识</h2><h3 id=\"1、语法\"><a href=\"#1、语法\" class=\"headerlink\" title=\"1、语法\"></a>1、语法</h3><p>1、类方法里是不可以调用普通方法的。</p>\n<p>2、<code>extension</code>与<code>catogry</code>的区别就是括号中有没有名字。另外<code>catogry</code>只可以增加方法不能增加属性，<code>extension</code>是可以增加属性的   </p>\n<p>3、<code>self</code>的赋值一定要在<code>initxxx</code>系列函数里调用，不能在别的函数里调用，<code>initialxxx</code>都不行</p>\n<h3 id=\"2、关于在一个工程中添加自定义framework\"><a href=\"#2、关于在一个工程中添加自定义framework\" class=\"headerlink\" title=\"2、关于在一个工程中添加自定义framework\"></a>2、关于在一个工程中添加自定义framework</h3><p>1、添加方式：File-&gt;New-&gt;Target-&gt;Cocoa Touch Framework<br>2、真机测试时可会出现dyld:Library no loaded:….<br><strong>解决方法</strong>：在app对应的Target-&gt;General-&gt;Embedded Binaries 添加自定义framwork</p>\n<h3 id=\"3、Framework-命令行编译\"><a href=\"#3、Framework-命令行编译\" class=\"headerlink\" title=\"3、Framework 命令行编译\"></a>3、Framework 命令行编译</h3><p>利用xcode tools<a href=\"https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html\" target=\"_blank\" rel=\"noopener\">参考</a>,命令如下：</p>\n<blockquote>\n<p>xcodebuild clean build -project /Users/yuanchengsu/Desktop/iMSDK/iMSDK/iOS/IMSDK/IMSDK.xcodeproj<br>-target IMSDKCoreKit -configuration Release  -xcconfig /Users/yuanchengsu/Desktop/iMSDK/iMSDK/iOS/IMSDK/Demo/Configurations/IMSDKGNU++98.xcconfig -sdk iphoneos9.1</p>\n</blockquote>\n<h3 id=\"4-KVO\"><a href=\"#4-KVO\" class=\"headerlink\" title=\"4.KVO\"></a>4.<a href=\"https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html\" target=\"_blank\" rel=\"noopener\">KVO</a></h3><h3 id=\"5-ios-https\"><a href=\"#5-ios-https\" class=\"headerlink\" title=\"5.ios https\"></a>5.<a href=\"http://io.diveinedu.com/2016/01/09/iOS%E5%BA%94%E7%94%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8BHTTPS.html\" target=\"_blank\" rel=\"noopener\">ios https</a></h3><h3 id=\"6-runloop\"><a href=\"#6-runloop\" class=\"headerlink\" title=\"6.runloop\"></a>6.runloop</h3><p>runloop只有在开启第二个线程的时候才考虑使用runloop，而且也并非所有的线程需要runloop</p>\n<ul>\n<li><p>使用runloop的情况    </p>\n<ul>\n<li>use ports or custom input sources to communicate with other threads</li>\n<li>use timers on the thread</li>\n<li>use any of the <code>performSelector...</code></li>\n<li>keep the thread around of perform periodic tasks     </li>\n</ul>\n</li>\n<li><p>performselector在后台执行时，必须开启一个runloop，否则调用不了     </p>\n</li>\n<li>runLoop有两套API，NSRunloop,CFRunLoopRef     </li>\n<li>runLoop在获取时，就是创建</li>\n<li>一个runloop有两个CFRunloopSource,source0:处理UIEvent，CFSocket,source1:mach port,CFMachPort,CFMessagePort;一种mode:default,tracking,common     </li>\n</ul>\n<h3 id=\"7-copy与retain\"><a href=\"#7-copy与retain\" class=\"headerlink\" title=\"7.copy与retain\"></a>7.copy与retain</h3><ul>\n<li>copy是指拷贝内容    </li>\n<li>retain是指拷贝指针     </li>\n<li>copy需要对象遵守NSCopying协议的    </li>\n<li></li>\n</ul>\n<h3 id=\"8-关于xcode查看汇编的方法\"><a href=\"#8-关于xcode查看汇编的方法\" class=\"headerlink\" title=\"8.关于xcode查看汇编的方法\"></a>8.关于xcode查看汇编的方法</h3><ul>\n<li>xcode 7.x: Debug ==&gt; Debug Workflow ==&gt; Show Disassembly when Debugging     </li>\n<li>xocde 7.x之前： Product ==&gt; Debug Workflow ==&gt; Show Disassembly when Debugging    </li>\n</ul>\n<h3 id=\"9-oc严格单例\"><a href=\"#9-oc严格单例\" class=\"headerlink\" title=\"9.oc严格单例\"></a>9.oc严格单例</h3><p>创建对象的步骤分为申请内存(alloc)、初始化(init)这两个步骤，我们要确保对象的唯一性，因此在第一步这个阶段我们就要拦截它。当我们调用alloc方法时，oc内部会调用allocWithZone这个方法来申请内存，我们覆写这个方法，然后在这个方法中调用shareInstance方法返回单例对象，这样就可以达到我们的目的。拷贝对象也是同样的原理，覆写copyWithZone方法，然后在这个方法中调用shareInstance方法返回单例对象。看代码吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t+(instancetype) sharedInstance</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    static IMSDKLocalLog *_instance = nil;</span><br><span class=\"line\">\t    static dispatch_once_t onceToken ;</span><br><span class=\"line\">\t    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">\t        _instance = [[super allocWithZone:NULL] initSingleton];// 继承可能有问题</span><br><span class=\"line\">\t    &#125;) ;</span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t    return _instance ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t+(id) allocWithZone:(struct _NSZone *)zone</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    return [IMSDKLocalLog sharedInstance];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t- (id) copyWithZone:(NSZone *)zone</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    return [IMSDKLocalLog sharedInstance];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t- (id) mutablecopyWithZone:(NSZone *)zone</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    return [IMSDKLocalLog sharedInstance];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t- (instancetype)initSingleton &#123;</span><br><span class=\"line\">\t    self = [super init];</span><br><span class=\"line\">\t    if (self) &#123;        //TODO</span><br><span class=\"line\">\t        _logfile = @&quot;&quot;;</span><br><span class=\"line\">\t        _maxLogSize = 20*1024*1024;</span><br><span class=\"line\">\t        _maxFileSize = 512*1024;</span><br><span class=\"line\">\t        _retry = 3;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    return self;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">```    </span><br><span class=\"line\">### 10、xcode 切换/build</span><br><span class=\"line\">1. xcodebuild -verison   (查看你的xcode版本)   </span><br><span class=\"line\">2. sudo xcode-select -switch xcode path , 例如：&lt;/Applications/Xcode8.0.app/Contents/Developer  &gt; (如果需要切换)    </span><br><span class=\"line\">3. xcodebuild -target &#123;你的工程名字&#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">### 11、关于`[NSString UTF8String]`返回null的问题</span><br><span class=\"line\">+ 首先，在使用UTF8String时要做好保护，因为其返回是可能为空的只是概率不高；</span><br><span class=\"line\">+ 返回null的一种可能情况：</span><br></pre></td></tr></table></figure>\n<p>NSString <em>ns = @”sdfhsdjf % C dsfsd”;<br>const char </em>s = [ns UTF8String];<br>```</p>\n<p><strong>原因：在字符串中出现了<code>% C</code>占位符。占位符的意义是会将指定内存格式化，但是这里没有指定内存，另外<code>%C</code>会将指定内存转为UTF-16，这样ns字符串中概率性的会出现非UTF8字符，所以转UTF8String时是会出现null的</strong></p>\n<h2 id=\"二、关于certificates-和provisioning-proflies\"><a href=\"#二、关于certificates-和provisioning-proflies\" class=\"headerlink\" title=\"二、关于certificates 和provisioning proflies\"></a>二、关于certificates 和provisioning proflies</h2><p>1、certificates：key(private key)</p>\n<p>2、provisioning profiles:(public key)</p>\n<ul>\n<li>appid(bundle identifier) </li>\n</ul>\n<ul>\n<li>devices(uuid)</li>\n</ul>\n<ul>\n<li>certificates(private key)  </li>\n</ul>\n<p>3、.p12是证书导出保存的形式<br>4、wwdr证书失效会导致自己证书无效</p>\n<h2 id=\"三、关于Clang-与LLVM\"><a href=\"#三、关于Clang-与LLVM\" class=\"headerlink\" title=\"三、关于Clang 与LLVM\"></a>三、关于Clang 与LLVM</h2><p>Clang 是一个 C++ 编写、基于 LLVM、发布于 LLVM BSD 许可证下的/C++/Objective C/Objective C++ 编译器。LLVM 是 Low Level Virtual Machine。具体介绍参考<a href=\"http://objccn.io/issue-6-2/\" target=\"_blank\" rel=\"noopener\">clang and llvm</a></p>\n<ul>\n<li>命令clang -E 是用于宏定义展开  </li>\n</ul>\n<h2 id=\"四、反馈系统UI设计问题：\"><a href=\"#四、反馈系统UI设计问题：\" class=\"headerlink\" title=\"四、反馈系统UI设计问题：\"></a>四、反馈系统UI设计问题：</h2><p>1、toolbar的设计问题，当用storyboard进行布局的时候要做到适配效果子在UIbarbuttonItem之间加入flexispace才能做到适配。</p>\n<p>2、关于storyboard initialViewcontrollerwithIdentiy的问题，当view还没出现的时生成的对象的成员都会是空的，只有到显示的时候才会出现。解决要对其进行参数传递的时候要采用property方法或者利用dispatch_after方式来做</p>\n<p>3、关于ipad版本浮动窗口形式的问题。当在ipad版本下设置Modalpresentationstyle就可以达到这种效果<br>4、关于storyboard的问题。一个app中可以有多个storyboard，通过instantiateviewcontrollerwithidentiter方式 来进行实例化。要注意的是storyboard要放到 mainbundle目录下<br>5、消除返回按钮上的文字，利用self.naviagtionitem.backbuttonitem = [[uibarbuttom alloc ]initwithtitle:@””] style:</p>\n<p>target:action];<a href=\"http://www.cnblogs.com/ygm900/p/3659619.html\" target=\"_blank\" rel=\"noopener\">参见</a>  </p>\n<h2 id=\"五、关于isKindOfClass与isMemberOfClass的区别：\"><a href=\"#五、关于isKindOfClass与isMemberOfClass的区别：\" class=\"headerlink\" title=\"五、关于isKindOfClass与isMemberOfClass的区别：\"></a>五、关于isKindOfClass与isMemberOfClass的区别：</h2><p>1、isKindOfClass，是判断一个对象是属于哪个类~~ 型，一直追溯到父类~~ 。或者子类的实例</p>\n<p>2、isMemberClass，是判断一个对象属于哪个类~~ 型，不追溯到父类!~~ 。   </p>\n<h2 id=\"六、Core-Data编程\"><a href=\"#六、Core-Data编程\" class=\"headerlink\" title=\"六、Core Data编程\"></a>六、Core Data编程</h2><p>1、core data 与sql的一些对应关系：</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>sql</th>\n<th>core data</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>表头</td>\n<td>表结构,实体，entity</td>\n<td>NSEntityDescription</td>\n</tr>\n<tr>\n<td>表中的一行数据</td>\n<td>记录</td>\n<td>NSManagedObject</td>\n</tr>\n<tr>\n<td>查询</td>\n<td>查询,select …</td>\n<td>NSFetchRequest</td>\n</tr>\n<tr>\n<td>持久化</td>\n<td>表存储,。。。</td>\n<td>NSPersistentStoreCoordinator</td>\n</tr>\n<tr>\n<td>数据库的设计，也就是.xcodemodel文件</td>\n<td>数据库模型,。。。</td>\n<td>NSManagedObjectModel</td>\n</tr>\n<tr>\n<td>操作上下文</td>\n<td>数据库操作</td>\n<td>NSManagedObjectContext</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"http://objccn.io/issue-4-1/\" target=\"_blank\" rel=\"noopener\">更详细的底层操作</a><br>2、<code>NSManagedObjectContext</code><br><code>NSManagedObjectContext</code>是程序员主要接触的一个类，也就是所有的操作基本上都通过它来操作的，底层是怎么实现的我们不需要去关心<br>3、<code>NSPersistentStoreCoordinator</code><br><code>NSPersistentStoreCoordinator</code>才是最终的操作实现都是才是核心,<a href=\"http://objccn.io/issue-4-1\" target=\"_blank\" rel=\"noopener\">参考</a><br>4、<a href=\"http://iiiyu.com/2013/03/29/learning-ios-notes-eighteen/\" target=\"_blank\" rel=\"noopener\">编程参考</a></p>\n<h2 id=\"七、关于异步加载问题\"><a href=\"#七、关于异步加载问题\" class=\"headerlink\" title=\"七、关于异步加载问题\"></a>七、关于异步加载问题</h2><p>1、<code>nsdata datawithcontentsofurl</code>是一个同步加载方法，因此要使用此方法要采用异步加载方法。可以适用于加载图片等；<br>2、注意<code>AFNertworking success/failure block</code> invoked in main thread。如果 没有进行队列设置默认会返回到主线程去。 </p>\n<pre><code>if(sucess)\n{\ndispatch_group_async(self.completionGroup?:http_request_operation_completion_group(),self.completionQueue?:dispatch_get_main_queue(),^{});\n}   \n</code></pre><h2 id=\"八、关于-strong-weak引用修饰符\"><a href=\"#八、关于-strong-weak引用修饰符\" class=\"headerlink\" title=\"八、关于 strong,weak引用修饰符\"></a>八、关于 strong,weak引用修饰符</h2><p>1、strong相当于手动引用计数（manual reference count）中的retain，拥有对象直到对象释放。<br>2、weak与strong刚好相反，weak并不持有对象，而且当对象释放时weak我修饰的对象会自动赋值为nil。例如：   </p>\n<pre><code>id _weak obj = [[NSObject alloc]init];//错误，weak不能持有对象    \nid _weak oo = nil;\n{\n   id strong object = [[NSObject alloc]init];\n   oo= object\n   NSLog(@&quot;%@&quot;,oo)//此处对象是存在的\n}\n</code></pre><h2 id=\"九、关于draweRect消耗内存\"><a href=\"#九、关于draweRect消耗内存\" class=\"headerlink\" title=\"九、关于draweRect消耗内存\"></a>九、<a href=\"http://bihongbo.com/2016/01/03/memoryGhostdrawRect/\" target=\"_blank\" rel=\"noopener\">关于draweRect消耗内存</a></h2><p>要想搞明白这个问题，我们需要撸一撸在<code>iOS</code>程序上图形显示的原理。在<code>iOS</code>系统中所有显示的视图都是从基类<code>UIView</code>继承而来的，同时<code>UIView</code>负责接收用户交互。<strong>但是实际上你所看到的视图内容，包括图形等，都是由<code>UIView</code>的一个实例图层属性来绘制和渲染的，那就是<code>CALayer</code>。</strong><br><strong>最终我们的图形渲染落点落在<code>contents</code>身上</strong><img src=\"http://7xkdhe.com1.z0.glb.clouddn.com/drawRect3.001.png\" alt=\"如图\">。<br><code>contents</code>也被称为寄宿图，除了给它赋值<code>CGImage</code>之外，我们也可以直接对它进行绘制，绘制的方法正是这次问题的关键，通过继承<code>UIView</code>并实现<code>-drawRect:</code>方法即可自定义绘制。<code>-drawRect:</code> 方法没有默认的实现，因为对<code>UIView</code>来说，寄宿图并不是必须的，<code>UIView</code>不关心绘制的内容。如果<code>UIView</code>检测到<code>-drawRect:</code>方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以<code>contentsScale</code>(这个属性与屏幕分辨率有关，我们的画板程序在不同模拟器下呈现的内存用量不同也是因为它)的值。这也就是<code>-drawRect:</code>消耗内存的原因。</p>\n<p><strong>解决方案：</strong>使用CAShapeLayer,另外与屏幕大小的画板可以算出消耗内存几M左右，可以接受   </p>\n<h2 id=\"十、关于设置圆角问题\"><a href=\"#十、关于设置圆角问题\" class=\"headerlink\" title=\"十、关于设置圆角问题\"></a>十、<a href=\"http://www.cocoachina.com/ios/20160301/15486.html\" target=\"_blank\" rel=\"noopener\">关于设置圆角问题</a></h2><p>由于设置圆角发生离屏渲染，所以对    </p>\n<h2 id=\"十一、数据持久化\"><a href=\"#十一、数据持久化\" class=\"headerlink\" title=\"十一、数据持久化\"></a>十一、<a href=\"http://casatwy.com/iosying-yong-jia-gou-tan-ben-di-chi-jiu-hua-fang-an-ji-dong-tai-bu-shu.html\" target=\"_blank\" rel=\"noopener\">数据持久化</a></h2><p>1.使用 archive的对象需要实现<nscoding>里的方法，关于NSCoder怎么使用参考如下 ：   </nscoding></p>\n<pre><code>- (    void)encodeWithCoder:(NSCoder *    )aCoder {\n    [aCoder encodeObject:self.firstName forKey:PERSON_KEY_FIRSTNAME];\n    [aCoder encodeObject:self.lastName forKey:PERSON_KEY_LASTNAME];\n    [aCoder encodeFloat:self.height forKey:PERSON_KEY_HEIGHT];\n}\n- (\nid\n)initWithCoder:(NSCoder *\n)aDecoder {\n    self \n=\n [super init];        \nif\n (self !=\n nil) {\n        self.firstName \n=\n [aDecoder decodeObjectForKey:PERSON_KEY_FIRSTNAME];\n        self.lastName \n=\n [aDecoder decodeObjectForKey:PERSON_KEY_LASTNAME];\n        self.height \n=\n [aDecoder decodeFloatForKey:PERSON_KEY_HEIGHT];\n    }        \nreturn\n self;\n}\n</code></pre><h2 id=\"十二、离屏渲染\"><a href=\"#十二、离屏渲染\" class=\"headerlink\" title=\"十二、离屏渲染\"></a>十二、离屏渲染</h2><p>设置了以下属性时，都会触发离屏绘制：    </p>\n<ul>\n<li>shouldRasterize（光栅化）  </li>\n<li>masks（遮罩）    </li>\n<li>shadows（阴影）   </li>\n<li>edge antialiasing（抗锯齿）  </li>\n</ul>\n<ul>\n<li>group opacity（不透明）   </li>\n</ul>\n<ul>\n<li>还有一种特殊的离屏渲染，<code>cpu</code>渲染，当我们使用drawRect时会触发</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>iOS 学习笔记</p>\n</blockquote>","more":"<h2 id=\"一、iOS基础知识\"><a href=\"#一、iOS基础知识\" class=\"headerlink\" title=\"一、iOS基础知识\"></a>一、iOS基础知识</h2><h3 id=\"1、语法\"><a href=\"#1、语法\" class=\"headerlink\" title=\"1、语法\"></a>1、语法</h3><p>1、类方法里是不可以调用普通方法的。</p>\n<p>2、<code>extension</code>与<code>catogry</code>的区别就是括号中有没有名字。另外<code>catogry</code>只可以增加方法不能增加属性，<code>extension</code>是可以增加属性的   </p>\n<p>3、<code>self</code>的赋值一定要在<code>initxxx</code>系列函数里调用，不能在别的函数里调用，<code>initialxxx</code>都不行</p>\n<h3 id=\"2、关于在一个工程中添加自定义framework\"><a href=\"#2、关于在一个工程中添加自定义framework\" class=\"headerlink\" title=\"2、关于在一个工程中添加自定义framework\"></a>2、关于在一个工程中添加自定义framework</h3><p>1、添加方式：File-&gt;New-&gt;Target-&gt;Cocoa Touch Framework<br>2、真机测试时可会出现dyld:Library no loaded:….<br><strong>解决方法</strong>：在app对应的Target-&gt;General-&gt;Embedded Binaries 添加自定义framwork</p>\n<h3 id=\"3、Framework-命令行编译\"><a href=\"#3、Framework-命令行编译\" class=\"headerlink\" title=\"3、Framework 命令行编译\"></a>3、Framework 命令行编译</h3><p>利用xcode tools<a href=\"https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html\" target=\"_blank\" rel=\"noopener\">参考</a>,命令如下：</p>\n<blockquote>\n<p>xcodebuild clean build -project /Users/yuanchengsu/Desktop/iMSDK/iMSDK/iOS/IMSDK/IMSDK.xcodeproj<br>-target IMSDKCoreKit -configuration Release  -xcconfig /Users/yuanchengsu/Desktop/iMSDK/iMSDK/iOS/IMSDK/Demo/Configurations/IMSDKGNU++98.xcconfig -sdk iphoneos9.1</p>\n</blockquote>\n<h3 id=\"4-KVO\"><a href=\"#4-KVO\" class=\"headerlink\" title=\"4.KVO\"></a>4.<a href=\"https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html\" target=\"_blank\" rel=\"noopener\">KVO</a></h3><h3 id=\"5-ios-https\"><a href=\"#5-ios-https\" class=\"headerlink\" title=\"5.ios https\"></a>5.<a href=\"http://io.diveinedu.com/2016/01/09/iOS%E5%BA%94%E7%94%A8%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8BHTTPS.html\" target=\"_blank\" rel=\"noopener\">ios https</a></h3><h3 id=\"6-runloop\"><a href=\"#6-runloop\" class=\"headerlink\" title=\"6.runloop\"></a>6.runloop</h3><p>runloop只有在开启第二个线程的时候才考虑使用runloop，而且也并非所有的线程需要runloop</p>\n<ul>\n<li><p>使用runloop的情况    </p>\n<ul>\n<li>use ports or custom input sources to communicate with other threads</li>\n<li>use timers on the thread</li>\n<li>use any of the <code>performSelector...</code></li>\n<li>keep the thread around of perform periodic tasks     </li>\n</ul>\n</li>\n<li><p>performselector在后台执行时，必须开启一个runloop，否则调用不了     </p>\n</li>\n<li>runLoop有两套API，NSRunloop,CFRunLoopRef     </li>\n<li>runLoop在获取时，就是创建</li>\n<li>一个runloop有两个CFRunloopSource,source0:处理UIEvent，CFSocket,source1:mach port,CFMachPort,CFMessagePort;一种mode:default,tracking,common     </li>\n</ul>\n<h3 id=\"7-copy与retain\"><a href=\"#7-copy与retain\" class=\"headerlink\" title=\"7.copy与retain\"></a>7.copy与retain</h3><ul>\n<li>copy是指拷贝内容    </li>\n<li>retain是指拷贝指针     </li>\n<li>copy需要对象遵守NSCopying协议的    </li>\n<li></li>\n</ul>\n<h3 id=\"8-关于xcode查看汇编的方法\"><a href=\"#8-关于xcode查看汇编的方法\" class=\"headerlink\" title=\"8.关于xcode查看汇编的方法\"></a>8.关于xcode查看汇编的方法</h3><ul>\n<li>xcode 7.x: Debug ==&gt; Debug Workflow ==&gt; Show Disassembly when Debugging     </li>\n<li>xocde 7.x之前： Product ==&gt; Debug Workflow ==&gt; Show Disassembly when Debugging    </li>\n</ul>\n<h3 id=\"9-oc严格单例\"><a href=\"#9-oc严格单例\" class=\"headerlink\" title=\"9.oc严格单例\"></a>9.oc严格单例</h3><p>创建对象的步骤分为申请内存(alloc)、初始化(init)这两个步骤，我们要确保对象的唯一性，因此在第一步这个阶段我们就要拦截它。当我们调用alloc方法时，oc内部会调用allocWithZone这个方法来申请内存，我们覆写这个方法，然后在这个方法中调用shareInstance方法返回单例对象，这样就可以达到我们的目的。拷贝对象也是同样的原理，覆写copyWithZone方法，然后在这个方法中调用shareInstance方法返回单例对象。看代码吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t+(instancetype) sharedInstance</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    static IMSDKLocalLog *_instance = nil;</span><br><span class=\"line\">\t    static dispatch_once_t onceToken ;</span><br><span class=\"line\">\t    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">\t        _instance = [[super allocWithZone:NULL] initSingleton];// 继承可能有问题</span><br><span class=\"line\">\t    &#125;) ;</span><br><span class=\"line\">\t    </span><br><span class=\"line\">\t    return _instance ;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t+(id) allocWithZone:(struct _NSZone *)zone</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    return [IMSDKLocalLog sharedInstance];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t- (id) copyWithZone:(NSZone *)zone</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    return [IMSDKLocalLog sharedInstance];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t- (id) mutablecopyWithZone:(NSZone *)zone</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    return [IMSDKLocalLog sharedInstance];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t- (instancetype)initSingleton &#123;</span><br><span class=\"line\">\t    self = [super init];</span><br><span class=\"line\">\t    if (self) &#123;        //TODO</span><br><span class=\"line\">\t        _logfile = @&quot;&quot;;</span><br><span class=\"line\">\t        _maxLogSize = 20*1024*1024;</span><br><span class=\"line\">\t        _maxFileSize = 512*1024;</span><br><span class=\"line\">\t        _retry = 3;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    return self;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">```    </span><br><span class=\"line\">### 10、xcode 切换/build</span><br><span class=\"line\">1. xcodebuild -verison   (查看你的xcode版本)   </span><br><span class=\"line\">2. sudo xcode-select -switch xcode path , 例如：&lt;/Applications/Xcode8.0.app/Contents/Developer  &gt; (如果需要切换)    </span><br><span class=\"line\">3. xcodebuild -target &#123;你的工程名字&#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">### 11、关于`[NSString UTF8String]`返回null的问题</span><br><span class=\"line\">+ 首先，在使用UTF8String时要做好保护，因为其返回是可能为空的只是概率不高；</span><br><span class=\"line\">+ 返回null的一种可能情况：</span><br></pre></td></tr></table></figure>\n<p>NSString <em>ns = @”sdfhsdjf % C dsfsd”;<br>const char </em>s = [ns UTF8String];<br>```</p>\n<p><strong>原因：在字符串中出现了<code>% C</code>占位符。占位符的意义是会将指定内存格式化，但是这里没有指定内存，另外<code>%C</code>会将指定内存转为UTF-16，这样ns字符串中概率性的会出现非UTF8字符，所以转UTF8String时是会出现null的</strong></p>\n<h2 id=\"二、关于certificates-和provisioning-proflies\"><a href=\"#二、关于certificates-和provisioning-proflies\" class=\"headerlink\" title=\"二、关于certificates 和provisioning proflies\"></a>二、关于certificates 和provisioning proflies</h2><p>1、certificates：key(private key)</p>\n<p>2、provisioning profiles:(public key)</p>\n<ul>\n<li>appid(bundle identifier) </li>\n</ul>\n<ul>\n<li>devices(uuid)</li>\n</ul>\n<ul>\n<li>certificates(private key)  </li>\n</ul>\n<p>3、.p12是证书导出保存的形式<br>4、wwdr证书失效会导致自己证书无效</p>\n<h2 id=\"三、关于Clang-与LLVM\"><a href=\"#三、关于Clang-与LLVM\" class=\"headerlink\" title=\"三、关于Clang 与LLVM\"></a>三、关于Clang 与LLVM</h2><p>Clang 是一个 C++ 编写、基于 LLVM、发布于 LLVM BSD 许可证下的/C++/Objective C/Objective C++ 编译器。LLVM 是 Low Level Virtual Machine。具体介绍参考<a href=\"http://objccn.io/issue-6-2/\" target=\"_blank\" rel=\"noopener\">clang and llvm</a></p>\n<ul>\n<li>命令clang -E 是用于宏定义展开  </li>\n</ul>\n<h2 id=\"四、反馈系统UI设计问题：\"><a href=\"#四、反馈系统UI设计问题：\" class=\"headerlink\" title=\"四、反馈系统UI设计问题：\"></a>四、反馈系统UI设计问题：</h2><p>1、toolbar的设计问题，当用storyboard进行布局的时候要做到适配效果子在UIbarbuttonItem之间加入flexispace才能做到适配。</p>\n<p>2、关于storyboard initialViewcontrollerwithIdentiy的问题，当view还没出现的时生成的对象的成员都会是空的，只有到显示的时候才会出现。解决要对其进行参数传递的时候要采用property方法或者利用dispatch_after方式来做</p>\n<p>3、关于ipad版本浮动窗口形式的问题。当在ipad版本下设置Modalpresentationstyle就可以达到这种效果<br>4、关于storyboard的问题。一个app中可以有多个storyboard，通过instantiateviewcontrollerwithidentiter方式 来进行实例化。要注意的是storyboard要放到 mainbundle目录下<br>5、消除返回按钮上的文字，利用self.naviagtionitem.backbuttonitem = [[uibarbuttom alloc ]initwithtitle:@””] style:</p>\n<p>target:action];<a href=\"http://www.cnblogs.com/ygm900/p/3659619.html\" target=\"_blank\" rel=\"noopener\">参见</a>  </p>\n<h2 id=\"五、关于isKindOfClass与isMemberOfClass的区别：\"><a href=\"#五、关于isKindOfClass与isMemberOfClass的区别：\" class=\"headerlink\" title=\"五、关于isKindOfClass与isMemberOfClass的区别：\"></a>五、关于isKindOfClass与isMemberOfClass的区别：</h2><p>1、isKindOfClass，是判断一个对象是属于哪个类~~ 型，一直追溯到父类~~ 。或者子类的实例</p>\n<p>2、isMemberClass，是判断一个对象属于哪个类~~ 型，不追溯到父类!~~ 。   </p>\n<h2 id=\"六、Core-Data编程\"><a href=\"#六、Core-Data编程\" class=\"headerlink\" title=\"六、Core Data编程\"></a>六、Core Data编程</h2><p>1、core data 与sql的一些对应关系：</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>sql</th>\n<th>core data</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>表头</td>\n<td>表结构,实体，entity</td>\n<td>NSEntityDescription</td>\n</tr>\n<tr>\n<td>表中的一行数据</td>\n<td>记录</td>\n<td>NSManagedObject</td>\n</tr>\n<tr>\n<td>查询</td>\n<td>查询,select …</td>\n<td>NSFetchRequest</td>\n</tr>\n<tr>\n<td>持久化</td>\n<td>表存储,。。。</td>\n<td>NSPersistentStoreCoordinator</td>\n</tr>\n<tr>\n<td>数据库的设计，也就是.xcodemodel文件</td>\n<td>数据库模型,。。。</td>\n<td>NSManagedObjectModel</td>\n</tr>\n<tr>\n<td>操作上下文</td>\n<td>数据库操作</td>\n<td>NSManagedObjectContext</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"http://objccn.io/issue-4-1/\" target=\"_blank\" rel=\"noopener\">更详细的底层操作</a><br>2、<code>NSManagedObjectContext</code><br><code>NSManagedObjectContext</code>是程序员主要接触的一个类，也就是所有的操作基本上都通过它来操作的，底层是怎么实现的我们不需要去关心<br>3、<code>NSPersistentStoreCoordinator</code><br><code>NSPersistentStoreCoordinator</code>才是最终的操作实现都是才是核心,<a href=\"http://objccn.io/issue-4-1\" target=\"_blank\" rel=\"noopener\">参考</a><br>4、<a href=\"http://iiiyu.com/2013/03/29/learning-ios-notes-eighteen/\" target=\"_blank\" rel=\"noopener\">编程参考</a></p>\n<h2 id=\"七、关于异步加载问题\"><a href=\"#七、关于异步加载问题\" class=\"headerlink\" title=\"七、关于异步加载问题\"></a>七、关于异步加载问题</h2><p>1、<code>nsdata datawithcontentsofurl</code>是一个同步加载方法，因此要使用此方法要采用异步加载方法。可以适用于加载图片等；<br>2、注意<code>AFNertworking success/failure block</code> invoked in main thread。如果 没有进行队列设置默认会返回到主线程去。 </p>\n<pre><code>if(sucess)\n{\ndispatch_group_async(self.completionGroup?:http_request_operation_completion_group(),self.completionQueue?:dispatch_get_main_queue(),^{});\n}   \n</code></pre><h2 id=\"八、关于-strong-weak引用修饰符\"><a href=\"#八、关于-strong-weak引用修饰符\" class=\"headerlink\" title=\"八、关于 strong,weak引用修饰符\"></a>八、关于 strong,weak引用修饰符</h2><p>1、strong相当于手动引用计数（manual reference count）中的retain，拥有对象直到对象释放。<br>2、weak与strong刚好相反，weak并不持有对象，而且当对象释放时weak我修饰的对象会自动赋值为nil。例如：   </p>\n<pre><code>id _weak obj = [[NSObject alloc]init];//错误，weak不能持有对象    \nid _weak oo = nil;\n{\n   id strong object = [[NSObject alloc]init];\n   oo= object\n   NSLog(@&quot;%@&quot;,oo)//此处对象是存在的\n}\n</code></pre><h2 id=\"九、关于draweRect消耗内存\"><a href=\"#九、关于draweRect消耗内存\" class=\"headerlink\" title=\"九、关于draweRect消耗内存\"></a>九、<a href=\"http://bihongbo.com/2016/01/03/memoryGhostdrawRect/\" target=\"_blank\" rel=\"noopener\">关于draweRect消耗内存</a></h2><p>要想搞明白这个问题，我们需要撸一撸在<code>iOS</code>程序上图形显示的原理。在<code>iOS</code>系统中所有显示的视图都是从基类<code>UIView</code>继承而来的，同时<code>UIView</code>负责接收用户交互。<strong>但是实际上你所看到的视图内容，包括图形等，都是由<code>UIView</code>的一个实例图层属性来绘制和渲染的，那就是<code>CALayer</code>。</strong><br><strong>最终我们的图形渲染落点落在<code>contents</code>身上</strong><img src=\"http://7xkdhe.com1.z0.glb.clouddn.com/drawRect3.001.png\" alt=\"如图\">。<br><code>contents</code>也被称为寄宿图，除了给它赋值<code>CGImage</code>之外，我们也可以直接对它进行绘制，绘制的方法正是这次问题的关键，通过继承<code>UIView</code>并实现<code>-drawRect:</code>方法即可自定义绘制。<code>-drawRect:</code> 方法没有默认的实现，因为对<code>UIView</code>来说，寄宿图并不是必须的，<code>UIView</code>不关心绘制的内容。如果<code>UIView</code>检测到<code>-drawRect:</code>方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以<code>contentsScale</code>(这个属性与屏幕分辨率有关，我们的画板程序在不同模拟器下呈现的内存用量不同也是因为它)的值。这也就是<code>-drawRect:</code>消耗内存的原因。</p>\n<p><strong>解决方案：</strong>使用CAShapeLayer,另外与屏幕大小的画板可以算出消耗内存几M左右，可以接受   </p>\n<h2 id=\"十、关于设置圆角问题\"><a href=\"#十、关于设置圆角问题\" class=\"headerlink\" title=\"十、关于设置圆角问题\"></a>十、<a href=\"http://www.cocoachina.com/ios/20160301/15486.html\" target=\"_blank\" rel=\"noopener\">关于设置圆角问题</a></h2><p>由于设置圆角发生离屏渲染，所以对    </p>\n<h2 id=\"十一、数据持久化\"><a href=\"#十一、数据持久化\" class=\"headerlink\" title=\"十一、数据持久化\"></a>十一、<a href=\"http://casatwy.com/iosying-yong-jia-gou-tan-ben-di-chi-jiu-hua-fang-an-ji-dong-tai-bu-shu.html\" target=\"_blank\" rel=\"noopener\">数据持久化</a></h2><p>1.使用 archive的对象需要实现<nscoding>里的方法，关于NSCoder怎么使用参考如下 ：   </nscoding></p>\n<pre><code>- (    void)encodeWithCoder:(NSCoder *    )aCoder {\n    [aCoder encodeObject:self.firstName forKey:PERSON_KEY_FIRSTNAME];\n    [aCoder encodeObject:self.lastName forKey:PERSON_KEY_LASTNAME];\n    [aCoder encodeFloat:self.height forKey:PERSON_KEY_HEIGHT];\n}\n- (\nid\n)initWithCoder:(NSCoder *\n)aDecoder {\n    self \n=\n [super init];        \nif\n (self !=\n nil) {\n        self.firstName \n=\n [aDecoder decodeObjectForKey:PERSON_KEY_FIRSTNAME];\n        self.lastName \n=\n [aDecoder decodeObjectForKey:PERSON_KEY_LASTNAME];\n        self.height \n=\n [aDecoder decodeFloatForKey:PERSON_KEY_HEIGHT];\n    }        \nreturn\n self;\n}\n</code></pre><h2 id=\"十二、离屏渲染\"><a href=\"#十二、离屏渲染\" class=\"headerlink\" title=\"十二、离屏渲染\"></a>十二、离屏渲染</h2><p>设置了以下属性时，都会触发离屏绘制：    </p>\n<ul>\n<li>shouldRasterize（光栅化）  </li>\n<li>masks（遮罩）    </li>\n<li>shadows（阴影）   </li>\n<li>edge antialiasing（抗锯齿）  </li>\n</ul>\n<ul>\n<li>group opacity（不透明）   </li>\n</ul>\n<ul>\n<li>还有一种特殊的离屏渲染，<code>cpu</code>渲染，当我们使用drawRect时会触发</li>\n</ul>"},{"title":"学习资源大全","date":"2017-03-19T12:03:28.000Z","_content":"> 本篇Blog主要收藏一些优秀学习资源\n\n<!--More-->\n\n# 1、[TensorFlow学习资源大全，包括教程，博文，工程等](http://blog.jobbole.com/110558/)\n> tensorflow最近刚好想学，便收藏此等好文","source":"_posts/学习资源大全.md","raw":"---\ntitle: 学习资源大全\ndate: 2017-03-19 20:03:28\ntags: [网页, 学习资源]\ncategories: \"学习资源\"\n---\n> 本篇Blog主要收藏一些优秀学习资源\n\n<!--More-->\n\n# 1、[TensorFlow学习资源大全，包括教程，博文，工程等](http://blog.jobbole.com/110558/)\n> tensorflow最近刚好想学，便收藏此等好文","slug":"学习资源大全","published":1,"updated":"2022-06-15T07:23:15.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4fa2sa2000pdacoz5i2pfgz","content":"<blockquote>\n<p>本篇Blog主要收藏一些优秀学习资源</p>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"1、TensorFlow学习资源大全，包括教程，博文，工程等\"><a href=\"#1、TensorFlow学习资源大全，包括教程，博文，工程等\" class=\"headerlink\" title=\"1、TensorFlow学习资源大全，包括教程，博文，工程等\"></a>1、<a href=\"http://blog.jobbole.com/110558/\" target=\"_blank\" rel=\"noopener\">TensorFlow学习资源大全，包括教程，博文，工程等</a></h1><blockquote>\n<p>tensorflow最近刚好想学，便收藏此等好文</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本篇Blog主要收藏一些优秀学习资源</p>\n</blockquote>","more":"<h1 id=\"1、TensorFlow学习资源大全，包括教程，博文，工程等\"><a href=\"#1、TensorFlow学习资源大全，包括教程，博文，工程等\" class=\"headerlink\" title=\"1、TensorFlow学习资源大全，包括教程，博文，工程等\"></a>1、<a href=\"http://blog.jobbole.com/110558/\" target=\"_blank\" rel=\"noopener\">TensorFlow学习资源大全，包括教程，博文，工程等</a></h1><blockquote>\n<p>tensorflow最近刚好想学，便收藏此等好文</p>\n</blockquote>"},{"title":"设计模式","date":"2017-04-01T06:27:36.000Z","_content":"# [设计模式](http://design-patterns.readthedocs.org/zh_CN/latest/index.html) 与架构 \n\n\n<!--More-->\n\n# 一、创建型模式   \n## 1、单例\n单例概念不要多说，主要要注意单例的使用，不能[滥用单例](http://objccn.io/issue-13-2/)。单例使用时要注意，如果对象的生命周期短于应用的生命周期时就不应该使用单例，主要考虑对象的生命周期与对象的全局性。\n# 二、结构型模式\n## 1、门面模式（Facade pattern）  \n所谓的**门面模式**与现实的门面是一样的意思，暴露出的API的就像一个门一样，封装了一个或几个子系统。\n## 2、装饰模式（Decorator Pattern） \n**装饰模式**也称包装模式（wrapper）就是一个类来包裹别一个类,是继承关系的一种替代方式，所谓的装饰模式就是指动态地给对象添加一些额外的职责不改变接口，（如OC中category和delegation）。**原理**：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。\n## 3、适配器模式（Adapter pattern）\n**适配器模式**可以让因接口不兼容的类一起工作。适配器模式分为：1、类的适配器；2、对象的适配器。适配器其实就是一个转接类一个中间类。类的适配器所要做的事情就是要把类的API适配到目标类的API上，例如类的API少一个这时候适配器就需要增加一个api,采用继承的方式。对象的适配器目的与类的适配器是一样的，只是采用的是委托的方式不是继承的方式，实质就是适配器具有一个被适配器的实例。\n\n+ 如OC的protocol   \n+ 适配器的适用场合一般为，系统想利用已有类但是类与系统的接口不一致。也就是目标类与被适配者都存在。\n\n## 4、桥接模式  \n**桥接模式**中所谓的抽象与实现分离解耦，其实是把原来的基类的实现化细节抽象出来，在构造到一个实现化的结构中，然后再把原来的基类改造成一个抽象化的等级结构，这样就可以实现系统在多个维度上的独立变化   \n   \n+ 桥接模式首先要确定抽象主体，也就是两个因子中的一个因子作为抽象化的主体，另一个作为其成员变量形成关联关系\n\n# 三、行为型模式   \n## 1、备忘录模式\n所谓的备忘录模式就是将app的一结状态存到文件中去或者说是存到本地   \n## 2、命令模式\n命令模式是将命令封装成一个对象，命令的接收者与发送者作为参数会传给命令对象，这样子将接收者与发送者很好地解耦。例如OC的NSInvocation  \n\n\t NSMethodSignature *sig = [self methodSignatureForSelector:@selector(yourfunction)];\n\t    NSInvocation*undoAction = [NSInvocation invocationWithMethodSignature:sig];\n\t    [undoAction setTarget:self];\n\t    [undoAction setSelector:@selector(yourfunction)];\n\t    [undoAction setArgument:&deletedAlbum atIndex:2];\n\t    [undoAction setArgument:&currentAlbumIndex atIndex:3];\n\t    [undoAction retainArguments];//worry about the argument will call deallocate\n\t\n\tNOTE:\n\tThe arguments must be passed by pointer.\n\tThe arguments start at index 2; indices 0 and 1 are reserved for the target and the selector.\n\tIf there’s a chance that the arguments will be deallocated, then you should call retainArguments.\n\n\n# 四、模式之间的关系与区别\n<font color = red>**理解各种模式之间的区别，可以从各种模式的目的去区分**</font>\n\n## 4.1 装饰器与适配器  \n+ 适配器与被适配者接口不一样，而且适配器的目的就是兼容不同的接口  \n+ 装饰器要求与被装饰者有同样的接口，也就是说装饰器与被装饰者有共同的父类，装饰器会给被装饰者动态添加额外的操作    \n \n## 4.2 装饰器与代理（proxy）  \n+ 代理强调的是对真实对象的访问控制，而且真实对象一般都是代理的成员变量对用户是不可以见的。\n+ 在ios中的 Delegation本质上是装饰器。\n\n## 4.3门面模式与适配器模式 \n+ 外观与适配器都是对现存系统的封装。外观定义的新的接口，而适配器则是复用一个原有的接口，**适配器是使两个已有的接口协同工作，而外观则是为现存系统提供一个更为方便的访问接口**。如果硬要说外观是适配，那么适配器有用来适配对象的，而外观是用来适配整个子系统的。也就是说，外观所针对的对象的粒度更大。\n\n# 五、架构设计\n# 5.1 MVC,MVP,MVVM   \n+ 传统的MVC中间其实V与M是有直接通信的，ios的MVC其实是一个MVP   \n+ ios中的MVP其实就是将UIVIewController作为view","source":"_posts/设计模式.md","raw":"---\ntitle: 设计模式\ndate: 2017-04-01 14:27:36\ntags: [设计模式]\ncategories: 设计模式\n---\n# [设计模式](http://design-patterns.readthedocs.org/zh_CN/latest/index.html) 与架构 \n\n\n<!--More-->\n\n# 一、创建型模式   \n## 1、单例\n单例概念不要多说，主要要注意单例的使用，不能[滥用单例](http://objccn.io/issue-13-2/)。单例使用时要注意，如果对象的生命周期短于应用的生命周期时就不应该使用单例，主要考虑对象的生命周期与对象的全局性。\n# 二、结构型模式\n## 1、门面模式（Facade pattern）  \n所谓的**门面模式**与现实的门面是一样的意思，暴露出的API的就像一个门一样，封装了一个或几个子系统。\n## 2、装饰模式（Decorator Pattern） \n**装饰模式**也称包装模式（wrapper）就是一个类来包裹别一个类,是继承关系的一种替代方式，所谓的装饰模式就是指动态地给对象添加一些额外的职责不改变接口，（如OC中category和delegation）。**原理**：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。\n## 3、适配器模式（Adapter pattern）\n**适配器模式**可以让因接口不兼容的类一起工作。适配器模式分为：1、类的适配器；2、对象的适配器。适配器其实就是一个转接类一个中间类。类的适配器所要做的事情就是要把类的API适配到目标类的API上，例如类的API少一个这时候适配器就需要增加一个api,采用继承的方式。对象的适配器目的与类的适配器是一样的，只是采用的是委托的方式不是继承的方式，实质就是适配器具有一个被适配器的实例。\n\n+ 如OC的protocol   \n+ 适配器的适用场合一般为，系统想利用已有类但是类与系统的接口不一致。也就是目标类与被适配者都存在。\n\n## 4、桥接模式  \n**桥接模式**中所谓的抽象与实现分离解耦，其实是把原来的基类的实现化细节抽象出来，在构造到一个实现化的结构中，然后再把原来的基类改造成一个抽象化的等级结构，这样就可以实现系统在多个维度上的独立变化   \n   \n+ 桥接模式首先要确定抽象主体，也就是两个因子中的一个因子作为抽象化的主体，另一个作为其成员变量形成关联关系\n\n# 三、行为型模式   \n## 1、备忘录模式\n所谓的备忘录模式就是将app的一结状态存到文件中去或者说是存到本地   \n## 2、命令模式\n命令模式是将命令封装成一个对象，命令的接收者与发送者作为参数会传给命令对象，这样子将接收者与发送者很好地解耦。例如OC的NSInvocation  \n\n\t NSMethodSignature *sig = [self methodSignatureForSelector:@selector(yourfunction)];\n\t    NSInvocation*undoAction = [NSInvocation invocationWithMethodSignature:sig];\n\t    [undoAction setTarget:self];\n\t    [undoAction setSelector:@selector(yourfunction)];\n\t    [undoAction setArgument:&deletedAlbum atIndex:2];\n\t    [undoAction setArgument:&currentAlbumIndex atIndex:3];\n\t    [undoAction retainArguments];//worry about the argument will call deallocate\n\t\n\tNOTE:\n\tThe arguments must be passed by pointer.\n\tThe arguments start at index 2; indices 0 and 1 are reserved for the target and the selector.\n\tIf there’s a chance that the arguments will be deallocated, then you should call retainArguments.\n\n\n# 四、模式之间的关系与区别\n<font color = red>**理解各种模式之间的区别，可以从各种模式的目的去区分**</font>\n\n## 4.1 装饰器与适配器  \n+ 适配器与被适配者接口不一样，而且适配器的目的就是兼容不同的接口  \n+ 装饰器要求与被装饰者有同样的接口，也就是说装饰器与被装饰者有共同的父类，装饰器会给被装饰者动态添加额外的操作    \n \n## 4.2 装饰器与代理（proxy）  \n+ 代理强调的是对真实对象的访问控制，而且真实对象一般都是代理的成员变量对用户是不可以见的。\n+ 在ios中的 Delegation本质上是装饰器。\n\n## 4.3门面模式与适配器模式 \n+ 外观与适配器都是对现存系统的封装。外观定义的新的接口，而适配器则是复用一个原有的接口，**适配器是使两个已有的接口协同工作，而外观则是为现存系统提供一个更为方便的访问接口**。如果硬要说外观是适配，那么适配器有用来适配对象的，而外观是用来适配整个子系统的。也就是说，外观所针对的对象的粒度更大。\n\n# 五、架构设计\n# 5.1 MVC,MVP,MVVM   \n+ 传统的MVC中间其实V与M是有直接通信的，ios的MVC其实是一个MVP   \n+ ios中的MVP其实就是将UIVIewController作为view","slug":"设计模式","published":1,"updated":"2022-06-15T07:23:15.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4fa2sa3000rdacoh9t6kyva","content":"<h1 id=\"设计模式-与架构\"><a href=\"#设计模式-与架构\" class=\"headerlink\" title=\"设计模式 与架构\"></a><a href=\"http://design-patterns.readthedocs.org/zh_CN/latest/index.html\" target=\"_blank\" rel=\"noopener\">设计模式</a> 与架构</h1><a id=\"more\"></a>\n<h1 id=\"一、创建型模式\"><a href=\"#一、创建型模式\" class=\"headerlink\" title=\"一、创建型模式\"></a>一、创建型模式</h1><h2 id=\"1、单例\"><a href=\"#1、单例\" class=\"headerlink\" title=\"1、单例\"></a>1、单例</h2><p>单例概念不要多说，主要要注意单例的使用，不能<a href=\"http://objccn.io/issue-13-2/\" target=\"_blank\" rel=\"noopener\">滥用单例</a>。单例使用时要注意，如果对象的生命周期短于应用的生命周期时就不应该使用单例，主要考虑对象的生命周期与对象的全局性。</p>\n<h1 id=\"二、结构型模式\"><a href=\"#二、结构型模式\" class=\"headerlink\" title=\"二、结构型模式\"></a>二、结构型模式</h1><h2 id=\"1、门面模式（Facade-pattern）\"><a href=\"#1、门面模式（Facade-pattern）\" class=\"headerlink\" title=\"1、门面模式（Facade pattern）\"></a>1、门面模式（Facade pattern）</h2><p>所谓的<strong>门面模式</strong>与现实的门面是一样的意思，暴露出的API的就像一个门一样，封装了一个或几个子系统。</p>\n<h2 id=\"2、装饰模式（Decorator-Pattern）\"><a href=\"#2、装饰模式（Decorator-Pattern）\" class=\"headerlink\" title=\"2、装饰模式（Decorator Pattern）\"></a>2、装饰模式（Decorator Pattern）</h2><p><strong>装饰模式</strong>也称包装模式（wrapper）就是一个类来包裹别一个类,是继承关系的一种替代方式，所谓的装饰模式就是指动态地给对象添加一些额外的职责不改变接口，（如OC中category和delegation）。<strong>原理</strong>：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。</p>\n<h2 id=\"3、适配器模式（Adapter-pattern）\"><a href=\"#3、适配器模式（Adapter-pattern）\" class=\"headerlink\" title=\"3、适配器模式（Adapter pattern）\"></a>3、适配器模式（Adapter pattern）</h2><p><strong>适配器模式</strong>可以让因接口不兼容的类一起工作。适配器模式分为：1、类的适配器；2、对象的适配器。适配器其实就是一个转接类一个中间类。类的适配器所要做的事情就是要把类的API适配到目标类的API上，例如类的API少一个这时候适配器就需要增加一个api,采用继承的方式。对象的适配器目的与类的适配器是一样的，只是采用的是委托的方式不是继承的方式，实质就是适配器具有一个被适配器的实例。</p>\n<ul>\n<li>如OC的protocol   </li>\n<li>适配器的适用场合一般为，系统想利用已有类但是类与系统的接口不一致。也就是目标类与被适配者都存在。</li>\n</ul>\n<h2 id=\"4、桥接模式\"><a href=\"#4、桥接模式\" class=\"headerlink\" title=\"4、桥接模式\"></a>4、桥接模式</h2><p><strong>桥接模式</strong>中所谓的抽象与实现分离解耦，其实是把原来的基类的实现化细节抽象出来，在构造到一个实现化的结构中，然后再把原来的基类改造成一个抽象化的等级结构，这样就可以实现系统在多个维度上的独立变化   </p>\n<ul>\n<li>桥接模式首先要确定抽象主体，也就是两个因子中的一个因子作为抽象化的主体，另一个作为其成员变量形成关联关系</li>\n</ul>\n<h1 id=\"三、行为型模式\"><a href=\"#三、行为型模式\" class=\"headerlink\" title=\"三、行为型模式\"></a>三、行为型模式</h1><h2 id=\"1、备忘录模式\"><a href=\"#1、备忘录模式\" class=\"headerlink\" title=\"1、备忘录模式\"></a>1、备忘录模式</h2><p>所谓的备忘录模式就是将app的一结状态存到文件中去或者说是存到本地   </p>\n<h2 id=\"2、命令模式\"><a href=\"#2、命令模式\" class=\"headerlink\" title=\"2、命令模式\"></a>2、命令模式</h2><p>命令模式是将命令封装成一个对象，命令的接收者与发送者作为参数会传给命令对象，这样子将接收者与发送者很好地解耦。例如OC的NSInvocation  </p>\n<pre><code> NSMethodSignature *sig = [self methodSignatureForSelector:@selector(yourfunction)];\n    NSInvocation*undoAction = [NSInvocation invocationWithMethodSignature:sig];\n    [undoAction setTarget:self];\n    [undoAction setSelector:@selector(yourfunction)];\n    [undoAction setArgument:&amp;deletedAlbum atIndex:2];\n    [undoAction setArgument:&amp;currentAlbumIndex atIndex:3];\n    [undoAction retainArguments];//worry about the argument will call deallocate\n\nNOTE:\nThe arguments must be passed by pointer.\nThe arguments start at index 2; indices 0 and 1 are reserved for the target and the selector.\nIf there’s a chance that the arguments will be deallocated, then you should call retainArguments.\n</code></pre><h1 id=\"四、模式之间的关系与区别\"><a href=\"#四、模式之间的关系与区别\" class=\"headerlink\" title=\"四、模式之间的关系与区别\"></a>四、模式之间的关系与区别</h1><font color=\"red\"><strong>理解各种模式之间的区别，可以从各种模式的目的去区分</strong></font>\n\n<h2 id=\"4-1-装饰器与适配器\"><a href=\"#4-1-装饰器与适配器\" class=\"headerlink\" title=\"4.1 装饰器与适配器\"></a>4.1 装饰器与适配器</h2><ul>\n<li>适配器与被适配者接口不一样，而且适配器的目的就是兼容不同的接口  </li>\n<li>装饰器要求与被装饰者有同样的接口，也就是说装饰器与被装饰者有共同的父类，装饰器会给被装饰者动态添加额外的操作    </li>\n</ul>\n<h2 id=\"4-2-装饰器与代理（proxy）\"><a href=\"#4-2-装饰器与代理（proxy）\" class=\"headerlink\" title=\"4.2 装饰器与代理（proxy）\"></a>4.2 装饰器与代理（proxy）</h2><ul>\n<li>代理强调的是对真实对象的访问控制，而且真实对象一般都是代理的成员变量对用户是不可以见的。</li>\n<li>在ios中的 Delegation本质上是装饰器。</li>\n</ul>\n<h2 id=\"4-3门面模式与适配器模式\"><a href=\"#4-3门面模式与适配器模式\" class=\"headerlink\" title=\"4.3门面模式与适配器模式\"></a>4.3门面模式与适配器模式</h2><ul>\n<li>外观与适配器都是对现存系统的封装。外观定义的新的接口，而适配器则是复用一个原有的接口，<strong>适配器是使两个已有的接口协同工作，而外观则是为现存系统提供一个更为方便的访问接口</strong>。如果硬要说外观是适配，那么适配器有用来适配对象的，而外观是用来适配整个子系统的。也就是说，外观所针对的对象的粒度更大。</li>\n</ul>\n<h1 id=\"五、架构设计\"><a href=\"#五、架构设计\" class=\"headerlink\" title=\"五、架构设计\"></a>五、架构设计</h1><h1 id=\"5-1-MVC-MVP-MVVM\"><a href=\"#5-1-MVC-MVP-MVVM\" class=\"headerlink\" title=\"5.1 MVC,MVP,MVVM\"></a>5.1 MVC,MVP,MVVM</h1><ul>\n<li>传统的MVC中间其实V与M是有直接通信的，ios的MVC其实是一个MVP   </li>\n<li>ios中的MVP其实就是将UIVIewController作为view</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"设计模式-与架构\"><a href=\"#设计模式-与架构\" class=\"headerlink\" title=\"设计模式 与架构\"></a><a href=\"http://design-patterns.readthedocs.org/zh_CN/latest/index.html\" target=\"_blank\" rel=\"noopener\">设计模式</a> 与架构</h1>","more":"<h1 id=\"一、创建型模式\"><a href=\"#一、创建型模式\" class=\"headerlink\" title=\"一、创建型模式\"></a>一、创建型模式</h1><h2 id=\"1、单例\"><a href=\"#1、单例\" class=\"headerlink\" title=\"1、单例\"></a>1、单例</h2><p>单例概念不要多说，主要要注意单例的使用，不能<a href=\"http://objccn.io/issue-13-2/\" target=\"_blank\" rel=\"noopener\">滥用单例</a>。单例使用时要注意，如果对象的生命周期短于应用的生命周期时就不应该使用单例，主要考虑对象的生命周期与对象的全局性。</p>\n<h1 id=\"二、结构型模式\"><a href=\"#二、结构型模式\" class=\"headerlink\" title=\"二、结构型模式\"></a>二、结构型模式</h1><h2 id=\"1、门面模式（Facade-pattern）\"><a href=\"#1、门面模式（Facade-pattern）\" class=\"headerlink\" title=\"1、门面模式（Facade pattern）\"></a>1、门面模式（Facade pattern）</h2><p>所谓的<strong>门面模式</strong>与现实的门面是一样的意思，暴露出的API的就像一个门一样，封装了一个或几个子系统。</p>\n<h2 id=\"2、装饰模式（Decorator-Pattern）\"><a href=\"#2、装饰模式（Decorator-Pattern）\" class=\"headerlink\" title=\"2、装饰模式（Decorator Pattern）\"></a>2、装饰模式（Decorator Pattern）</h2><p><strong>装饰模式</strong>也称包装模式（wrapper）就是一个类来包裹别一个类,是继承关系的一种替代方式，所谓的装饰模式就是指动态地给对象添加一些额外的职责不改变接口，（如OC中category和delegation）。<strong>原理</strong>：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。</p>\n<h2 id=\"3、适配器模式（Adapter-pattern）\"><a href=\"#3、适配器模式（Adapter-pattern）\" class=\"headerlink\" title=\"3、适配器模式（Adapter pattern）\"></a>3、适配器模式（Adapter pattern）</h2><p><strong>适配器模式</strong>可以让因接口不兼容的类一起工作。适配器模式分为：1、类的适配器；2、对象的适配器。适配器其实就是一个转接类一个中间类。类的适配器所要做的事情就是要把类的API适配到目标类的API上，例如类的API少一个这时候适配器就需要增加一个api,采用继承的方式。对象的适配器目的与类的适配器是一样的，只是采用的是委托的方式不是继承的方式，实质就是适配器具有一个被适配器的实例。</p>\n<ul>\n<li>如OC的protocol   </li>\n<li>适配器的适用场合一般为，系统想利用已有类但是类与系统的接口不一致。也就是目标类与被适配者都存在。</li>\n</ul>\n<h2 id=\"4、桥接模式\"><a href=\"#4、桥接模式\" class=\"headerlink\" title=\"4、桥接模式\"></a>4、桥接模式</h2><p><strong>桥接模式</strong>中所谓的抽象与实现分离解耦，其实是把原来的基类的实现化细节抽象出来，在构造到一个实现化的结构中，然后再把原来的基类改造成一个抽象化的等级结构，这样就可以实现系统在多个维度上的独立变化   </p>\n<ul>\n<li>桥接模式首先要确定抽象主体，也就是两个因子中的一个因子作为抽象化的主体，另一个作为其成员变量形成关联关系</li>\n</ul>\n<h1 id=\"三、行为型模式\"><a href=\"#三、行为型模式\" class=\"headerlink\" title=\"三、行为型模式\"></a>三、行为型模式</h1><h2 id=\"1、备忘录模式\"><a href=\"#1、备忘录模式\" class=\"headerlink\" title=\"1、备忘录模式\"></a>1、备忘录模式</h2><p>所谓的备忘录模式就是将app的一结状态存到文件中去或者说是存到本地   </p>\n<h2 id=\"2、命令模式\"><a href=\"#2、命令模式\" class=\"headerlink\" title=\"2、命令模式\"></a>2、命令模式</h2><p>命令模式是将命令封装成一个对象，命令的接收者与发送者作为参数会传给命令对象，这样子将接收者与发送者很好地解耦。例如OC的NSInvocation  </p>\n<pre><code> NSMethodSignature *sig = [self methodSignatureForSelector:@selector(yourfunction)];\n    NSInvocation*undoAction = [NSInvocation invocationWithMethodSignature:sig];\n    [undoAction setTarget:self];\n    [undoAction setSelector:@selector(yourfunction)];\n    [undoAction setArgument:&amp;deletedAlbum atIndex:2];\n    [undoAction setArgument:&amp;currentAlbumIndex atIndex:3];\n    [undoAction retainArguments];//worry about the argument will call deallocate\n\nNOTE:\nThe arguments must be passed by pointer.\nThe arguments start at index 2; indices 0 and 1 are reserved for the target and the selector.\nIf there’s a chance that the arguments will be deallocated, then you should call retainArguments.\n</code></pre><h1 id=\"四、模式之间的关系与区别\"><a href=\"#四、模式之间的关系与区别\" class=\"headerlink\" title=\"四、模式之间的关系与区别\"></a>四、模式之间的关系与区别</h1><font color=\"red\"><strong>理解各种模式之间的区别，可以从各种模式的目的去区分</strong></font>\n\n<h2 id=\"4-1-装饰器与适配器\"><a href=\"#4-1-装饰器与适配器\" class=\"headerlink\" title=\"4.1 装饰器与适配器\"></a>4.1 装饰器与适配器</h2><ul>\n<li>适配器与被适配者接口不一样，而且适配器的目的就是兼容不同的接口  </li>\n<li>装饰器要求与被装饰者有同样的接口，也就是说装饰器与被装饰者有共同的父类，装饰器会给被装饰者动态添加额外的操作    </li>\n</ul>\n<h2 id=\"4-2-装饰器与代理（proxy）\"><a href=\"#4-2-装饰器与代理（proxy）\" class=\"headerlink\" title=\"4.2 装饰器与代理（proxy）\"></a>4.2 装饰器与代理（proxy）</h2><ul>\n<li>代理强调的是对真实对象的访问控制，而且真实对象一般都是代理的成员变量对用户是不可以见的。</li>\n<li>在ios中的 Delegation本质上是装饰器。</li>\n</ul>\n<h2 id=\"4-3门面模式与适配器模式\"><a href=\"#4-3门面模式与适配器模式\" class=\"headerlink\" title=\"4.3门面模式与适配器模式\"></a>4.3门面模式与适配器模式</h2><ul>\n<li>外观与适配器都是对现存系统的封装。外观定义的新的接口，而适配器则是复用一个原有的接口，<strong>适配器是使两个已有的接口协同工作，而外观则是为现存系统提供一个更为方便的访问接口</strong>。如果硬要说外观是适配，那么适配器有用来适配对象的，而外观是用来适配整个子系统的。也就是说，外观所针对的对象的粒度更大。</li>\n</ul>\n<h1 id=\"五、架构设计\"><a href=\"#五、架构设计\" class=\"headerlink\" title=\"五、架构设计\"></a>五、架构设计</h1><h1 id=\"5-1-MVC-MVP-MVVM\"><a href=\"#5-1-MVC-MVP-MVVM\" class=\"headerlink\" title=\"5.1 MVC,MVP,MVVM\"></a>5.1 MVC,MVP,MVVM</h1><ul>\n<li>传统的MVC中间其实V与M是有直接通信的，ios的MVC其实是一个MVP   </li>\n<li>ios中的MVP其实就是将UIVIewController作为view</li>\n</ul>"},{"title":"hexo使用手册","date":"2017-03-19T03:04:18.000Z","_content":"\n> Hexo 的日常使用，包括增加，修改以及多设备操作\n\n<!--More-->\n\n## 一、关于日常笔记（添加新，修改等）：\n+ 依次执行git pull, git add .、git commit -m \"...\"、git push origin hexo指令将改动推送到GitHub；\n+ 然后才执行`hexo clean g d`发布网站到master分支上 \n+ master分支不用理会，hexo管理   \n\n## 二、其它设备上使用下列步骤：\n+ 使用git clone -b hexo https://github.com/xxxx/xxxx.git ；\n+ 在本地库中执行：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init）\n\n## 三、Git https 转 ssh\n### git clone 时一般有两种方式https和ssh，但是https模式下每一次push都需要输入用户名与密码，而ssh方式下只要设置好ssh后不需要每一次都输入用户名与密码。那么如果一个https如何才能转成ssh呢，那就按以下步骤：    \n+ 通过`git remote -v`查看当前模式\n+ 通过`git remote set-url git@github.com:xxxx/xxx.git`便可转成ssh\n\n\n## 四、关于hexo使用markdown语法\n+ 代码块使用tap键缩进，不要使用语法\n+ 标题与`##`之间要空格\n\n## 五、hexo相关图片如果需要站点内部引用则需要放置:`themes/next/source/uploads(images)`","source":"_posts/hexo使用手册.md","raw":"---\ntitle: hexo使用手册\ndate: 2017-03-19 11:04:18\ncategories: Hexo\ntags: 使用手册\n---\n\n> Hexo 的日常使用，包括增加，修改以及多设备操作\n\n<!--More-->\n\n## 一、关于日常笔记（添加新，修改等）：\n+ 依次执行git pull, git add .、git commit -m \"...\"、git push origin hexo指令将改动推送到GitHub；\n+ 然后才执行`hexo clean g d`发布网站到master分支上 \n+ master分支不用理会，hexo管理   \n\n## 二、其它设备上使用下列步骤：\n+ 使用git clone -b hexo https://github.com/xxxx/xxxx.git ；\n+ 在本地库中执行：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init）\n\n## 三、Git https 转 ssh\n### git clone 时一般有两种方式https和ssh，但是https模式下每一次push都需要输入用户名与密码，而ssh方式下只要设置好ssh后不需要每一次都输入用户名与密码。那么如果一个https如何才能转成ssh呢，那就按以下步骤：    \n+ 通过`git remote -v`查看当前模式\n+ 通过`git remote set-url git@github.com:xxxx/xxx.git`便可转成ssh\n\n\n## 四、关于hexo使用markdown语法\n+ 代码块使用tap键缩进，不要使用语法\n+ 标题与`##`之间要空格\n\n## 五、hexo相关图片如果需要站点内部引用则需要放置:`themes/next/source/uploads(images)`","slug":"hexo使用手册","published":1,"updated":"2022-06-15T07:23:15.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4fa2sa4000wdacomvy7nazu","content":"<blockquote>\n<p>Hexo 的日常使用，包括增加，修改以及多设备操作</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"一、关于日常笔记（添加新，修改等）：\"><a href=\"#一、关于日常笔记（添加新，修改等）：\" class=\"headerlink\" title=\"一、关于日常笔记（添加新，修改等）：\"></a>一、关于日常笔记（添加新，修改等）：</h2><ul>\n<li>依次执行git pull, git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub；</li>\n<li>然后才执行<code>hexo clean g d</code>发布网站到master分支上 </li>\n<li>master分支不用理会，hexo管理   </li>\n</ul>\n<h2 id=\"二、其它设备上使用下列步骤：\"><a href=\"#二、其它设备上使用下列步骤：\" class=\"headerlink\" title=\"二、其它设备上使用下列步骤：\"></a>二、其它设备上使用下列步骤：</h2><ul>\n<li>使用git clone -b hexo <a href=\"https://github.com/xxxx/xxxx.git\" target=\"_blank\" rel=\"noopener\">https://github.com/xxxx/xxxx.git</a> ；</li>\n<li>在本地库中执行：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init）</li>\n</ul>\n<h2 id=\"三、Git-https-转-ssh\"><a href=\"#三、Git-https-转-ssh\" class=\"headerlink\" title=\"三、Git https 转 ssh\"></a>三、Git https 转 ssh</h2><h3 id=\"git-clone-时一般有两种方式https和ssh，但是https模式下每一次push都需要输入用户名与密码，而ssh方式下只要设置好ssh后不需要每一次都输入用户名与密码。那么如果一个https如何才能转成ssh呢，那就按以下步骤：\"><a href=\"#git-clone-时一般有两种方式https和ssh，但是https模式下每一次push都需要输入用户名与密码，而ssh方式下只要设置好ssh后不需要每一次都输入用户名与密码。那么如果一个https如何才能转成ssh呢，那就按以下步骤：\" class=\"headerlink\" title=\"git clone 时一般有两种方式https和ssh，但是https模式下每一次push都需要输入用户名与密码，而ssh方式下只要设置好ssh后不需要每一次都输入用户名与密码。那么如果一个https如何才能转成ssh呢，那就按以下步骤：\"></a>git clone 时一般有两种方式https和ssh，但是https模式下每一次push都需要输入用户名与密码，而ssh方式下只要设置好ssh后不需要每一次都输入用户名与密码。那么如果一个https如何才能转成ssh呢，那就按以下步骤：</h3><ul>\n<li>通过<code>git remote -v</code>查看当前模式</li>\n<li>通过<code>git remote set-url git@github.com:xxxx/xxx.git</code>便可转成ssh</li>\n</ul>\n<h2 id=\"四、关于hexo使用markdown语法\"><a href=\"#四、关于hexo使用markdown语法\" class=\"headerlink\" title=\"四、关于hexo使用markdown语法\"></a>四、关于hexo使用markdown语法</h2><ul>\n<li>代码块使用tap键缩进，不要使用语法</li>\n<li>标题与<code>##</code>之间要空格</li>\n</ul>\n<h2 id=\"五、hexo相关图片如果需要站点内部引用则需要放置-themes-next-source-uploads-images\"><a href=\"#五、hexo相关图片如果需要站点内部引用则需要放置-themes-next-source-uploads-images\" class=\"headerlink\" title=\"五、hexo相关图片如果需要站点内部引用则需要放置:themes/next/source/uploads(images)\"></a>五、hexo相关图片如果需要站点内部引用则需要放置:<code>themes/next/source/uploads(images)</code></h2>","site":{"data":{}},"excerpt":"<blockquote>\n<p>Hexo 的日常使用，包括增加，修改以及多设备操作</p>\n</blockquote>","more":"<h2 id=\"一、关于日常笔记（添加新，修改等）：\"><a href=\"#一、关于日常笔记（添加新，修改等）：\" class=\"headerlink\" title=\"一、关于日常笔记（添加新，修改等）：\"></a>一、关于日常笔记（添加新，修改等）：</h2><ul>\n<li>依次执行git pull, git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub；</li>\n<li>然后才执行<code>hexo clean g d</code>发布网站到master分支上 </li>\n<li>master分支不用理会，hexo管理   </li>\n</ul>\n<h2 id=\"二、其它设备上使用下列步骤：\"><a href=\"#二、其它设备上使用下列步骤：\" class=\"headerlink\" title=\"二、其它设备上使用下列步骤：\"></a>二、其它设备上使用下列步骤：</h2><ul>\n<li>使用git clone -b hexo <a href=\"https://github.com/xxxx/xxxx.git\" target=\"_blank\" rel=\"noopener\">https://github.com/xxxx/xxxx.git</a> ；</li>\n<li>在本地库中执行：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init）</li>\n</ul>\n<h2 id=\"三、Git-https-转-ssh\"><a href=\"#三、Git-https-转-ssh\" class=\"headerlink\" title=\"三、Git https 转 ssh\"></a>三、Git https 转 ssh</h2><h3 id=\"git-clone-时一般有两种方式https和ssh，但是https模式下每一次push都需要输入用户名与密码，而ssh方式下只要设置好ssh后不需要每一次都输入用户名与密码。那么如果一个https如何才能转成ssh呢，那就按以下步骤：\"><a href=\"#git-clone-时一般有两种方式https和ssh，但是https模式下每一次push都需要输入用户名与密码，而ssh方式下只要设置好ssh后不需要每一次都输入用户名与密码。那么如果一个https如何才能转成ssh呢，那就按以下步骤：\" class=\"headerlink\" title=\"git clone 时一般有两种方式https和ssh，但是https模式下每一次push都需要输入用户名与密码，而ssh方式下只要设置好ssh后不需要每一次都输入用户名与密码。那么如果一个https如何才能转成ssh呢，那就按以下步骤：\"></a>git clone 时一般有两种方式https和ssh，但是https模式下每一次push都需要输入用户名与密码，而ssh方式下只要设置好ssh后不需要每一次都输入用户名与密码。那么如果一个https如何才能转成ssh呢，那就按以下步骤：</h3><ul>\n<li>通过<code>git remote -v</code>查看当前模式</li>\n<li>通过<code>git remote set-url git@github.com:xxxx/xxx.git</code>便可转成ssh</li>\n</ul>\n<h2 id=\"四、关于hexo使用markdown语法\"><a href=\"#四、关于hexo使用markdown语法\" class=\"headerlink\" title=\"四、关于hexo使用markdown语法\"></a>四、关于hexo使用markdown语法</h2><ul>\n<li>代码块使用tap键缩进，不要使用语法</li>\n<li>标题与<code>##</code>之间要空格</li>\n</ul>\n<h2 id=\"五、hexo相关图片如果需要站点内部引用则需要放置-themes-next-source-uploads-images\"><a href=\"#五、hexo相关图片如果需要站点内部引用则需要放置-themes-next-source-uploads-images\" class=\"headerlink\" title=\"五、hexo相关图片如果需要站点内部引用则需要放置:themes/next/source/uploads(images)\"></a>五、hexo相关图片如果需要站点内部引用则需要放置:<code>themes/next/source/uploads(images)</code></h2>"}],"PostAsset":[],"PostCategory":[{"post_id":"cl4fa2s9o0002daco0s5lc8bi","category_id":"cl4fa2s9r0005daco9c6h6rsk","_id":"cl4fa2sa0000edacoilaunqp9"},{"post_id":"cl4fa2s9y0009daconl71c7rh","category_id":"cl4fa2s9r0005daco9c6h6rsk","_id":"cl4fa2sa1000idaco2uujebgc"},{"post_id":"cl4fa2s9q0004daco914aug2h","category_id":"cl4fa2s9y000adacopb3wgk6r","_id":"cl4fa2sa2000mdacosrvkpfmk"},{"post_id":"cl4fa2s9t0007daco68bmg6a0","category_id":"cl4fa2sa0000fdaco16f8561s","_id":"cl4fa2sa4000sdacoex4vfqhq"},{"post_id":"cl4fa2sa1000kdacoj44a5ar6","category_id":"cl4fa2s9r0005daco9c6h6rsk","_id":"cl4fa2sa4000xdacoegfdca78"},{"post_id":"cl4fa2s9w0008dacoz4oppgyh","category_id":"cl4fa2sa2000ndaco43m6gdrv","_id":"cl4fa2sa50010dacoilo86n15"},{"post_id":"cl4fa2s9z000cdacok6qfj4rt","category_id":"cl4fa2sa4000vdaco91frf97a","_id":"cl4fa2sa50014dacoog5sso7g"},{"post_id":"cl4fa2s9z000ddacotn4cc1ca","category_id":"cl4fa2sa50012dacomom0huz0","_id":"cl4fa2sa60019dacornhhhb18"},{"post_id":"cl4fa2sa2000pdacoz5i2pfgz","category_id":"cl4fa2sa50015dacollutvj30","_id":"cl4fa2sa6001cdaco3h3hewbj"},{"post_id":"cl4fa2sa3000rdacoh9t6kyva","category_id":"cl4fa2sa6001adacoud4j19om","_id":"cl4fa2sa6001hdacobtk688qr"},{"post_id":"cl4fa2sa4000wdacomvy7nazu","category_id":"cl4fa2sa6001ddacoxeveh4l9","_id":"cl4fa2sa7001ldacokl0qn2hi"}],"PostTag":[{"post_id":"cl4fa2s9o0002daco0s5lc8bi","tag_id":"cl4fa2s9s0006daco3squbree","_id":"cl4fa2sa1000jdacogv71ne2y"},{"post_id":"cl4fa2s9o0002daco0s5lc8bi","tag_id":"cl4fa2s9y000bdaco7jjec8cp","_id":"cl4fa2sa1000ldacotdjoz68g"},{"post_id":"cl4fa2sa1000kdacoj44a5ar6","tag_id":"cl4fa2s9s0006daco3squbree","_id":"cl4fa2sa3000qdaconwh7o9k1"},{"post_id":"cl4fa2sa1000kdacoj44a5ar6","tag_id":"cl4fa2s9y000bdaco7jjec8cp","_id":"cl4fa2sa4000udaco7vm45wh4"},{"post_id":"cl4fa2s9q0004daco914aug2h","tag_id":"cl4fa2sa0000gdaco8oyr5o7x","_id":"cl4fa2sa4000ydaco7wcmy0ne"},{"post_id":"cl4fa2s9q0004daco914aug2h","tag_id":"cl4fa2s9y000bdaco7jjec8cp","_id":"cl4fa2sa5000zdaco13shug59"},{"post_id":"cl4fa2s9t0007daco68bmg6a0","tag_id":"cl4fa2sa4000tdaco7pyuldjh","_id":"cl4fa2sa50016dacooq21je9o"},{"post_id":"cl4fa2s9t0007daco68bmg6a0","tag_id":"cl4fa2s9y000bdaco7jjec8cp","_id":"cl4fa2sa50017dacoha110dj4"},{"post_id":"cl4fa2s9w0008dacoz4oppgyh","tag_id":"cl4fa2sa50013dacon5keixfc","_id":"cl4fa2sa6001edacorkcucho6"},{"post_id":"cl4fa2s9w0008dacoz4oppgyh","tag_id":"cl4fa2s9y000bdaco7jjec8cp","_id":"cl4fa2sa6001fdacoo1veoijw"},{"post_id":"cl4fa2s9y0009daconl71c7rh","tag_id":"cl4fa2s9s0006daco3squbree","_id":"cl4fa2sa7001idacoqf4mdktw"},{"post_id":"cl4fa2s9y0009daconl71c7rh","tag_id":"cl4fa2sa6001bdacok596r5mv","_id":"cl4fa2sa7001jdacoue9ctupc"},{"post_id":"cl4fa2s9z000cdacok6qfj4rt","tag_id":"cl4fa2sa6001gdacoeo5zbslf","_id":"cl4fa2sa7001ndacorc8d0u1l"},{"post_id":"cl4fa2s9z000cdacok6qfj4rt","tag_id":"cl4fa2sa7001kdaconfy1q1zs","_id":"cl4fa2sa7001odacowc5mzubd"},{"post_id":"cl4fa2s9z000ddacotn4cc1ca","tag_id":"cl4fa2sa7001mdacog18cffl1","_id":"cl4fa2sa7001qdacof6d5n86a"},{"post_id":"cl4fa2s9z000ddacotn4cc1ca","tag_id":"cl4fa2s9y000bdaco7jjec8cp","_id":"cl4fa2sa7001rdacox50ai98l"},{"post_id":"cl4fa2sa2000pdacoz5i2pfgz","tag_id":"cl4fa2sa7001pdaconjrljn1h","_id":"cl4fa2sa8001udacovb9lghek"},{"post_id":"cl4fa2sa2000pdacoz5i2pfgz","tag_id":"cl4fa2sa7001sdaconvx2hb7r","_id":"cl4fa2sa8001vdacordg5mqno"},{"post_id":"cl4fa2sa3000rdacoh9t6kyva","tag_id":"cl4fa2sa8001tdacorrawswxy","_id":"cl4fa2sa8001xdaco9v0wtsok"},{"post_id":"cl4fa2sa4000wdacomvy7nazu","tag_id":"cl4fa2sa7001kdaconfy1q1zs","_id":"cl4fa2sa8001ydacogxsbh93j"}],"Tag":[{"name":"iOS","_id":"cl4fa2s9s0006daco3squbree"},{"name":"Dev","_id":"cl4fa2s9y000bdaco7jjec8cp"},{"name":"C/C++","_id":"cl4fa2sa0000gdaco8oyr5o7x"},{"name":"Lua","_id":"cl4fa2sa4000tdaco7pyuldjh"},{"name":"Unity","_id":"cl4fa2sa50013dacon5keixfc"},{"name":"swift","_id":"cl4fa2sa6001bdacok596r5mv"},{"name":"git","_id":"cl4fa2sa6001gdacoeo5zbslf"},{"name":"使用手册","_id":"cl4fa2sa7001kdaconfy1q1zs"},{"name":"Python","_id":"cl4fa2sa7001mdacog18cffl1"},{"name":"网页","_id":"cl4fa2sa7001pdaconjrljn1h"},{"name":"学习资源","_id":"cl4fa2sa7001sdaconvx2hb7r"},{"name":"设计模式","_id":"cl4fa2sa8001tdacorrawswxy"}]}}