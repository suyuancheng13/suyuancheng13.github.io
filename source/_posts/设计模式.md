---
title: 设计模式
date: 2017-04-01 14:27:36
tags: [设计模式]
categories: 设计模式
---



# [设计模式](http://design-patterns.readthedocs.org/zh_CN/latest/index.html) 与架构 


<!--More-->

# 一、创建型模式   
## 1、单例
单例概念不要多说，主要要注意单例的使用，不能[滥用单例](http://objccn.io/issue-13-2/)。单例使用时要注意，如果对象的生命周期短于应用的生命周期时就不应该使用单例，主要考虑对象的生命周期与对象的全局性。
# 二、结构型模式
## 1、门面模式（Facade pattern）  
所谓的**门面模式**与现实的门面是一样的意思，暴露出的API的就像一个门一样，封装了一个或几个子系统。
## 2、装饰模式（Decorator Pattern） 
**装饰模式**也称包装模式（wrapper）就是一个类来包裹别一个类,是继承关系的一种替代方式，所谓的装饰模式就是指动态地给对象添加一些额外的职责不改变接口，（如OC中category和delegation）。**原理**：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。
## 3、适配器模式（Adapter pattern）
**适配器模式**可以让因接口不兼容的类一起工作。适配器模式分为：1、类的适配器；2、对象的适配器。适配器其实就是一个转接类一个中间类。类的适配器所要做的事情就是要把类的API适配到目标类的API上，例如类的API少一个这时候适配器就需要增加一个api,采用继承的方式。对象的适配器目的与类的适配器是一样的，只是采用的是委托的方式不是继承的方式，实质就是适配器具有一个被适配器的实例。

+ 如OC的protocol   
+ 适配器的适用场合一般为，系统想利用已有类但是类与系统的接口不一致。也就是目标类与被适配者都存在。

## 4、桥接模式  
**桥接模式**中所谓的抽象与实现分离解耦，其实是把原来的基类的实现化细节抽象出来，在构造到一个实现化的结构中，然后再把原来的基类改造成一个抽象化的等级结构，这样就可以实现系统在多个维度上的独立变化   
   
+ 桥接模式首先要确定抽象主体，也就是两个因子中的一个因子作为抽象化的主体，另一个作为其成员变量形成关联关系

# 三、行为型模式   
## 1、备忘录模式
所谓的备忘录模式就是将app的一结状态存到文件中去或者说是存到本地   
## 2、命令模式
命令模式是将命令封装成一个对象，命令的接收者与发送者作为参数会传给命令对象，这样子将接收者与发送者很好地解耦。例如OC的NSInvocation  

	 NSMethodSignature *sig = [self methodSignatureForSelector:@selector(yourfunction)];
	    NSInvocation*undoAction = [NSInvocation invocationWithMethodSignature:sig];
	    [undoAction setTarget:self];
	    [undoAction setSelector:@selector(yourfunction)];
	    [undoAction setArgument:&deletedAlbum atIndex:2];
	    [undoAction setArgument:&currentAlbumIndex atIndex:3];
	    [undoAction retainArguments];//worry about the argument will call deallocate
	
	NOTE:
	The arguments must be passed by pointer.
	The arguments start at index 2; indices 0 and 1 are reserved for the target and the selector.
	If there’s a chance that the arguments will be deallocated, then you should call retainArguments.


# 四、模式之间的关系与区别
<font color = red>**理解各种模式之间的区别，可以从各种模式的目的去区分**</font>

## 4.1 装饰器与适配器  
+ 适配器与被适配者接口不一样，而且适配器的目的就是兼容不同的接口  
+ 装饰器要求与被装饰者有同样的接口，也就是说装饰器与被装饰者有共同的父类，装饰器会给被装饰者动态添加额外的操作    
 
## 4.2 装饰器与代理（proxy）  
+ 代理强调的是对真实对象的访问控制，而且真实对象一般都是代理的成员变量对用户是不可以见的。
+ 在ios中的 Delegation本质上是装饰器。

## 4.3门面模式与适配器模式 
+ 外观与适配器都是对现存系统的封装。外观定义的新的接口，而适配器则是复用一个原有的接口，**适配器是使两个已有的接口协同工作，而外观则是为现存系统提供一个更为方便的访问接口**。如果硬要说外观是适配，那么适配器有用来适配对象的，而外观是用来适配整个子系统的。也就是说，外观所针对的对象的粒度更大。

# 五、架构设计
# 5.1 MVC,MVP,MVVM   
+ 传统的MVC中间其实V与M是有直接通信的，ios的MVC其实是一个MVP   
+ ios中的MVP其实就是将UIVIewController作为view