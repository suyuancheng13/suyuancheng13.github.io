---
title: C/C++ Dev
date: 2017-03-19 17:27:29
categories: C/C++
tags: [C/C++,Dev]
---

> C/C++ 相关知识储备

<!-- More-->

# 一、基础知识
## 1、关于类的静态成员赋值问题
静态成员在实现文件中直接初始化不能在头文件里进行就地初始化，如：
**错误**



	Class A   
	{     
	   static n = 10;
	}      
  



**正确：**在实现文件中   



	int A：：n=10；//不需要static 关键字
 
 
**原因**
因为class的声明都通常在头文件中，如果允许这样做其实就相当于在头文件里定义了一个非const的变量。头文件因为会被包含到多个文件中去，而非const变量的链接属性是内部链接也就是不会在编译时在导出符号表中，因此在某个文件中对其修改不会影响到别的文件，而这不是我们想要的结果。另外，const变量的可以的，因为const变量是只读的而且链接属性是外部链接也就是在编译时会导出符号表，就不存在上述现象。**c/c++在编译时会生成三个符号表：未解决符号表（待填入的变量如extern），导出符号表（用于链接到别的模块的变量与函数），重定位符号表（用于在链接时组成可运行程序内的全局地址）**       

## 2、关于内联函数在头文件里定义的原因
因为编译时每一个单元之间是不通的也就是相互独立，如果将内联函数定义在.cpp文件中就那么就只能这一个cpp文件可以用到这个内联函数了，其它的单元会因为找不到这个定义而无法进行函数展开。（与.h /.cpp不一样的原因是内联函数其实是在编译时进行一个展开，而一般的函数并不进行展开）

## 3、关于枚举变量


	enum weekly {sun,sat,frid};weekly test;
	test = sun;/*test 只能赋予 {sun,sat,frid}中枚举出的值，或者进行强制类型转换的赋值如：test = (weekly)0，意为将枚举中的第0个元素赋予test*/


## 4、关于float变量

1，规范IEEE754有关于0的描述。  


2，由于float是不确定的描述，所以一般不要对其进行比较！

## 5、关于构造函数（派生类与父类的调用关系）  

**原则就是父类的构造函数一定要调用不管是显示还是隐式**

1、如果子类没有定义构造函数，则调用父类无参构造函数（默认构造函数）；

2、如果子类定义了有参构造函数，创建子类对象时候，先执行父类无参构造函数，然后执行子类构造 函数；

3、如果子类构造函数没有显示调用父类构造函数，则会调用父类默认无参构造函数；

4、如果子类构造函数没有显示调用父类构造函数且父类提供了无参构造函数，则会调用父类的无参默认构造函数

5、如果子类构造函数没有显示调用 父类构造函数且父类只定义了有参构造函数，则会出错  

## 6、关于C/C++符号表问题
1、C++支持重载C不支持重载的原因：C在编译时生成符号表时只根据<font color = red>**函数名**</font>生成，而C++生成的符号表是由<font color = red>**函数名+参数**</font>生成的   


2、C++不能以返回值不同作为重载区分的原因：同上，由于C++生成的符号表是由<font color = red>**函数名+参数**</font>生成的，并不包含返回值    

## 7、关于C++继承访问控制问题

|  父类访问控制| public | protected | private |    
| -- | -- | -- | --|    
|public 继承| public |  protected | 不可用 |      
|protected 继承| protected |  protected | 不可用 |     
|private 继承|  private  |   private | 不可用 |      

**protected**：不可以被用户访问，只可以被派生类访问  

**private**：都不可以访问，除了自己外。    

# 8、[重写，重载，覆盖的关系]( http://blog.csdn.net/ericbaner/article/details/3857268)   

+ 重写= 覆盖，是子类重写（覆盖）父类的方法，也就是同名同参数的方法   

+ 重载，是一个作用域内有两个或者多个同名的方法（参数不一样），重载不能根据返回值不同进行重载       

## 9.静态变量也全局变量的区别
+ 从内存分配来说：     
  + 静态变量与全局变量都是在程序静态区域      
+ 从链接属性来说：     
  + 静态全局变量只能在本文件访问，全局变量能在多文件间访问     

静态全局变量与全局变量的区别就在于链接属性

## 二、关于编码问题

1、**Ascii**：c语言中的ascii表，一个字节

2、**unicode**：为了拓展表示更多的语言，例如中文就无法用ascii码表示，二个字节

3、**utf-8**：用unicode可以解决编码的问题，但是全部采用二个字节一般情况下是比较浪费的，所以就出现了可变长的unicode编码方式。utf-8根据不同的字符编码成1-6个字节的可变长，常用 的英文字母就编码成一个字节与ascii码一至，中方字符则编码成三个字节。这样utf-8其实是包括了ascii的。

## 三、关于`static`关键字问题

1、**静态变量**属于静态存储方式，其存储空间为内存中的静态数据区（在静态存储区内分配存储单元）；

2、**静态变量**可以在任何可以申请的地方申请，一旦申请成功后，它将不再接受其他的同样申请。 函数体内如果在定义静态变量的同时进行了初始化，则以后程序不再进行初始化操作（出现在函数内部的基本类型的的静态变量初始化语句只有在第一次调用才执行）。而对自动变量赋初值是在函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语句 例如：


```   

	class test
	
	{
	
	private :
	 int a;
	public :
	    test( int _a): a (_a)
	
	    {
	
	        NSLog ( @"test:%d\n" , a );
	
	
	    }
	
	};
	
	void testFunction( int a)
	
	{
	  static test te(a);
	    NSLog ( @"\n%p\n" ,&te);
	    static int bb= 10 ;
	    NSLog ( @"\nbb value:%d\n" ,bb);
	
	    bb ++;
	  NSLog ( @"\nbb value:%d\n" ,bb);
	
	}
	
	void TEST()
	
	{
	
	     testFunction ( 10 );
	
	    testFunction ( 11 );
	}

```

bb的结果：

```

	10
	
	11
	
	11
	
	12

```

同理，test类的构造函数也只会调用一次 

>  它将不再接受其他的同样申请       




## 四、关于递归函数问题

1、我们都知道递归层次过多会导致栈溢出，那么关于递归优化我们可以使用循环`while`来进行改写，其实我们也可以使用[尾递归]( https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8)的方式进行改写。   

2、尾调用，先来看一段代码：

```

	func ()
	
	{
	
	.....
	
	return g()
	
	}

```

上述例子中，func调用了g函数，在这种情况下当g函数运行完时无须返回到func函数中去，因此，栈中就不需要保存func的信息。**CAUTION**: `return g()`不能有多余的操作。尾递归其实就是一种尾调用。*但是现在一些编译器没有真的实现尾递归*。    

## 五、继承与组合   

+ 目中减少使用继承，另外也不宜使用深继承。因为继承使用对象之间形成强耦合关系。   

## 六、命令式编程，函数式编程及响应式编程

+ 在命令式编程环境中, a= b+c  表示将表达式b+c的结果赋给a ，而之后b改变 或 c 的值不会影响a 。但在响应式编程中，a 的值会随着 b 或 c 的更新而更新。   

+ 一般的编程语言是命令式编程（指令式编程），响应式可以联想到KVO,Notification   
+ 函数式编程是以函数为主[参考](http://coolshell.cn/articles/10822.html)

## 七、void *test = &test 理解：“=”是左结合性运算符，所以就可以理解了，然后就是void *是可以指向任何指针，so done




